From e16423d005113346392dc7417fe8bb95200d321b Mon Sep 17 00:00:00 2001
From: Xiao-Long Chen <chenxiaolong@cxl.epac.to>
Date: Sun, 25 Aug 2013 22:28:41 -0400
Subject: [PATCH] vold: Allow ASEC containers on external SD when internal is
 emulated

WARNING: This an initial implementation for Android 4.4 Kit Kat.
It may or may not work properly.

* This modifies Volume::mountVol() and Volume::unmountVol to call
  mountAsecExternal() to set up .android_secure/ regardless if the
  volume is primary or not. On devices where emulated internal
  storage is used, the emulated storage is primary. Without this
  patch, /data/secure/asec/ and the tmpfs over .android_secure/
  won't be mounted.

Thanks to Pierre-Hugues Husson for the idea in this patch! The initial
implementation called createBindMounts() on all mount points regardless
of whether or not it was the SD card.

Change-Id: Ic2c45d275179099065a10e1e664a08efea66acf1
---
 Volume.cpp | 25 ++++++++++++++++++++++---
 Volume.h   |  1 +
 2 files changed, 23 insertions(+), 3 deletions(-)

diff --git a/Volume.cpp b/Volume.cpp
index 820d69e..4046084 100644
--- a/Volume.cpp
+++ b/Volume.cpp
@@ -184,6 +184,23 @@ int Volume::handleBlockEvent(NetlinkEvent *evt) {
     return -1;
 }
 
+bool Volume::isExternalSd() {
+    const char* externalSdPath1 = getenv("EXTERNAL_SD") ? : "/storage/sdcard1";
+    // Necessary for Kit Kat
+    const char* externalSdPath2 = "/mnt/media_rw/sdcard1";
+    const char* disablePath = "/data/system/no-external-apps";
+
+    if (strcmp(getMountpoint(), externalSdPath1) == 0
+          || strcmp(getMountpoint(), externalSdPath2) == 0) {
+        if (access(disablePath, F_OK) != -1) {
+            SLOGV("Application moving disabled; will not touch ASEC\n");
+            return false;
+        }
+        return true;
+    }
+    return false;
+}
+
 void Volume::setState(int state) {
     char msg[255];
     int oldState = mState;
@@ -323,6 +340,7 @@ int Volume::mountVol() {
     dev_t deviceNodes[4];
     int n, i, rc = 0;
     char errmsg[255];
+    bool externalSd = isExternalSd();
 
     int flags = getFlags();
     bool providesAsec = (flags & VOL_PROVIDES_ASEC) != 0;
@@ -516,7 +534,8 @@ int Volume::mountVol() {
         protectFromAutorunStupidity();
 
 #ifndef MINIVOLD
-        if (providesAsec && mountAsecExternal() != 0) {
+        // Create android_secure on external SD
+        if ((externalSd || providesAsec) && mountAsecExternal() != 0) {
             SLOGE("Failed to mount secure area (%s)", strerror(errno));
             umount(getMountpoint());
             setState(Volume::State_Idle);
@@ -623,7 +642,7 @@ int Volume::unmountVol(bool force, bool revert) {
 
     // TODO: determine failure mode if FUSE times out
 
-    if (providesAsec && doUnmount(Volume::SEC_ASECDIR_EXT, force) != 0) {
+    if ((isExternalSd() || providesAsec) && doUnmount(Volume::SEC_ASECDIR_EXT, force) != 0) {
         SLOGE("Failed to unmount secure area on %s (%s)", getMountpoint(), strerror(errno));
         goto out_mounted;
     }
@@ -657,7 +676,7 @@ int Volume::unmountVol(bool force, bool revert) {
     return 0;
 
 fail_remount_secure:
-    if (providesAsec && mountAsecExternal() != 0) {
+    if ((isExternalSd() || providesAsec) && mountAsecExternal() != 0) {
         SLOGE("Failed to remount secure area (%s)", strerror(errno));
         goto out_nomedia;
     }
diff --git a/Volume.h b/Volume.h
index 5f5b3f4..546098e 100644
--- a/Volume.h
+++ b/Volume.h
@@ -73,6 +73,7 @@ public:
     int formatVol(bool wipe);
 
     const char *getLabel() { return mLabel; }
+    bool isExternalSd();
     int getState() { return mState; }
     int getFlags() { return mFlags; };
 
-- 
1.8.4.2


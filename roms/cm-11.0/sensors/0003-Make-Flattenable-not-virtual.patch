From 5489ce8c3a0aa87fe97b4c3272797b713210f114 Mon Sep 17 00:00:00 2001
From: kejar31 <justin.a.rogers@gmail.com>
Date: Tue, 12 Nov 2013 13:16:43 -0600
Subject: [PATCH 3/3] Make Flattenable not virtual

---
 include/gui/Sensor.h |   4 +-
 libs/gui/Sensor.cpp  | 129 ++++++++++++++++++++++++++-------------------------
 2 files changed, 67 insertions(+), 66 deletions(-)

diff --git a/include/gui/Sensor.h b/include/gui/Sensor.h
index 2a218ba..de8e3a5 100644
--- a/include/gui/Sensor.h
+++ b/include/gui/Sensor.h
@@ -70,8 +70,8 @@ public:
 
     // LightFlattenable protocol
     inline bool isFixedSize() const { return false; }
-    size_t getSize() const;
-    status_t flatten(void* buffer) const;
+    size_t getFlattenedSize() const;
+    status_t flatten(void* buffer, size_t size) const;
     status_t unflatten(void const* buffer, size_t size);
 
 private:
diff --git a/libs/gui/Sensor.cpp b/libs/gui/Sensor.cpp
index 1259557..ad9a4e4 100644
--- a/libs/gui/Sensor.cpp
+++ b/libs/gui/Sensor.cpp
@@ -98,87 +98,88 @@ int32_t Sensor::getVersion() const {
     return mVersion;
 }
 
-size_t Sensor::getSize() const
+size_t Sensor::getFlattenedSize() const
 {
-    return  sizeof(int32_t) + ((mName.length() + 3) & ~3) +
-            sizeof(int32_t) + ((mVendor.length() + 3) & ~3) +
+    size_t fixedSize =
             sizeof(int32_t) * 3 +
             sizeof(float) * 4 +
             sizeof(int32_t);
-}
 
-static inline
-size_t write(void* buffer, size_t offset, const String8& value) {
-    memcpy(static_cast<char*>(buffer) + offset, value.string(), value.length());
-    return (value.length() + 3) & ~3;
-}
+    size_t variableSize =
+            sizeof(int32_t) + FlattenableUtils::align<4>(mName.length()) +
+            sizeof(int32_t) + FlattenableUtils::align<4>(mVendor.length());
 
-static inline
-size_t write(void* buffer, size_t offset, float value) {
-    *reinterpret_cast<float*>(static_cast<char*>(buffer) + offset) = value;
-    return sizeof(float);
+    return fixedSize + variableSize;
 }
 
-static inline
-size_t write(void* buffer, size_t offset, int32_t value) {
-    *reinterpret_cast<int32_t*>(static_cast<char*>(buffer) + offset) = value;
-    return sizeof(int32_t);
-}
+status_t Sensor::flatten(void* buffer, size_t size) const {
+    if (size < getFlattenedSize()) {
+        return NO_MEMORY;
+    }
 
-status_t Sensor::flatten(void* buffer) const
-{
-    size_t offset = 0;
-    offset += write(buffer, offset, int32_t(mName.length()));
-    offset += write(buffer, offset, mName);
-    offset += write(buffer, offset, int32_t(mVendor.length()));
-    offset += write(buffer, offset, mVendor);
-    offset += write(buffer, offset, mVersion);
-    offset += write(buffer, offset, mHandle);
-    offset += write(buffer, offset, mType);
-    offset += write(buffer, offset, mMinValue);
-    offset += write(buffer, offset, mMaxValue);
-    offset += write(buffer, offset, mResolution);
-    offset += write(buffer, offset, mPower);
-    offset += write(buffer, offset, mMinDelay);
+    FlattenableUtils::write(buffer, size, mName.length());
+    memcpy(static_cast<char*>(buffer), mName.string(), mName.length());
+    FlattenableUtils::advance(buffer, size, FlattenableUtils::align<4>(mName.length()));
+
+    FlattenableUtils::write(buffer, size, mVendor.length());
+    memcpy(static_cast<char*>(buffer), mVendor.string(), mVendor.length());
+    FlattenableUtils::advance(buffer, size, FlattenableUtils::align<4>(mVendor.length()));
+
+    FlattenableUtils::write(buffer, size, mVersion);
+    FlattenableUtils::write(buffer, size, mHandle);
+    FlattenableUtils::write(buffer, size, mType);
+    FlattenableUtils::write(buffer, size, mMinValue);
+    FlattenableUtils::write(buffer, size, mMaxValue);
+    FlattenableUtils::write(buffer, size, mResolution);
+    FlattenableUtils::write(buffer, size, mPower);
+    FlattenableUtils::write(buffer, size, mMinDelay);
     return NO_ERROR;
 }
 
-static inline
-size_t read(void const* buffer, size_t offset, String8* value, int32_t len) {
-    value->setTo(static_cast<char const*>(buffer) + offset, len);
-    return (len + 3) & ~3;
-}
+status_t Sensor::unflatten(void const* buffer, size_t size) {
+    size_t len;
 
-static inline
-size_t read(void const* buffer, size_t offset, float* value) {
-    *value = *reinterpret_cast<float const*>(static_cast<char const*>(buffer) + offset);
-    return sizeof(float);
-}
+    if (size < sizeof(size_t)) {
+        return NO_MEMORY;
+    }
+    FlattenableUtils::read(buffer, size, len);
+    if (size < len) {
+        return NO_MEMORY;
+    }
+    mName.setTo(static_cast<char const*>(buffer), len);
+    FlattenableUtils::advance(buffer, size, FlattenableUtils::align<4>(len));
 
-static inline
-size_t read(void const* buffer, size_t offset, int32_t* value) {
-    *value = *reinterpret_cast<int32_t const*>(static_cast<char const*>(buffer) + offset);
-    return sizeof(int32_t);
-}
 
-status_t Sensor::unflatten(void const* buffer, size_t size)
-{
-    int32_t len;
-    size_t offset = 0;
-    offset += read(buffer, offset, &len);
-    offset += read(buffer, offset, &mName, len);
-    offset += read(buffer, offset, &len);
-    offset += read(buffer, offset, &mVendor, len);
-    offset += read(buffer, offset, &mVersion);
-    offset += read(buffer, offset, &mHandle);
-    offset += read(buffer, offset, &mType);
-    offset += read(buffer, offset, &mMinValue);
-    offset += read(buffer, offset, &mMaxValue);
-    offset += read(buffer, offset, &mResolution);
-    offset += read(buffer, offset, &mPower);
-    offset += read(buffer, offset, &mMinDelay);
+    if (size < sizeof(size_t)) {
+        return NO_MEMORY;
+    }
+    FlattenableUtils::read(buffer, size, len);
+    if (size < len) {
+        return NO_MEMORY;
+    }
+    mVendor.setTo(static_cast<char const*>(buffer), len);
+    FlattenableUtils::advance(buffer, size, FlattenableUtils::align<4>(len));
+
+    size_t fixedSize =
+            sizeof(int32_t) * 3 +
+            sizeof(float) * 4 +
+            sizeof(int32_t);
+
+    if (size < fixedSize) {
+        return NO_MEMORY;
+    }
+
+    FlattenableUtils::read(buffer, size, mVersion);
+    FlattenableUtils::read(buffer, size, mHandle);
+    FlattenableUtils::read(buffer, size, mType);
+    FlattenableUtils::read(buffer, size, mMinValue);
+    FlattenableUtils::read(buffer, size, mMaxValue);
+    FlattenableUtils::read(buffer, size, mResolution);
+    FlattenableUtils::read(buffer, size, mPower);
+    FlattenableUtils::read(buffer, size, mMinDelay);
     return NO_ERROR;
 }
 
+
 // ----------------------------------------------------------------------------
 }; // namespace android
-- 
1.8.4.2


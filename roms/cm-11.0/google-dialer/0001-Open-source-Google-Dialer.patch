From d8b9a9b83add997802e3e659d4ce64deec723a16 Mon Sep 17 00:00:00 2001
From: Xiao-Long Chen <chenxiaolong@cxl.epac.to>
Date: Mon, 30 Dec 2013 02:37:43 -0500
Subject: [PATCH] Open-source Google Dialer

20130115 - Merge Lars Greiss's changes (Slim ROMS PS10):
         - https://gerrit.slimroms.net/#/c/1996/

Change-Id: I3ccfd8e9a4c14565e36fe2a3daad9dd74b554706
---
 Android.mk                                         |  13 +-
 AndroidManifest.xml                                |  31 +-
 MergeTranslations.py                               | 131 +++++
 assets/contacts_extensions.properties              |   1 +
 proguard.flags                                     |   5 +
 res/drawable-hdpi/ic_action_settings_blue.png      | Bin 0 -> 630 bytes
 .../ic_places_picture_180_holo_light.png           | Bin 0 -> 698 bytes
 res/drawable-hdpi/ic_places_picture_holo_light.png | Bin 0 -> 424 bytes
 res/drawable-xhdpi/ic_action_settings_blue.png     | Bin 0 -> 737 bytes
 .../ic_places_picture_180_holo_light.png           | Bin 0 -> 1140 bytes
 .../ic_places_picture_holo_light.png               | Bin 0 -> 632 bytes
 res/drawable-xxhdpi/ic_action_settings_blue.png    | Bin 0 -> 559 bytes
 .../ic_places_picture_180_holo_light.png           | Bin 0 -> 1171 bytes
 .../ic_places_picture_holo_light.png               | Bin 0 -> 636 bytes
 res/layout/google_caller_id_setting.xml            |  40 ++
 res/layout/local_search_setting.xml                |  63 ++
 res/values/colors.xml                              |   6 +
 res/values/dimens.xml                              |   3 +
 src/com/android/dialer/DialtactsActivity.java      |   2 +-
 src/com/android/dialer/calllog/CallLogAdapter.java |   2 +-
 .../android/dialerbind/DatabaseHelperManager.java  |   3 +-
 src/com/android/dialerbind/ObjectFactory.java      |  14 +-
 src/com/google/android/common/http/UrlRules.java   | 234 ++++++++
 .../android/dialer/GoogleDialerDatabaseHelper.java | 115 ++++
 .../dialer/calllog/GoogleCallLogAdapter.java       | 188 ++++++
 .../DialerExtendedPhoneDirectoriesManager.java     |  65 +++
 .../dialer/extensions/GoogleDialtactsActivity.java |  48 ++
 .../CachedNumberLookupServiceImpl.java             | 298 ++++++++++
 .../phonenumbercache/PhoneNumberCacheContract.java |  48 ++
 .../phonenumbercache/PhoneNumberCacheProvider.java | 346 +++++++++++
 .../android/dialer/provider/DialerProvider.java    | 636 +++++++++++++++++++++
 .../dialer/reverselookup/PeopleApiClient.java      | 267 +++++++++
 .../dialer/reverselookup/PeopleJsonParser.java     | 337 +++++++++++
 .../dialer/reverselookup/PhoneNumberInfoImpl.java  |  96 ++++
 .../reverselookup/PhoneNumberServiceImpl.java      | 356 ++++++++++++
 .../reverselookup/ReverseLookupSettingUtil.java    |  65 +++
 .../settings/ActionBarSwitchSettingsFragment.java  |  87 +++
 .../settings/GoogleCallerIdSettingsFragment.java   |  66 +++
 .../settings/GoogleDialerSettingsActivity.java     | 118 ++++
 .../settings/LocalSearchSettingsFragment.java      |  69 +++
 .../google/android/dialer/util/AuthException.java  |  29 +
 .../dialer/util/GoogleLocationSettingHelper.java   |  98 ++++
 src/com/google/android/dialer/util/HelpUrl.java    |  55 ++
 .../google/android/dialer/util/HttpFetcher.java    | 164 ++++++
 src/com/google/android/dialer/util/JsonUtil.java   |  36 ++
 src/com/google/android/gsf/Gservices.java          | 237 ++++++++
 46 files changed, 4358 insertions(+), 14 deletions(-)
 create mode 100755 MergeTranslations.py
 create mode 100644 assets/contacts_extensions.properties
 create mode 100644 res/drawable-hdpi/ic_action_settings_blue.png
 create mode 100644 res/drawable-hdpi/ic_places_picture_180_holo_light.png
 create mode 100644 res/drawable-hdpi/ic_places_picture_holo_light.png
 create mode 100644 res/drawable-xhdpi/ic_action_settings_blue.png
 create mode 100644 res/drawable-xhdpi/ic_places_picture_180_holo_light.png
 create mode 100644 res/drawable-xhdpi/ic_places_picture_holo_light.png
 create mode 100644 res/drawable-xxhdpi/ic_action_settings_blue.png
 create mode 100644 res/drawable-xxhdpi/ic_places_picture_180_holo_light.png
 create mode 100644 res/drawable-xxhdpi/ic_places_picture_holo_light.png
 create mode 100644 res/layout/google_caller_id_setting.xml
 create mode 100644 res/layout/local_search_setting.xml
 create mode 100644 src/com/google/android/common/http/UrlRules.java
 create mode 100644 src/com/google/android/dialer/GoogleDialerDatabaseHelper.java
 create mode 100644 src/com/google/android/dialer/calllog/GoogleCallLogAdapter.java
 create mode 100644 src/com/google/android/dialer/extensions/DialerExtendedPhoneDirectoriesManager.java
 create mode 100644 src/com/google/android/dialer/extensions/GoogleDialtactsActivity.java
 create mode 100644 src/com/google/android/dialer/phonenumbercache/CachedNumberLookupServiceImpl.java
 create mode 100644 src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheContract.java
 create mode 100644 src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheProvider.java
 create mode 100644 src/com/google/android/dialer/provider/DialerProvider.java
 create mode 100644 src/com/google/android/dialer/reverselookup/PeopleApiClient.java
 create mode 100644 src/com/google/android/dialer/reverselookup/PeopleJsonParser.java
 create mode 100644 src/com/google/android/dialer/reverselookup/PhoneNumberInfoImpl.java
 create mode 100644 src/com/google/android/dialer/reverselookup/PhoneNumberServiceImpl.java
 create mode 100644 src/com/google/android/dialer/reverselookup/ReverseLookupSettingUtil.java
 create mode 100644 src/com/google/android/dialer/settings/ActionBarSwitchSettingsFragment.java
 create mode 100644 src/com/google/android/dialer/settings/GoogleCallerIdSettingsFragment.java
 create mode 100644 src/com/google/android/dialer/settings/GoogleDialerSettingsActivity.java
 create mode 100644 src/com/google/android/dialer/settings/LocalSearchSettingsFragment.java
 create mode 100644 src/com/google/android/dialer/util/AuthException.java
 create mode 100644 src/com/google/android/dialer/util/GoogleLocationSettingHelper.java
 create mode 100644 src/com/google/android/dialer/util/HelpUrl.java
 create mode 100644 src/com/google/android/dialer/util/HttpFetcher.java
 create mode 100644 src/com/google/android/dialer/util/JsonUtil.java
 create mode 100644 src/com/google/android/gsf/Gservices.java

diff --git a/Android.mk b/Android.mk
index 899d589..ba6b1b9 100644
--- a/Android.mk
+++ b/Android.mk
@@ -9,13 +9,18 @@ incallui_dir := ../InCallUI
 src_dirs := src $(contacts_common_dir)/src $(incallui_dir)/src
 res_dirs := res $(contacts_common_dir)/res $(incallui_dir)/res
 
+# Google Play Services resource files
+res_dirs += ../../../external/google/google_play_services/libproject/google-play-services_lib/res
+
 LOCAL_SRC_FILES := $(call all-java-files-under, $(src_dirs))
 LOCAL_RESOURCE_DIR := $(addprefix $(LOCAL_PATH)/, $(res_dirs))
+LOCAL_ASSET_DIR := $(LOCAL_PATH)/assets
 
 LOCAL_AAPT_FLAGS := \
     --auto-add-overlay \
     --extra-packages com.android.contacts.common \
-    --extra-packages com.android.incallui
+    --extra-packages com.android.incallui \
+    --extra-packages com.google.android.gms
 
 LOCAL_JAVA_LIBRARIES := telephony-common
 LOCAL_STATIC_JAVA_LIBRARIES := \
@@ -27,6 +32,7 @@ LOCAL_STATIC_JAVA_LIBRARIES := \
     android-support-v13 \
     android-support-v4 \
     android-ex-variablespeed \
+    googleplayservices
 
 LOCAL_REQUIRED_MODULES := libvariablespeed
 
@@ -38,5 +44,10 @@ LOCAL_PROGUARD_FLAG_FILES := proguard.flags $(incallui_dir)/proguard.flags
 
 include $(BUILD_PACKAGE)
 
+include $(CLEAR_VARS)
+LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := \
+    googleplayservices:../../../external/google/google_play_services/libproject/google-play-services_lib/libs/google-play-services.jar
+include $(BUILD_MULTI_PREBUILT)
+
 # Use the following include to make our test apk.
 include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index c1fbcd7..75e96c3 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -51,6 +51,10 @@
      presses home. -->
     <uses-permission android:name="android.permission.STOP_APP_SWITCHES" />
 
+    <!-- Google Dialer -->
+    <uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" />
+    <uses-feature android:name="com.google.android.feature.GOOGLE_EXPERIENCE" android:required="true" />
+
     <application
         android:name="DialerApplication"
         android:label="@string/applicationLabel"
@@ -65,14 +69,14 @@
         <!-- The entrance point for Phone UI.
              stateAlwaysHidden is set to suppress keyboard show up on
              dialpad screen. -->
-        <activity android:name=".DialtactsActivity"
+        <activity android:name="com.google.android.dialer.extensions.GoogleDialtactsActivity"
             android:label="@string/launcherDialer"
             android:theme="@style/DialtactsTheme"
             android:launchMode="singleTask"
             android:clearTaskOnLaunch="true"
             android:icon="@mipmap/ic_launcher_phone"
             android:screenOrientation="portrait"
-            android:enabled="@*android:bool/config_voice_capable"
+            android:enabled="@*android:bool/config_enableNetworkLocationOverlay"
             android:windowSoftInputMode="stateAlwaysHidden|adjustNothing">
             <intent-filter>
                 <action android:name="android.intent.action.DIAL" />
@@ -167,6 +171,11 @@
             </intent-filter>
         </activity>
 
+        <activity android:name="com.google.android.dialer.settings.GoogleDialerSettingsActivity"
+            android:label="@string/dialer_settings_label"
+            android:parentActivityName="com.google.android.GoogleDialtactsActivity"
+            android:theme="@*android:style/Theme.Holo.Light" />
+
         <activity android:name="com.android.contacts.common.test.FragmentTestActivity">
             <intent-filter>
                 <category android:name="android.intent.category.TEST"/>
@@ -175,19 +184,19 @@
 
         <!-- Backwards compatibility: "Phone" from Gingerbread and earlier -->
         <activity-alias android:name="DialtactsActivity"
-            android:targetActivity=".DialtactsActivity"
+            android:targetActivity="com.google.android.dialer.extensions.GoogleDialtactsActivity"
             android:exported="true"
         />
 
         <!-- Backwards compatibility: "Call log" from Gingerbread and earlier -->
         <activity-alias android:name="RecentCallsListActivity"
-            android:targetActivity=".DialtactsActivity"
+            android:targetActivity="com.google.android.dialer.extensions.GoogleDialtactsActivity"
             android:exported="true"
         />
 
         <!-- Backwards compatibility: "Call log" from ICS -->
         <activity-alias android:name=".activities.CallLogActivity"
-            android:targetActivity=".DialtactsActivity"
+            android:targetActivity="com.google.android.dialer.extensions.GoogleDialtactsActivity"
             android:exported="true"
         />
 
@@ -242,7 +251,7 @@
         <!-- end vCard related -->
 
         <receiver android:name=".calllog.CallLogReceiver"
-            android:enabled="@*android:bool/config_voice_capable">
+            android:enabled="@*android:bool/config_enableNetworkLocationOverlay">
             <intent-filter>
                 <action android:name="android.intent.action.NEW_VOICEMAIL" />
                 <data
@@ -304,5 +313,15 @@
             </intent-filter>
         </receiver>
 
+        <provider android:name="com.google.android.dialer.provider.DialerProvider"
+                  android:authorities="com.google.android.dialer.provider"
+                  android:exported="false"
+                  android:multiprocess="false" />
+
+        <provider android:name="com.google.android.dialer.phonenumbercache.PhoneNumberCacheProvider"
+                  android:authorities="com.google.android.dialer.cacheprovider"
+                  android:exported="false"
+                  android:multiprocess="false" />
+
     </application>
 </manifest>
diff --git a/MergeTranslations.py b/MergeTranslations.py
new file mode 100755
index 0000000..25f44f9
--- /dev/null
+++ b/MergeTranslations.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python3
+
+# Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Hacky way to merge Google's translations
+
+import os
+import re
+import sys
+
+names = [
+  'dialer_settings_label',
+  'dialer_hint_find_contact',
+  'call_settings_label',
+  'view_location_settings',
+  'enable_reverse_lookup',
+  'reverse_lookup_enabled',
+  'google_caller_id_setting_title',
+  'google_caller_id_setting__on',
+  'google_caller_id_setting__off',
+  'google_caller_id_settings_text',
+  'local_search_directory_label',
+  'local_search_setting_title',
+  'local_search_setting_on',
+  'local_search_setting_off',
+  'local_search_settings_text'
+]
+
+MAGIC_BEGIN = 'BEGIN: do not remove'
+MAGIC_END = 'END: do not remove'
+COMMENT = '    <!-- Google Dialer (auto merged, do not edit) (%s) -->\n'
+
+if len(sys.argv) != 2:
+    print("Usage: %s [Google's res dir]" % __file__)
+    sys.exit(1)
+
+olddir = sys.argv[1]
+newdir = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'res')
+
+for directory in os.listdir(olddir):
+    if not directory.startswith('values'):
+        continue
+
+    strings_old = os.path.join(olddir, directory, 'strings.xml')
+    if not os.path.exists(strings_old):
+        print("Old %s does not have strings.xml" % directory)
+        continue
+
+    strings_new = os.path.join(newdir, directory, 'strings.xml')
+    if not os.path.exists(strings_new):
+        print("New %s does not have strings.xml" % directory)
+        continue
+
+    tempnames = dict()
+
+    f = open(strings_old, 'r')
+    lines = f.readlines()
+    f.close()
+
+    # Get Google's translations
+    i = 0
+    while i < len(lines):
+        for j in names:
+            if 'name="%s"' % j in lines[i]:
+                temp = lines[i]
+                while '</string>' not in lines[i]:
+                    i += 1
+                    temp += lines[i]
+
+                if j == 'dialer_hint_find_contact':
+                    temp = re.sub('dialer_hint_find_contact',
+                                  'dialer_hint_find_contact_google', temp)
+                tempnames[j] = temp
+
+        i += 1
+
+    f = open(strings_new, 'r')
+    lines = f.readlines()
+    f.close()
+
+    # Remove old translations
+    i = 0
+    while i < len(lines):
+        if MAGIC_BEGIN in lines[i]:
+            while MAGIC_END not in lines[i]:
+                del lines[i]
+            if MAGIC_END in lines[i]:
+                del lines[i]
+            break
+        i += 1
+
+    # Merge new translations
+    f = open(strings_new, 'w')
+
+    first = True
+    resources = False
+    i = 0
+    while i < len(lines):
+        f.write(lines[i])
+        if first:
+            if 'resources' in lines[i]:
+                first = False
+
+                while '>' not in lines[i]:
+                    i += 1
+                    f.write(lines[i])
+
+                f.write(COMMENT % MAGIC_BEGIN)
+
+                for j in names:
+                    if j in tempnames:
+                        f.write(tempnames[j])
+
+                f.write(COMMENT % MAGIC_END)
+
+        i += 1
+
+    f.close()
diff --git a/assets/contacts_extensions.properties b/assets/contacts_extensions.properties
new file mode 100644
index 0000000..f9bad0b
--- /dev/null
+++ b/assets/contacts_extensions.properties
@@ -0,0 +1 @@
+extendedPhoneDirectories=com.google.android.dialer.extensions.DialerExtendedPhoneDirectoriesManager
diff --git a/proguard.flags b/proguard.flags
index 40ef035..c74dfd1 100644
--- a/proguard.flags
+++ b/proguard.flags
@@ -12,4 +12,9 @@
 @com.android.dialer.NeededForReflection *;
 }
 
+# Keep DialerExtendedPhoneDirectoriesManager for assets/contacts_extensions.properties
+-keep class com.google.android.dialer.extensions.DialerExtendedPhoneDirectoriesManager extends * {
+  *;
+}
+
 -verbose
diff --git a/res/drawable-hdpi/ic_action_settings_blue.png b/res/drawable-hdpi/ic_action_settings_blue.png
new file mode 100644
index 0000000000000000000000000000000000000000..c6ca73badb92ebb17395769c9052f9cc2279100a
GIT binary patch
literal 630
zcmeAS@N?(olHy`uVBq!ia0vp^1|ZDA3?vioaBc-s+XH+;T!FOl)~7=bb^p8v@|$f*
zkY6wZ10xHoR6%pPAd~#P|G$rNHvIVcE0TH2pWMmWynNgW@4kQe`uWDh)K9nBWC{h2
zaVg$E%pu(r_8?8RNbU&tbwe|t0fwF~jv*e$-%gDVK4c)!YUwK~%`47&#Jg2Yq?PI3
z2e$wJ%XhAIxcz0?7XCitch2cXo72nAKYP6_?6)`Lfdn;UhE&F<m)t`iK9`rd)~_Sc
zC2G;<@8WC{-Nj|F<><>u_mYd=h0}$2o`)>Z*Gpha7pZXMpWgU@ODC`~Uj6X4?@Xud
z@3)9rusI)>J(_%H|It{588^Q7y*86``h1J&?KH0$_xh*K4xX&tZ_4L??x^dh^tf81
z`?GE@+8B|x=-|g6F1j}RStR%UyBhuUfV=IQ7H8W%f4@xV{eEuC8zZ~sB`@b#F59ef
ze~Jj_G!-$GprD9L0vX#w4wanTs1+Z>(p#=2=-B-2(s3JU-cvvRa2Z=%v#XgMw$6$3
z{U!Sg|Ko!0cu&1n`!H_RpA^w|OIMv=_wVq(=#RV|r(O5=g-`GS#sY(<tDnm{r-UW|
DRje-&

literal 0
HcmV?d00001

diff --git a/res/drawable-hdpi/ic_places_picture_180_holo_light.png b/res/drawable-hdpi/ic_places_picture_180_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..f0bbe73459344c4dafbc47fa6b15ad5e230b01b8
GIT binary patch
literal 698
zcmeAS@N?(olHy`uVBq!ia0y~yVB`Z~4xj)-?5$;$3=B+-o-U3d6}R5rx$DPdD8Lrr
z=J@gdU-`4k4YEw!&i0wB1?hE3Z}UECT)r%4v+cA=jr!8xxxWUha}+!{(8$crCu4!k
zScuF)NIO5oqPCH_{SZP4vQe$b9Eb&v?XP??*YAqV*R*~vv2K0a%{+~`_(h-ZZtR%x
z@$PK)Ck18LoYRP~_)Pd|O|_d{3P*N4RDRsC{drOA_Vn2dAOD3sy0hkU{M)`?1!>23
zAHIp~puXh%55*l>?&du&zyGs4{weMC`=q0lRd*M3zMHNbp57hBz5ndR;&%I!vsJ%K
zmQ8sC^P>jP$!BgH@|DUsVUanr;>0tV%WP7glI{jQR!qMy`}N`6zjYSYGD{HwC(@Uu
zJIBG<vfbhEvnp1pV{7~u98~892W<dY)#CYL>)r}WmBre={4D>g-s$k;=g;0$)<wtt
z{SwEs{@t$IKvOsVt^4_F&G~)rr*ob|i4~dZ=KE$B0?y5IuC?Glf6?qhK_tVItn7oY
zQ+;;a{>^U^<MQ=Y>6@=#9lOoFFFPDwQ^@JAiEKcXUSr!zOBShD{}=q);LyBS1QO|B
zmlYlm^INcRj`M<rJDeNa1h*?(crck2EDs6<EKw40|Lf}e8Olt@`;Q&>mOEKgzV<P<
Xa?2V1Oo`GKP@?p7^>bP0l+XkKCiF3c

literal 0
HcmV?d00001

diff --git a/res/drawable-hdpi/ic_places_picture_holo_light.png b/res/drawable-hdpi/ic_places_picture_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..f70e8e711155f7ee77fc2b3fc42e1e62f059720f
GIT binary patch
literal 424
zcmV;Z0ayNsP)<h;3K|Lk000e1NJLTq003YB003YJ00000$MY!U0004RNkl<ZXx{CZ
z(Q<+?5Jm3|=oF~_|F88wq(zO~K18uvDFI^#+szC!3zKkQ6AlY}!(*F+0SsUO0~o*n
z1~7mD3}65Q{1PC)*i+mfP6n)FhSJwl0bFJg_dr)qPmyAhBwMBi_|vNRrUPAt2?3h}
zp+zYGwI`HUN(<O}9xs}^9ie5FIz{9uIbXtOnq(<#mtjJ{f`qcrM}+d!fK|6P^?J`T
zHB~%D6@$~k391Mo04Q4z0qS<VD%$dVeJ?{*K`q{;ilG!~ma0e&$Z=Lh+l2`MYg5Ji
ztBT07qZd#g04)mveBWQF;&}d#9RXJXV6!E_ilYFHCxik3wpXeMZQl^eN&@uFiIuXd
z2uDvnddrR(t0Hs=+Eo987^8|Tzom+BlmOsz_U0l+6{}mTP-QpkZBdvio>LW`<5V&B
zNp3vR230isepOWHR8exYDqI-ieozHW6`d5^kSb`ZFn|I6%L_-7|9SL&qkRI9X}H1T
S^IK8?0000<MNUMnLSTYfm#kR;

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_action_settings_blue.png b/res/drawable-xhdpi/ic_action_settings_blue.png
new file mode 100644
index 0000000000000000000000000000000000000000..36ef2b8fc1c6211351d88156918b57aec7aeb400
GIT binary patch
literal 737
zcmeAS@N?(olHy`uVBq!ia0vp^4j|0I3?%1nZ+ru!&II^`xB_Y8txtysvaEPl5A=^q
zNswPK0|O%qt6u+_)%6lgF7N-}P`dQ%_dNN3*ED{r^9BY7xvMercxpaZz4?LtvcbeU
zF=dY{3i^#wY*%M0{{5&cZZzrL-0PCpmI$u_n$zIv;usQf_-**@phE@%XO{(D$hr{L
zt+b-Tb<h2y*1!J$cVSw(^o-jj-_n{Fm6__BEhoQuchfR)&5`>I3_H|Yj$h@U=#by~
zuzgp3-oBvNh!A@fCi!X8mOACK*4*MevWn-B!G!Dsnk+Kc4tvNdbiI<hz+q<gl~*ZJ
zn2jmnj<NFwHv=_~M+sdFb%$6E9!Z*(u==J^!tSky%Z{_W-TN#f*FKu>9N!Yj_BR@8
z7Hw{Ou32hMJMfc>RpsKwo^!oZuI{s6`nP6nPey#_%4}V=y&u1<39{Yqv335bpGDi|
zgnkHhXOF+Ha&Xp{u!;BXM)Qd9@%Jx&Y`66IS>sC<U)ngU`*vj>ns7uc#AwOH3(F2B
z%wf;Cz36XmC#Nu<p21_A153IOTJU$UoD0`b=<G`^$y;)B?U}dHHv@g5&gpl|iQj5p
zv3bH~zPkS>*j_h&TIu=Pmb<>8f6EQ|FS>skKL_akb$rSHuigF!@9NpVn(fZ!sQ-J=
ro%21p{)2B#frWi#(a&Zf79NJWGoiD2wO5}8#w~-VtDnm{r-UW|FHmS$

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_places_picture_180_holo_light.png b/res/drawable-xhdpi/ic_places_picture_180_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..6409ab185d7ae07f5bbbe65011f317b26fd6fb22
GIT binary patch
literal 1140
zcmeAS@N?(olHy`uVBq!ia0y~yV9Wqv4xj)-e4iaB0|Se-r;B4q#jUq@Z|2={5NSv}
zmczJ7^Zoy%+O93Wn>U=8JUeXfjLBIOB)8T5Uz*zUlc{XUWX_kjJ&vz%W{}$A(9EWL
zVF9a@Nk$`x;m8eQ@J4|d7nnedX0Z$)1Ednj0IH<3mM`^}Qr^2SDX!-HskQL)pN00u
z&!5*UegEQ#)dMMBDHA4A9Dj9(=Wb{B*H4Pp{mp#Nvuo4!*qyn1biQ8xrd#plk6QD(
z?9F=jR{kv!+;jGK>4w}lmjY{FzTmo|7gs8s^LAZs?Yh~D;GjUW^o!`#5)0`w?2m07
z`CqQPWO9DqB3a*qtM6ar{Z`V8HO$fjF3(If?DhI+bT;A8q*vl4^9o+3ulrwgeA;WC
z-y!pEm_(&Ztod_h@~hUi&zBvS*G=~0|GP_X;qv~2DK+118}{v8`^B4o`EI!-{a+;=
z*txBWSM3da@~iPJ=YHn${=mJn7v8sW07m2m4%9dc4>`=~&6n2p(M4&-#F*Rmw{to7
zMzJhjli~RMiQ%mb$MoFIx9rVdJbSwB$$$6j@m5}|^gn!BQRZ*%j4esjvTdES!9_aw
z?Yx&C{O7s3SA9};-alov*XJku{%|b)>iyx<^wo@)*KGMKC{rZ3R`BmvK^?=r^PhQF
zxj&!f8^34er-$}_mHqtlvbW4$h$R*NUA&Cjs(XG?ylvu3c0RjR{E~B?E_FQL6mHOW
zY~Dqy!;R|G7CHMZwq4%+;No=CIkB#*Qx-?YZ7C|dA@$T|o!yfpORGQ6U!IuW_iA(Q
zhyO*t56@o;3Ktg4l>WNhcR$zGJ7VXJ7tQ~6;H3Lk#lt@n>H{yVKWILuZ~DPcC*MYY
zc=7Y>1lGB`=WlJVxzEBM@28jP_&hE4-_C<2g0;`zSluv_`*O$9Dy3Zb&CXi>YoGM=
zUSA5V6U`Do|FL=P-2<KVUlp4-=WG<YbM`{MEFup%Dl<TG*o*8{FAKJnm0e6&H1V6o
z+2lF?-Y<50HP}>lmC0;bP#jcy;`Y^r^Z)#K|AMVL?%3qrZo4I$NXnK{xBi{Jzsu*X
oe|62&=ld>Xen0a)zjo^v^~&hge`h5G`h$uSPgg&ebxsLQ0D^f73jhEB

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_places_picture_holo_light.png b/res/drawable-xhdpi/ic_places_picture_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..7c92a6030c376ce8947d96c278b6c6c157eee92c
GIT binary patch
literal 632
zcmeAS@N?(olHy`uVBq!ia0vp^4Is<`Bp9BB+KDqTFxh*$IEGZ*dOPcO*<u48*Zv-7
zh3)75{Ga~Sc-izVmjzbyCoQvhT%g@J)wF%OPIGQqj_k=GrT&O-MG6dz91aXj0u2l-
zSeOY9Pyes>cJo<$nXx5SlI{GbkdrA4k7^<+xI<Plfi*?k5M7?USZ%g3!<;6DfOOff
zDf0KuvMQWcXB600&8qNl`bQbBxw+gf3>_}M9H9;kl8i}<XWwG84qd>0d3G>E!1sjh
zn}5m#itV<u->CeC?ZQeUfmILA9p1>YrS-Am$tgT67V}se)?NFyY_aQMqi(C*U(7qc
z^Gk~Kt*yTyD%KazoA7jT__V*alSB5W-Voby;=84XQxEethbdY+%q4Gq`*-)rE=%PD
zUJMStWm=UpDjr%L{%E(UxN?TAeu9b0f%^9yPgXK9=$dmmoIC%FecS66nI~`0p4-@N
zU#ZKGu=ncw6B{<YvFP9Y^~n?=zl(=An{JLyIUa6p?p(g!XO>$9`$G$kh6RD2XGI<t
zTcyi(TRvg(ZOtv)R!0S$Ox$(LvpAIdzKoTbjQAy+juYFSimdv%>!*R-ud~7zuPgDt
zxcz#KkLVrWwGq*iFPA)zD}DMdA>?{T&dM#TxXnG;<<GdNdh^Ok_q~q#_-s*FjLN=g
z*88{^zS`%$INi>0;n4!&8wX|_niIgv5+UWVyuf8wfA&%PH8a<Uwk!4Dxwy`<WQ+1H
z4ZiKyx?;s_zfP_=<al!<-+iW4kXZh+RqOCty_bJZx}7)wYdt^a%s<X|+DDmZ-AM2P
OB`Hr=KbLh*2~7aMkP%A&

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_action_settings_blue.png b/res/drawable-xxhdpi/ic_action_settings_blue.png
new file mode 100644
index 0000000000000000000000000000000000000000..03a9800ee4fcd2a6c39123cd7ae6ecf784bffd3f
GIT binary patch
literal 559
zcmeAS@N?(olHy`uVBq!ia0vp^2_VeD3?#3*wSy#P2Ka=y{{R2qc<a+ah}yPjO#nL5
zxFpCgn1Lbez?c6om+3Ih`W2e?RpDX3%n98~k1`Y^4?kb5x!{NI3WL1I?FVHSYQ-H{
zIx{e}FIaz(NX`ca21X%I7srr{dv9mF<Z5z|aNRs7>(m(??cDp{zy6iiJA8#P_rgMd
zj(0!RC${H2iOXBb!oaZeLQ&AV7d@fbUyrcw7yQ7+ogrn?B*txcTZKtmXaisCfxh?W
zcZoF3Qz%eqP;mLvC!?+?ps&j@h1Fu2fQXI)zsy>HnVGi~`2H?j)v$Zs{TjE&oPoIy
zFQ3;<`+Vj8gQ{imd&In-KHAzP*Od3Xs!EczM)rTNG?!zvMMpGO<D1YXh9;hc`u(Mr
zVl1baWP&;V=@*<(4(9nQ+u88`>DHqh-xf9hiaXN3y!^A}_2BO7s#oGOzb%SxtiC8)
zEy!}CdxLnQeiK7=;IzFRDn>{5cBp-My!VA;aP*?RFJ|tnU}QKT9>>>gyQSO3*BThO
N44$rjF6*2UngD>%2X_Df

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_places_picture_180_holo_light.png b/res/drawable-xxhdpi/ic_places_picture_180_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..97b98225783cd4741d87f6365aa2a00756cc5e7a
GIT binary patch
literal 1171
zcmeAS@N?(olHy`uVBq!ia0y~yV3Gl04xj+TjHwz67#LWhJY5_^DsH{Kb2h8RK&0W~
zHVw6oT^aZP@BPJR+%4EHn0|5Jfdb8xx**H+>OiMI9lQ6`??0F;zm1_#f$vD8g#h~_
z2bm6LAP2#M2oqG`AcJPY5k{C<FoV$*G+IC{gDL1>MzA0b!cb7yfaFN9YOr&W^kFD?
zM9}RR3JAL$!*d<XdD-v2En9#0-Nlc`Phv<@#qT$mko>8@_if$E6xq*WeZOV;uB*yy
zpUnUE2}*cjcndR91y(-gYTNkY<&+vvb$Hxk`W|b<G&60DIcSjoaL4(F6|sj3twq<q
z{rtb~Uh`z;{h|nWB3Q5_h8bZ$CP%GHkm#Q0cXE135hA1zESMG)?}0c#(=`H4i}D~s
z;j;4dx?OFL7jhq;UTpD>O`W|?8={+tD9Hh<X;xnW4V1VYUpD=gEh;N|u)PVC?1%_Z
zsGHY^Lml;FQBx`B@wZ=2ES<mZVa1C>AD_zf?LK(2@je$McVMJem{$>T6%AJNfHP}n
zQ=(3l)lzZ2y>IH;=ggJ)u@-C_wm?DX28IxZ0^&1KGnYwu_2q+U@6PH=?@&B7_w|-e
QU}3}H>FVdQ&MBb@0B}N`{{R30

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_places_picture_holo_light.png b/res/drawable-xxhdpi/ic_places_picture_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..43029bd81bf60c5a9fe13432d0955531f842c9bb
GIT binary patch
literal 636
zcmeAS@N?(olHy`uVBq!ia0vp^2SAtuNHCOdH@?llz~t=d;uunK>+NmFq9zA{)<h{b
zrh{6O@BB~N>7u2#rN_Z)wSi8QprpWx`%|xKeK2G;@t=A=<8HqN6UYoQK*DW?^1rIQ
zyOd_iPdNUN<5J8s_9=P_5B?~B_E+S!=$z6lfnw-3wgTl#tfs3k-?eRHjG6Vn_o_+e
z>d?DkbE8ch{Brj!_-(dr!snH1r>)eh=IXq&j*Hz8q&;Wn)DIK4-U^MiQ23nu%(_!U
z_s`{2<}X*XZkwDBzkKFpgBC>H1h1CeK^_Z29$h!*t^2X+n7*N*yOn(H`kIRmR=VUZ
z7216%V&bx!F9d(AN}U#x6u^DRkq2b_Y;V<Rd>%)o_L^+p)aANNXz9+|o~jnyj6kUa
z$AUW*yDw-mPW4xvBfsy~av{%n{e}O|%RJi8d(o>mtD-^XZOEev>!~mF7FzvS^Jwo{
zv-WSvAKQH_Ti^U~d@?aoV{hm=Cy*r@x<ZtsCVAc1zq-QUhQvIt8H=ayxijC(BW-WE
zQEf&Ti<fHGqjzCGcW0YQe5_lRrstp~XmaC$4hu-{5}{_ft^TT$b}X-YY8Cdgx6Jmc
zW>Dwn7a@;+uUzTkqIED5lmwOtW&5el*>?R-p4P<3tNTKnth3+OtX2$WDoKC0c~8fg
zyH*NQE2^`!3^V2~5ds+t2OGYIIHf#oh$;=7ot1x9KKb#Uon?>u%R%y<u6{1-oD!M<
Dj9u?@

literal 0
HcmV?d00001

diff --git a/res/layout/google_caller_id_setting.xml b/res/layout/google_caller_id_setting.xml
new file mode 100644
index 0000000..c944f88
--- /dev/null
+++ b/res/layout/google_caller_id_setting.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<!--
+     This is a reverse-engineered implementation of com.google.android.Dialer.
+     There is no guarantee that this implementation will work correctly or even
+     work at all. Use at your own risk.
+-->
+
+<LinearLayout
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <TextView
+        android:id="@id/text"
+        android:layout_width="fill_parent"
+        android:layout_height="fill_parent"
+        android:padding="26.0dip"
+        android:textSize="16.0sp"
+        android:textColor="@color/google_settings_text_color"
+        android:linksClickable="true"
+        android:singleLine="false"
+        android:fontFamily="sans-serif" />
+
+</LinearLayout>
diff --git a/res/layout/local_search_setting.xml b/res/layout/local_search_setting.xml
new file mode 100644
index 0000000..42e0010
--- /dev/null
+++ b/res/layout/local_search_setting.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<!--
+     This is a reverse-engineered implementation of com.google.android.Dialer.
+     There is no guarantee that this implementation will work correctly or even
+     work at all. Use at your own risk.
+-->
+
+<LinearLayout
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <TextView
+        android:id="@id/text"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:paddingLeft="26.0dip"
+        android:paddingTop="26.0dip"
+        android:paddingRight="26.0dip"
+        android:textSize="16.0dip"
+        android:textColor="@color/google_settings_text_color"
+        android:linksClickable="true"
+        android:singleLine="false"
+        android:fontFamily="sans-serif" />
+
+    <View
+        android:background="@color/google_settings_background"
+        android:layout_width="fill_parent"
+        android:layout_height="2.0dip"
+        android:layout_marginLeft="26.0dip"
+        android:layout_marginTop="24.0dip"
+        android:layout_marginRight="26.0dip" />
+
+    <TextView
+        android:id="@+id/view_location_settings"
+        android:layout_width="fill_parent"
+        android:layout_height="64.0dip"
+        android:layout_marginLeft="26.0dip"
+        android:layout_marginRight="26.0dip"
+        android:paddingLeft="10.0dip"
+        android:gravity="center_vertical"
+        android:textSize="18.0dip"
+        android:textColor="@color/google_settings_text_color"
+        android:text="@string/view_location_settings"
+        android:fontFamily="sans-serif" />
+
+</LinearLayout>
diff --git a/res/values/colors.xml b/res/values/colors.xml
index d405f3d..3e17757 100644
--- a/res/values/colors.xml
+++ b/res/values/colors.xml
@@ -76,4 +76,10 @@
     <color name="call_stats_outgoing">#99cc00</color>
     <color name="call_stats_missed">#eb1313</color>
     <color name="call_stats_bar_background">#88888888</color>
+
+    <!-- Text color for google dialer settings -->
+    <color name="google_settings_text_color">#ff555555</color>
+    <!-- Background google dialer settings -->
+    <color name="google_settings_background">#ffdedede</color>
+
 </resources>
diff --git a/res/values/dimens.xml b/res/values/dimens.xml
index aeccec8..fedc42a 100644
--- a/res/values/dimens.xml
+++ b/res/values/dimens.xml
@@ -16,6 +16,9 @@
   -->
 <resources>
 
+    <!-- Google Dialer -->
+    <dimen name="action_bar_switch_padding_right">16.0dip</dimen>
+
     <!-- Height of edit text in dialpad fragment -->
     <dimen name="dialpad_horizontal_margin">0dip</dimen>
     <dimen name="dialpad_vertical_margin">2dip</dimen>
diff --git a/src/com/android/dialer/DialtactsActivity.java b/src/com/android/dialer/DialtactsActivity.java
index 04934c7..ecd732b 100644
--- a/src/com/android/dialer/DialtactsActivity.java
+++ b/src/com/android/dialer/DialtactsActivity.java
@@ -512,7 +512,7 @@ public class DialtactsActivity extends TransactionSafeActivity implements View.O
         mSearchView = (EditText) findViewById(R.id.search_view);
         mSearchView.addTextChangedListener(mPhoneSearchQueryTextListener);
 
-        final String hintText = getString(R.string.dialer_hint_find_contact);
+        final String hintText = getString(R.string.dialer_hint_find_contact_google);
 
         // The following code is used to insert an icon into a CharSequence (copied from
         // SearchView)
diff --git a/src/com/android/dialer/calllog/CallLogAdapter.java b/src/com/android/dialer/calllog/CallLogAdapter.java
index bb84204..983f5d9 100644
--- a/src/com/android/dialer/calllog/CallLogAdapter.java
+++ b/src/com/android/dialer/calllog/CallLogAdapter.java
@@ -533,7 +533,7 @@ public class CallLogAdapter extends GroupingListAdapter
     }
 
     @VisibleForTesting
-    void enqueueRequest(String number, String countryIso, ContactInfo callLogInfo,
+    protected void enqueueRequest(String number, String countryIso, ContactInfo callLogInfo,
             boolean immediate) {
         mAdapterHelper.enqueueRequest(number, countryIso, callLogInfo, immediate);
     }
diff --git a/src/com/android/dialerbind/DatabaseHelperManager.java b/src/com/android/dialerbind/DatabaseHelperManager.java
index c929932..20e9839 100644
--- a/src/com/android/dialerbind/DatabaseHelperManager.java
+++ b/src/com/android/dialerbind/DatabaseHelperManager.java
@@ -19,10 +19,11 @@ package com.android.dialerbind;
 import android.content.Context;
 
 import com.android.dialer.database.DialerDatabaseHelper;
+import com.google.android.dialer.GoogleDialerDatabaseHelper;
 
 
 public class DatabaseHelperManager {
     public static DialerDatabaseHelper getDatabaseHelper(Context context) {
-        return DialerDatabaseHelper.getInstance(context);
+        return GoogleDialerDatabaseHelper.getInstance(context);
     }
 }
diff --git a/src/com/android/dialerbind/ObjectFactory.java b/src/com/android/dialerbind/ObjectFactory.java
index c43dffc..bcacd18 100644
--- a/src/com/android/dialerbind/ObjectFactory.java
+++ b/src/com/android/dialerbind/ObjectFactory.java
@@ -23,6 +23,8 @@ import android.content.Context;
 import com.android.dialer.calllog.CallLogAdapter;
 import com.android.dialer.calllog.ContactInfoHelper;
 import com.android.dialer.service.CachedNumberLookupService;
+import com.google.android.dialer.calllog.GoogleCallLogAdapter;
+import com.google.android.dialer.phonenumbercache.CachedNumberLookupServiceImpl;
 
 /**
  * Default static binding for various objects.
@@ -30,14 +32,18 @@ import com.android.dialer.service.CachedNumberLookupService;
 public class ObjectFactory {
 
     public static CachedNumberLookupService newCachedNumberLookupService() {
-        // no-op
-        return null;
+        return new CachedNumberLookupServiceImpl();
     }
 
     public static CallLogAdapter newCallLogAdapter(Context context, CallFetcher callFetcher,
             ContactInfoHelper contactInfoHelper, boolean useCallAsPrimaryAction,
             boolean isCallLog) {
-        return new CallLogAdapter(context, callFetcher, contactInfoHelper, useCallAsPrimaryAction,
-                isCallLog);
+        if (isCallLog) {
+            return new CallLogAdapter(context, callFetcher,
+                    contactInfoHelper, useCallAsPrimaryAction, isCallLog);
+        } else {
+            return new GoogleCallLogAdapter(context, callFetcher,
+                    contactInfoHelper, useCallAsPrimaryAction, isCallLog);
+        }
     }
 }
diff --git a/src/com/google/android/common/http/UrlRules.java b/src/com/google/android/common/http/UrlRules.java
new file mode 100644
index 0000000..49432bf
--- /dev/null
+++ b/src/com/google/android/common/http/UrlRules.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.common.http;
+
+import com.google.android.gsf.Gservices;
+
+import android.content.ContentResolver;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A set of rules rewriting and blocking URLs.  Used to offer a point of
+ * control for redirecting HTTP requests, often to the Android proxy server.
+ *
+ * <p>Each rule has the following format:
+ *
+ * <pre><em>url-prefix</em> [REWRITE <em>new-prefix</em>] [BLOCK]</pre>
+ *
+ * <p>Any URL which starts with <em>url-prefix</em> will trigger the rule.
+ * If BLOCK is specified, requests to that URL will be blocked and fail.
+ * If REWRITE is specified, the matching prefix will be removed and replaced
+ * with <em>new-prefix</em>.  (If both are specified, BLOCK wins.)  Case is
+ * insensitive for the REWRITE and BLOCK keywords, but sensitive for URLs.
+ *
+ * <p>In Gservices, the value of any key that starts with "url:" will be
+ * interpreted as a rule.  The full name of the key is unimportant (but can
+ * be used to document the intent of the rule, and must be unique).
+ * Example gservices keys:
+ *
+ * <pre>
+ * url:use_proxy_for_calendar = "http://www.google.com/calendar/ REWRITE http://android.clients.google.com/proxy/calendar/"
+ * url:stop_crash_reports = "http://android.clients.google.com/crash/ BLOCK"
+ * url:use_ssl_for_contacts = "http://www.google.com/m8/ REWRITE https://www.google.com/m8/"
+ * </pre>
+ */
+public class UrlRules {
+    /** Thrown when the rewrite rules can't be parsed. */
+    public static class RuleFormatException extends Exception {
+        public RuleFormatException(String msg) { super(msg); }
+    }
+
+    /** A single rule specifying actions for URLs matching a certain prefix. */
+    public static class Rule implements Comparable {
+        /** Name assigned to the rule (for logging and debugging). */
+        public final String mName;
+
+        /** Prefix required to match this rule. */
+        public final String mPrefix;
+
+        /** Text to replace mPrefix with (null to leave alone). */
+        public final String mRewrite;
+
+        /** True if matching URLs should be blocked. */
+        public final boolean mBlock;
+
+        /** Default rule that does nothing. */
+        public static final Rule DEFAULT = new Rule();
+
+        /** Parse a rewrite rule as given in a Gservices value. */
+        public Rule(String name, String rule) throws RuleFormatException {
+            mName = name;
+            String[] words = PATTERN_SPACE_PLUS.split(rule);
+            if (words.length == 0) throw new RuleFormatException("Empty rule");
+
+            mPrefix = words[0];
+            String rewrite = null;
+            boolean block = false;
+            for (int pos = 1; pos < words.length; ) {
+                String word = words[pos].toLowerCase();
+                if (word.equals("rewrite") && pos + 1 < words.length) {
+                    rewrite = words[pos + 1];
+                    pos += 2;
+                } else if (word.equals("block")) {
+                    block = true;
+                    pos += 1;
+                } else {
+                    throw new RuleFormatException("Illegal rule: " + rule);
+                }
+                // TODO: Parse timeout specifications, etc.
+            }
+
+            mRewrite = rewrite;
+            mBlock = block;
+        }
+
+        /** Create the default Rule. */
+        private Rule() {
+            mName = "DEFAULT";
+            mPrefix = "";
+            mRewrite = null;
+            mBlock = false;
+        }
+
+        /**
+         * Apply the rule to a particular URL (assumed to match the rule).
+         * @param url to rewrite or modify.
+         * @return modified URL, or null if the URL is blocked.
+         */
+         public String apply(String url) {
+             if (mBlock) {
+                 return null;
+             } else if (mRewrite != null) {
+                 return mRewrite + url.substring(mPrefix.length());
+             } else {
+                 return url;
+             }
+         }
+
+         /** More generic rules are greater than more specific rules. */
+         public int compareTo(Object o) {
+             return ((Rule) o).mPrefix.compareTo(mPrefix);
+         }
+    }
+
+    /** Cached rule set from Gservices. */
+    private static UrlRules sCachedRules = new UrlRules(new Rule[] {});
+
+    private static final Pattern PATTERN_SPACE_PLUS = Pattern.compile(" +");
+    private static final Pattern RULE_PATTERN = Pattern.compile("\\W");
+
+    /** Gservices token when sCachedRules was cached. */
+    private static Object sCachedVersionToken = null;
+
+    /** Currently active set of Rules. */
+    private final Rule[] mRules;
+
+    /** Regular expression with one capturing group for each Rule. */
+    private final Pattern mPattern;
+
+    /**
+     * Create a rewriter from an array of Rules.  Normally used only for
+     * testing.  Instead, use {@link #getRules} to get rules from Gservices.
+     * @param rules to use.
+     */
+    public UrlRules(Rule[] rules) {
+        // Sort the rules to put the most specific rules first.
+        Arrays.sort(rules);
+
+        // Construct a regular expression, escaping all the prefix strings.
+        StringBuilder pattern = new StringBuilder("(");
+        for (int i = 0; i < rules.length; ++i) {
+            if (i > 0) pattern.append(")|(");
+            pattern.append(RULE_PATTERN.matcher(rules[i].mPrefix).replaceAll("\\\\$0"));
+        }
+        mPattern = Pattern.compile(pattern.append(")").toString());
+        mRules = rules;
+    }
+
+    /**
+     * Match a string against every Rule and find one that matches.
+     * @param uri to match against the Rules in the rewriter.
+     * @return the most specific matching Rule, or Rule.DEFAULT if none match.
+     */
+    public Rule matchRule(String url) {
+        Matcher matcher = mPattern.matcher(url);
+        if (matcher.lookingAt()) {
+            for (int i = 0; i < mRules.length; ++i) {
+                if (matcher.group(i + 1) != null) {
+                    return mRules[i];  // Rules are sorted most specific first.
+                }
+            }
+        }
+        return Rule.DEFAULT;
+    }
+
+    /**
+     * Get the (possibly cached) UrlRules based on the rules in Gservices.
+     * @param resolver to use for accessing the Gservices database.
+     * @return an updated UrlRules instance
+     */
+    public static synchronized UrlRules getRules(ContentResolver resolver) {
+        Object versionToken = Gservices.getVersionToken(resolver);
+
+        if (versionToken == UrlRules.sCachedVersionToken) {
+            // The token is the same, so the rules are the same.
+            if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+                Log.v("UrlRules", "Using cached rules, versionToken: " + versionToken);
+            }
+            return sCachedRules;
+        }
+
+        if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+            Log.v("UrlRules", "Scanning for Gservices \"url:*\" rules");
+        }
+
+        // Get all the Gservices settings with names starting with "url:".
+        Map<String, String> rulesMap = Gservices.getStringsByPrefix(resolver, "url:");
+        ArrayList<Rule> rules = new ArrayList<Rule>();
+
+        for (Map.Entry<String, String> entry : rulesMap.entrySet()) {
+            try {
+                String name = entry.getKey().substring(4);  // "url:X"
+                String value = entry.getValue();
+                if (value == null || value.length() == 0) continue;
+                if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+                    Log.v("UrlRules", "  Rule " + name + ": " + value);
+                }
+                rules.add(new Rule(name, value));
+            } catch (RuleFormatException e) {
+                // Oops, Gservices has an invalid rule!  Skip it.
+                Log.e("UrlRules", "Invalid rule from Gservices", e);
+            }
+        }
+
+        sCachedRules = new UrlRules(rules.toArray(new Rule[rules.size()]));
+        sCachedVersionToken = versionToken;
+
+        if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+            Log.v("UrlRules", "New rules stored, versionToken: " + versionToken);
+        }
+
+        return sCachedRules;
+    }
+}
diff --git a/src/com/google/android/dialer/GoogleDialerDatabaseHelper.java b/src/com/google/android/dialer/GoogleDialerDatabaseHelper.java
new file mode 100644
index 0000000..023897f
--- /dev/null
+++ b/src/com/google/android/dialer/GoogleDialerDatabaseHelper.java
@@ -0,0 +1,115 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer;
+
+import com.android.dialer.database.DialerDatabaseHelper;
+import com.android.internal.annotations.VisibleForTesting;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+public class GoogleDialerDatabaseHelper extends DialerDatabaseHelper {
+    private static final String TAG = GoogleDialerDatabaseHelper.class.getSimpleName();
+    private static GoogleDialerDatabaseHelper sSingleton = null;
+    private final String[] mArgs1;
+
+    protected GoogleDialerDatabaseHelper(Context context, String databaseName) {
+        super(context, databaseName, 60004);
+        mArgs1 = new String[1];
+    }
+
+    public static synchronized GoogleDialerDatabaseHelper getInstance(Context context) {
+        if (sSingleton == null) {
+            sSingleton = new GoogleDialerDatabaseHelper(
+                    context.getApplicationContext(), "dialer.db");
+        }
+        return sSingleton;
+    }
+
+    @VisibleForTesting
+    static GoogleDialerDatabaseHelper getNewInstanceForTest(Context context) {
+        return new GoogleDialerDatabaseHelper(context, null);
+    }
+
+    private void setupTables(SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS cached_number_contacts");
+        db.execSQL("CREATE TABLE " + "cached_number_contacts" + " (" +
+                "normalized_number" + " TEXT PRIMARY KEY NOT NULL, " +
+                "number" + " TEXT NOT NULL, " +
+                "phone_type" + " INTEGER DEFAULT 0, " +
+                "phone_label" + " TEXT,display_name TEXT, " +
+                "has_photo" + " INTEGER DEFAULT 0, " +
+                "has_thumbnail" + " INTEGER DEFAULT 0, " +
+                "photo_uri" + " TEXT, " +
+                "time_last_updated" + " LONG NOT NULL, " +
+                "source_name" + " TEXT, " +
+                "source_type" + " INTEGER DEFAULT 0, " +
+                "source_id" + " TEXT, " +
+                "lookup_key" + " TEXT" +
+        ");");
+        db.execSQL("CREATE INDEX " + "cached_number_index"
+                + " ON " + "cached_number_contacts (normalized_number);");
+        setProperty(db, "proprietary_database_version", String.valueOf(6));
+    }
+
+    @Override
+    public void onCreate(SQLiteDatabase db) {
+        super.onCreate(db);
+        setupTables(db);
+    }
+
+    @Override
+    public void onUpgrade(SQLiteDatabase db, int oldNumber, int newNumber) {
+        super.onUpgrade(db, oldNumber, newNumber);
+        int version = getPropertyAsInt(db, "proprietary_database_version", 0);
+        if (version == 0) {
+            Log.e(TAG, "Malformed database version..recreating database");
+        }
+        if (version < 6) {
+            setupTables(db);
+        } else {
+            setProperty(db, "proprietary_database_version", String.valueOf(6));
+        }
+    }
+
+    public void prune() {
+        prune(2592000000L);
+    }
+
+    public void prune(long timestamp) {
+        mArgs1[0] = Long.toString(System.currentTimeMillis() - timestamp);
+        getWritableDatabase().execSQL(
+                "DELETE FROM cached_number_contacts WHERE time_last_updated<?", mArgs1);
+    }
+
+    public void purgeAll() {
+        getWritableDatabase().execSQL("DELETE FROM cached_number_contacts");
+    }
+
+    public void purgeSource(int type) {
+        mArgs1[0] = Integer.toString(type);
+        getWritableDatabase().execSQL(
+                "DELETE FROM cached_number_contacts WHERE source_type=?", mArgs1);
+    }
+}
diff --git a/src/com/google/android/dialer/calllog/GoogleCallLogAdapter.java b/src/com/google/android/dialer/calllog/GoogleCallLogAdapter.java
new file mode 100644
index 0000000..a91ea9a
--- /dev/null
+++ b/src/com/google/android/dialer/calllog/GoogleCallLogAdapter.java
@@ -0,0 +1,188 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.calllog;
+
+import com.android.dialer.R;
+
+import com.android.dialer.calllog.CallLogAdapter;
+import com.android.dialer.calllog.ContactInfo;
+import com.android.dialer.calllog.ContactInfoHelper;
+import com.android.dialer.calllog.PhoneNumberUtilsWrapper;
+import com.android.dialer.PhoneCallDetails;
+import com.android.incallui.Log;
+import com.android.incallui.service.PhoneNumberService;
+import com.android.incalluibind.ServiceFactory;
+import com.google.android.dialer.phonenumbercache.CachedNumberLookupServiceImpl;
+import com.google.android.dialer.reverselookup.ReverseLookupSettingUtil;
+import com.google.android.dialer.settings.GoogleDialerSettingsActivity;
+import com.google.android.dialer.settings.GoogleCallerIdSettingsFragment;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.graphics.Bitmap;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceManager;
+import android.provider.CallLog;
+import android.text.TextUtils;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+public class GoogleCallLogAdapter extends CallLogAdapter {
+    private static final String TAG = GoogleCallLogAdapter.class.getSimpleName();
+    private View mBadgeContainer;
+    private View mCallerIdContainer;
+    private ImageView mCallerIdImageView;
+    private TextView mCallerIdText;
+    private ImageView mDismissButton;
+    private SharedPreferences mPrefs;
+
+    public GoogleCallLogAdapter(Context context, CallLogAdapter.CallFetcher callFetcher,
+            ContactInfoHelper contactInfoHelper, boolean useCallAsPrimaryAction,
+            boolean isCallLog) {
+        super(context, callFetcher, contactInfoHelper, useCallAsPrimaryAction, isCallLog);
+        mPrefs = PreferenceManager.getDefaultSharedPreferences(context);
+    }
+
+    private void lookupNumber(final String phoneNumber, final String countryIso,
+            boolean isIncoming) {
+        PhoneNumberService phoneNumberService = ServiceFactory.newPhoneNumberService(mContext);
+        if (phoneNumberService != null) {
+            phoneNumberService.getPhoneNumberInfo(
+                    phoneNumber, new PhoneNumberService.NumberLookupListener() {
+                @Override
+                public void onPhoneNumberInfoComplete(PhoneNumberService.PhoneNumberInfo info) {
+                    if (info != null) {
+                        enqueueRequest(phoneNumber, countryIso, null, true);
+                    }
+                }
+            }, new PhoneNumberService.ImageLookupListener() {
+                @Override
+                public void onImageFetchComplete(Bitmap bitmap) {
+                    enqueueRequest(phoneNumber, countryIso, null, true);
+                }
+            }, isIncoming);
+        }
+    }
+
+    private boolean shouldShowCallerIdBadge(ContactInfo info, PhoneCallDetails details) {
+        if (mPrefs.getBoolean("google_caller_id_show_enabled_msg", true)) {
+            boolean isEnabled = ReverseLookupSettingUtil.isEnabled(mContext);
+            boolean isNormalNumber = PhoneNumberUtilsWrapper.isUnknownNumberThatCanBeLookedUp(
+                    details.number, details.numberPresentation);
+
+            Log.d(TAG, "shouldShowCallerIdBadge() - isEnabled " + isEnabled
+                    + ", isNormalNumber: " + isNormalNumber
+                    + ", info.sourceType: " + info.sourceType
+                    + ", info.name: " + info.name);
+
+            return isEnabled && isNormalNumber
+                    && (CachedNumberLookupServiceImpl.CachedContactInfoImpl
+                    .isPeopleApiSource(info.sourceType)
+                    || TextUtils.isEmpty(info.name));
+        }
+
+        return false;
+    }
+
+    @Override
+    protected void bindBadge(View view, ContactInfo info, PhoneCallDetails details, int callType) {
+        super.bindBadge(view, info, details, callType);
+
+        if (shouldShowCallerIdBadge(info, details)) {
+            Log.d(TAG, "Showing caller id badge.");
+
+            mCallerIdText.setText(mContext.getResources()
+                    .getString(R.string.reverse_lookup_enabled));
+
+            mCallerIdImageView.setImageResource(
+                    R.drawable.ic_action_settings_blue);
+
+            mCallerIdContainer.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    Intent i = new Intent(mContext, GoogleDialerSettingsActivity.class);
+                    i.putExtra(PreferenceActivity.EXTRA_SHOW_FRAGMENT,
+                            GoogleCallerIdSettingsFragment.class.getName());
+                    i.putExtra(PreferenceActivity.EXTRA_SHOW_FRAGMENT_TITLE,
+                            R.string.google_caller_id_setting_title);
+                    mContext.startActivity(i);
+                }
+            });
+
+            mBadgeContainer.setVisibility(View.VISIBLE);
+
+            if (mPrefs.getBoolean("google_caller_id_shown_first_time", true)) {
+                mPrefs.edit().putBoolean("google_caller_id_shown_first_time", false).commit();
+
+                // TODO: Is this right?
+                if (callType != CallLog.Calls.INCOMING_TYPE &&
+                        callType != CallLog.Calls.MISSED_TYPE) {
+                    lookupNumber(details.number.toString(), details.countryIso, false);
+                } else {
+                    lookupNumber(details.number.toString(), details.countryIso, true);
+                }
+            }
+        } else {
+            Log.d(TAG, "Hiding caller id badge.");
+            mBadgeContainer.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    protected View newChildView(Context context, ViewGroup parent) {
+        ViewGroup viewGroup = (ViewGroup) super.newChildView(context, parent);
+
+        mBadgeContainer = ((LayoutInflater) mContext.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE)).inflate(
+                R.layout.call_log_list_item_extra, null, false);
+
+        mCallerIdContainer = mBadgeContainer.findViewById(
+                R.id.badge_link_container);
+
+        mCallerIdImageView = (ImageView) mBadgeContainer.findViewById(
+                R.id.badge_image);
+
+        mCallerIdText = (TextView) mBadgeContainer.findViewById(
+                R.id.badge_text);
+
+        mDismissButton = (ImageView) mBadgeContainer.findViewById(
+                R.id.dismiss_button);
+        mDismissButton.setVisibility(View.VISIBLE);
+
+        mDismissButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                mBadgeContainer.setVisibility(View.GONE);
+                mPrefs.edit().putBoolean("google_caller_id_show_enabled_msg", false).commit();
+                notifyDataSetChanged();
+            }
+        });
+
+        viewGroup.addView(mBadgeContainer);
+        return viewGroup;
+    }
+}
diff --git a/src/com/google/android/dialer/extensions/DialerExtendedPhoneDirectoriesManager.java b/src/com/google/android/dialer/extensions/DialerExtendedPhoneDirectoriesManager.java
new file mode 100644
index 0000000..b991488
--- /dev/null
+++ b/src/com/google/android/dialer/extensions/DialerExtendedPhoneDirectoriesManager.java
@@ -0,0 +1,65 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.extensions;
+
+import com.android.dialer.R;
+
+import com.android.contacts.common.extensions.ExtendedPhoneDirectoriesManager;
+import com.android.contacts.common.list.DirectoryPartition;
+import com.google.android.dialer.provider.DialerProvider;
+import com.google.android.gsf.Gservices;
+
+import android.content.Context;
+import android.preference.PreferenceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class DialerExtendedPhoneDirectoriesManager
+        implements ExtendedPhoneDirectoriesManager {
+    @Override
+    public List<DirectoryPartition> getExtendedDirectories(Context context) {
+        ArrayList<DirectoryPartition> list = new ArrayList<DirectoryPartition>();
+
+        boolean enableNearby = Gservices.getBoolean(context.getContentResolver(),
+                "dialer_enable_nearby_places_directory", true);
+        boolean enableSearch = PreferenceManager.getDefaultSharedPreferences(context)
+                .getBoolean("local_search", true);
+
+        if (enableNearby && enableSearch) {
+            DirectoryPartition dp = new DirectoryPartition(false, true);
+            dp.setContentUri(DialerProvider.NEARBY_PLACES_URI.toString());
+            dp.setLabel(context.getString(R.string.local_search_directory_label));
+            dp.setPriorityDirectory(false);
+            dp.setPhotoSupported(true);
+            dp.setDisplayNumber(false);
+            dp.setResultLimit(3);
+            list.add(dp);
+        } else {
+            Log.i("DialerProvider", "Nearby places is disabled");
+        }
+
+        return list;
+    }
+}
diff --git a/src/com/google/android/dialer/extensions/GoogleDialtactsActivity.java b/src/com/google/android/dialer/extensions/GoogleDialtactsActivity.java
new file mode 100644
index 0000000..fa3019b
--- /dev/null
+++ b/src/com/google/android/dialer/extensions/GoogleDialtactsActivity.java
@@ -0,0 +1,48 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.extensions;
+
+import com.android.dialer.DialtactsActivity;
+import com.google.android.gsf.Gservices;
+import com.google.android.dialer.reverselookup.ReverseLookupSettingUtil;
+import com.google.android.dialer.settings.GoogleDialerSettingsActivity;
+
+import android.content.ContextWrapper;
+import android.content.Intent;
+
+public class GoogleDialtactsActivity extends DialtactsActivity {
+    @Override
+    protected void handleMenuSettings() {
+        boolean enableNearby = Gservices.getBoolean(
+                ((ContextWrapper)this).getContentResolver(),
+                "dialer_enable_nearby_places_directory", true);
+        boolean gServiceEnabled =
+                ReverseLookupSettingUtil.isGServiceEnabled(this);
+
+        if (enableNearby || gServiceEnabled) {
+            startActivity(new Intent(this, GoogleDialerSettingsActivity.class));
+        } else {
+            super.handleMenuSettings();
+        }
+    }
+}
diff --git a/src/com/google/android/dialer/phonenumbercache/CachedNumberLookupServiceImpl.java b/src/com/google/android/dialer/phonenumbercache/CachedNumberLookupServiceImpl.java
new file mode 100644
index 0000000..10da8eb
--- /dev/null
+++ b/src/com/google/android/dialer/phonenumbercache/CachedNumberLookupServiceImpl.java
@@ -0,0 +1,298 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.phonenumbercache;
+
+import com.android.dialer.calllog.ContactInfo;
+import com.android.dialer.service.CachedNumberLookupService;
+import com.google.android.dialer.GoogleDialerDatabaseHelper;
+import com.google.android.dialer.reverselookup.ReverseLookupSettingUtil;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.text.TextUtils;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import libcore.io.IoUtils;
+
+public class CachedNumberLookupServiceImpl implements CachedNumberLookupService {
+    private Uri getContactUri(Cursor cursor) {
+        int type = cursor.getInt(8);
+        String directory = cursor.getString(9);
+        String displayName = cursor.getString(7);
+        String encoded = cursor.getString(10);
+
+        if (!TextUtils.isEmpty(encoded) && !TextUtils.isEmpty(directory)) {
+            if (type == 1) {
+                return ContactsContract.Contacts.getLookupUri(0, encoded)
+                        .buildUpon().appendQueryParameter("directory", directory).build();
+            }
+            if (type == 2 || type == 3 || type == 4) {
+                Uri.Builder encodedFragment =
+                        ContactsContract.Contacts.CONTENT_LOOKUP_URI.buildUpon()
+                        .appendPath("encoded").encodedFragment(encoded);
+
+                if (!TextUtils.isEmpty(displayName)) {
+                    encodedFragment.appendQueryParameter("displayName", displayName);
+                }
+
+                return encodedFragment.appendQueryParameter("directory", directory).build();
+            }
+        }
+        return null;
+    }
+
+    private Uri getPhotoUri(Cursor cursor, String uri) {
+        // TODO: What are the variables?
+
+        int i1 = cursor.getInt(1);
+        int i2 = cursor.getInt(2);
+        if (i1 != 0) {
+            return PhoneNumberCacheContract.getPhotoLookupUri(uri);
+        }
+        if (i2 != 0) {
+            return PhoneNumberCacheContract.getThumbnailLookupUri(uri);
+        }
+
+        String s = cursor.getString(3);
+        if (s != null) {
+            return Uri.parse(s);
+        } else {
+            return null;
+        }
+    }
+
+    public static void purgePeopleApiCacheEntries(Context context) {
+        GoogleDialerDatabaseHelper instance =
+                GoogleDialerDatabaseHelper.getInstance(context);
+
+        // TODO: What are the constants?
+        instance.purgeSource(3);
+        instance.purgeSource(4);
+    }
+
+    @Override
+    public void addContact(Context context,
+            CachedNumberLookupService.CachedContactInfo info) {
+        if (info instanceof CachedContactInfoImpl) {
+            CachedContactInfoImpl cachedInfo = (CachedContactInfoImpl)info;
+            Uri uri = PhoneNumberCacheContract.CONTACT_URI;
+            ContentValues contentValues = new ContentValues();
+            ContactInfo contactInfo = cachedInfo.getContactInfo();
+            if (contactInfo != null && contactInfo != ContactInfo.EMPTY) {
+                String number;
+                if (contactInfo.number != null) {
+                    number = contactInfo.number;
+                } else {
+                    number = contactInfo.normalizedNumber;
+                }
+                if (!TextUtils.isEmpty(number)) {
+                    contentValues.put("number", number);
+                    contentValues.put("phone_type", contactInfo.type);
+                    contentValues.put("phone_label", contactInfo.label);
+                    contentValues.put("display_name", contactInfo.name);
+                    String photoUri;
+                    if (contactInfo.photoUri != null) {
+                        photoUri = contactInfo.photoUri.toString();
+                    } else {
+                        photoUri = null;
+                    }
+                    contentValues.put("photo_uri", photoUri);
+                    contentValues.put("source_name", cachedInfo.sourceName);
+                    contentValues.put("source_type", cachedInfo.sourceType);
+                    contentValues.put("source_id", cachedInfo.sourceId);
+                    contentValues.put("lookup_key", cachedInfo.lookupKey);
+                    context.getContentResolver().insert(uri, contentValues);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean addPhoto(Context context, String number, byte[] photo) {
+        Uri uri = PhoneNumberCacheContract.getPhotoLookupUri(number);
+        OutputStream stream = null;
+        try {
+            stream = context.getContentResolver().openOutputStream(uri);
+            stream.write(photo);
+            return true;
+        } catch (IOException e) {
+            return false;
+        } finally {
+            IoUtils.closeQuietly(stream);
+        }
+    }
+
+    @Override
+    public CachedContactInfoImpl buildCachedContactInfo(ContactInfo info) {
+        return new CachedContactInfoImpl(info);
+    }
+
+    @Override
+    public void clearAllCacheEntries(Context context) {
+        GoogleDialerDatabaseHelper.getInstance(context).purgeAll();
+    }
+
+    @Override
+    public boolean isCacheUri(String uri) {
+        return uri.startsWith(PhoneNumberCacheContract.AUTHORITY_URI.toString());
+    }
+
+    @Override
+    public CachedContactInfoImpl lookupCachedContactFromNumber(Context context, String number) {
+        Cursor query = context.getContentResolver().query(
+                PhoneNumberCacheContract.getContactLookupUri(number),
+                CachedNumberQuery.PROJECTION, null, null, null);
+
+        if (query == null) {
+            return null;
+        }
+
+        try {
+            if (!query.moveToFirst()) {
+                return buildCachedContactInfo(ContactInfo.EMPTY);
+            }
+
+            // TODO: What are the constants
+            int type = query.getInt(8);
+
+            if (CachedContactInfoImpl.isPeopleApiSource(type)
+                    && !ReverseLookupSettingUtil.isEnabled(context)) {
+                purgePeopleApiCacheEntries(context);
+                return buildCachedContactInfo(ContactInfo.EMPTY);
+            }
+
+            ContactInfo info = new ContactInfo();
+            info.lookupUri = getContactUri(query);
+            info.name = query.getString(0);
+            info.type = query.getInt(5);
+            info.label = query.getString(6);
+            if (info.type == 0 && info.label == null) {
+                info.label = ContactInfo.GEOCODE_AS_LABEL;
+            }
+            info.number = query.getString(4);
+            info.normalizedNumber = number;
+            info.formattedNumber = null;
+            info.photoId = 0L;
+            info.photoUri = getPhotoUri(query, number);
+
+            CachedContactInfoImpl cachedContactInfo = buildCachedContactInfo(info);
+            cachedContactInfo.setSource(type, query.getString(7), query.getLong(9));
+            return cachedContactInfo;
+        }
+        finally {
+            query.close();
+        }
+    }
+
+    public static class CachedContactInfoImpl
+            implements CachedNumberLookupService.CachedContactInfo {
+        private final ContactInfo mInfo;
+
+        public String lookupKey;
+
+        public long sourceId;
+        public String sourceName;
+        public int sourceType;
+
+        public CachedContactInfoImpl(ContactInfo empty) {
+            if (empty == null) {
+                empty = ContactInfo.EMPTY;
+            }
+            mInfo = empty;
+        }
+
+        public static boolean isBusiness(int type) {
+            return type == 3 || type == 2;
+        }
+
+        public static boolean isPeopleApiSource(int type) {
+            // TODO: What are the constants?
+            return type == 3 || type == 4;
+        }
+
+        @Override
+        public ContactInfo getContactInfo() {
+            return mInfo;
+        }
+
+        public int getSourceType() {
+            return sourceType;
+        }
+
+        @Override
+        public void setDirectorySource(String name, long directoryId) {
+            // TODO: What is the constant?
+            setSource(1, name, directoryId);
+        }
+
+        @Override
+        public void setExtendedSource(String name, long directoryId) {
+            // TODO: What is the constant?
+            setSource(2, name, directoryId);
+        }
+
+        @Override
+        public void setLookupKey(String key) {
+            lookupKey = key;
+        }
+
+        public void setPeopleAPISource(boolean b) {
+            // TODO: What are the constants?
+
+            int type;
+            if (b) {
+                type = 3;
+            } else {
+                type = 4;
+            }
+            setSource(type, "Google Caller ID", 2147483647L);
+        }
+
+        protected void setSource(int type, String name, long id) {
+            sourceType = type;
+            sourceName = name;
+            sourceId = id;
+            mInfo.sourceType = type;
+        }
+    }
+
+    public interface CachedNumberQuery {
+        public static final String[] PROJECTION = {
+                "display_name",
+                "has_photo",
+                "has_thumbnail",
+                "photo_uri",
+                "number",
+                "phone_type",
+                "phone_label",
+                "source_name",
+                "source_type",
+                "source_id",
+                "lookup_key" };
+    }
+}
diff --git a/src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheContract.java b/src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheContract.java
new file mode 100644
index 0000000..76a433d
--- /dev/null
+++ b/src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheContract.java
@@ -0,0 +1,48 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.phonenumbercache;
+
+import android.net.Uri;
+
+public final class PhoneNumberCacheContract {
+    public static final Uri AUTHORITY_URI =
+            Uri.parse("content://com.google.android.dialer.cacheprovider");
+    public static final Uri CONTACT_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "contact");
+    public static final Uri PHOTO_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "photo");
+    public static final Uri THUMBNAIL_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "thumbnail");
+
+    public static Uri getContactLookupUri(String s) {
+        return CONTACT_URI.buildUpon().appendPath(s).build();
+    }
+
+    public static Uri getPhotoLookupUri(String s) {
+        return PHOTO_URI.buildUpon().appendPath(s).build();
+    }
+
+    public static Uri getThumbnailLookupUri(String s) {
+        return THUMBNAIL_URI.buildUpon().appendPath(s).build();
+    }
+}
diff --git a/src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheProvider.java b/src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheProvider.java
new file mode 100644
index 0000000..1866049
--- /dev/null
+++ b/src/com/google/android/dialer/phonenumbercache/PhoneNumberCacheProvider.java
@@ -0,0 +1,346 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.phonenumbercache;
+
+import com.android.contacts.common.GeoUtil;
+import com.google.android.dialer.GoogleDialerDatabaseHelper;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PathPermission;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDoneException;
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+public class PhoneNumberCacheProvider extends ContentProvider {
+    private static final String TAG = PhoneNumberCacheProvider.class.getSimpleName();
+
+    private static final Set<String> SUPPORTED_UPDATE_COLUMNS = new HashSet<String>();
+    private static final UriMatcher sUriMatcher = new UriMatcher(-1);
+    private final String[] mArgs1;
+    private GoogleDialerDatabaseHelper mDbHelper;
+    private File mPhotoPath;
+    private File mThumbnailPath;
+
+    static {
+        sUriMatcher.addURI("com.google.android.dialer.cacheprovider", "contact", 1000);
+        sUriMatcher.addURI("com.google.android.dialer.cacheprovider", "contact/*", 1001);
+        sUriMatcher.addURI("com.google.android.dialer.cacheprovider", "photo/*", 2000);
+        sUriMatcher.addURI("com.google.android.dialer.cacheprovider", "thumbnail/*", 3000);
+        SUPPORTED_UPDATE_COLUMNS.add("number");
+        SUPPORTED_UPDATE_COLUMNS.add("phone_type");
+        SUPPORTED_UPDATE_COLUMNS.add("phone_label");
+        SUPPORTED_UPDATE_COLUMNS.add("display_name");
+        SUPPORTED_UPDATE_COLUMNS.add("photo_uri");
+        SUPPORTED_UPDATE_COLUMNS.add("source_name");
+        SUPPORTED_UPDATE_COLUMNS.add("source_type");
+        SUPPORTED_UPDATE_COLUMNS.add("source_id");
+        SUPPORTED_UPDATE_COLUMNS.add("lookup_key");
+    }
+
+    public PhoneNumberCacheProvider() {
+        mArgs1 = new String[1];
+    }
+
+    public PhoneNumberCacheProvider(Context context, String readPermission,
+            String writePermission, PathPermission[] pathPermissions) {
+        super(context, readPermission, writePermission, pathPermissions);
+        mArgs1 = new String[1];
+    }
+
+    private void createDirectoryIfDoesNotExist(File file) {
+        if (!file.exists() && !file.mkdirs()) {
+            throw new RuntimeException(
+                    "Unable to create photo storage directory " + file.getPath());
+        }
+    }
+
+    private void createPhotoDirectoriesIfDoNotExist() {
+        mPhotoPath = new File(getContext().getFilesDir(), "photos/raw");
+        mThumbnailPath = new File(getContext().getFilesDir(), "thumbnails/raw");
+        createDirectoryIfDoesNotExist(mPhotoPath);
+        createDirectoryIfDoesNotExist(mThumbnailPath);
+    }
+
+    private boolean deleteFile(String number, boolean fullPhoto) {
+        File file;
+        if (fullPhoto) {
+            file = getPhotoForNumber(number);
+        } else {
+            file = getThumbnailForNumber(number);
+        }
+        return file.delete();
+    }
+
+    private boolean deleteFiles(String number) {
+        boolean deletedPhoto = deleteFile(number, true);
+        boolean deletedThumbnail = deleteFile(number, false);
+        if (!deletedPhoto && !deletedThumbnail) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    private String getE164Number(String number) {
+        return PhoneNumberUtils.formatNumberToE164(number,
+                GeoUtil.getCurrentCountryIso(getContext()));
+    }
+
+    private String getNumberFromUri(Uri uri) {
+        if (uri.getPathSegments().size() != 2) {
+            throw new IllegalArgumentException("Invalid URI or phone number not provided");
+        }
+        return getE164Number(uri.getLastPathSegment());
+    }
+
+    private String getNumberFromValues(ContentValues values) {
+        String number = values.getAsString("number");
+        if (number == null || number.length() == 0) {
+            throw new IllegalArgumentException("Phone number not provided");
+        }
+        return getE164Number(number);
+    }
+
+    private File getPhotoForNumber(String number) {
+        return new File(mPhotoPath, number);
+    }
+
+    private File getThumbnailForNumber(String number) {
+        return new File(mThumbnailPath, number);
+    }
+
+    private boolean isNumberInCache(String number) {
+        SQLiteDatabase database = mDbHelper.getReadableDatabase();
+        mArgs1[0] = number;
+        long entries = DatabaseUtils.queryNumEntries(database,
+                "cached_number_contacts", "normalized_number=?", mArgs1);
+        boolean inCache = false;
+        if (entries > 0) {
+            inCache = true;
+        }
+        return inCache;
+    }
+
+    private ParcelFileDescriptor openFileForRead(
+            String number, boolean fullPhoto) throws FileNotFoundException {
+        File file;
+        if (fullPhoto) {
+            file = getPhotoForNumber(number);
+        } else {
+            file = getThumbnailForNumber(number);
+        }
+        if (file.exists()) {
+            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
+        }
+        setHavePhoto(number, fullPhoto, false);
+        throw new FileNotFoundException("No photo file found for number: " + number);
+    }
+
+    private ParcelFileDescriptor openFileForWrite(String number, boolean fullPhoto) {
+        // TODO: Check if it's right. Decompiler completely screwed it up
+
+        File file;
+        if (fullPhoto) {
+            file = getPhotoForNumber(number);
+        } else {
+            file = getThumbnailForNumber(number);
+        }
+
+        try {
+            if (!file.exists()) {
+                file.createNewFile();
+                setHavePhoto(number, fullPhoto, true);
+            }
+
+            return ParcelFileDescriptor.open(file,
+                    ParcelFileDescriptor.MODE_READ_WRITE);
+        } catch (FileNotFoundException e) {
+            return null;
+        } catch (IOException e) {
+            Log.d(TAG, "IOException when attempting to create new file for cached photo.");
+            return null;
+        }
+    }
+
+    private void setHavePhoto(String number, boolean fullPhoto, boolean havePhoto) {
+        String which = fullPhoto ? "has_photo" : "has_thumbnail";
+        String have = havePhoto ? "1" : "0";
+
+        SQLiteDatabase database = mDbHelper.getWritableDatabase();
+        mArgs1[0] = number;
+        StringBuilder sb = new StringBuilder();
+        sb.append("UPDATE cached_number_contacts SET ");
+        sb.append(which);
+        sb.append("=");
+        sb.append(have);
+        sb.append(" WHERE ");
+        sb.append("normalized_number=?");
+        sb.append(";");
+
+        database.execSQL(sb.toString(), mArgs1);
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        // TODO: Where does 1001 come from?
+        if (sUriMatcher.match(uri) == 1001) {
+            mDbHelper.prune();
+
+            String number = getNumberFromUri(uri);
+            mArgs1[0] = number;
+            SQLiteDatabase database = mDbHelper.getWritableDatabase();
+            deleteFiles(number);
+            return database.delete("cached_number_contacts", "normalized_number=?", mArgs1);
+        }
+        throw new IllegalArgumentException("Unknown URI or phone number not provided");
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        return null;
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        // TODO: What are the constants?
+        int match = sUriMatcher.match(uri);
+        switch (match) {
+        default:
+            throw new IllegalArgumentException("Unknown URI");
+        case 1000:
+        case 1001:
+            String number;
+            if (match == 1000) {
+                number = getNumberFromValues(values);
+            } else {
+                number = getNumberFromUri(uri);
+            }
+
+            for (String key : values.keySet()) {
+                if (!SUPPORTED_UPDATE_COLUMNS.contains(key)) {
+                    values.remove(key);
+                    Log.e(TAG, "Ignoring unsupported column for update: " + key);
+                }
+            }
+
+            mDbHelper.prune();
+            values.put("normalized_number", number);
+            values.put("time_last_updated", System.currentTimeMillis());
+
+            SQLiteDatabase database = mDbHelper.getWritableDatabase();
+            mArgs1[0] = number;
+            Integer type = values.getAsInteger("source_type");
+
+            // TODO: What is n and n2?
+            int n = 0;
+            if (type != null && CachedNumberLookupServiceImpl.CachedContactInfoImpl
+                    .isPeopleApiSource(type)) {
+                n = 1;
+            } else {
+                int n2 = -1;
+                try {
+                    n2 = (int) DatabaseUtils.longForQuery(database,
+                            "SELECT source_type FROM cached_number_contacts WHERE normalized_number=?",
+                            mArgs1);
+                    boolean peopleApiSource = CachedNumberLookupServiceImpl
+                            .CachedContactInfoImpl.isPeopleApiSource(n2);
+
+                    if (!peopleApiSource) {
+                        n = 1;
+                    }
+                }
+                catch (SQLiteDoneException ex) {
+                    // TODO: What to do here? Decompiler broke code
+                }
+            }
+            if (n != 0) {
+                database.insertWithOnConflict("cached_number_contacts", null, values, 5);
+            }
+            return uri;
+        }
+    }
+
+    @Override
+    public boolean onCreate() {
+        mDbHelper = GoogleDialerDatabaseHelper.getInstance(getContext());
+        createPhotoDirectoriesIfDoNotExist();
+        return true;
+    }
+
+    @Override
+    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
+        int match = sUriMatcher.match(uri);
+        switch (match) {
+        default:
+            throw new FileNotFoundException("Unknown or unsupported URI");
+        case 2000:
+        case 3000:
+            String number = getNumberFromUri(uri);
+            if (!isNumberInCache(number)) {
+                throw new FileNotFoundException("Phone number does not exist in cache");
+            }
+            if (mode.equals("r")) {
+                return openFileForRead(number, match == 2000);
+            } else {
+                return openFileForWrite(number, match == 2000);
+            }
+        }
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+            String[] selectionArgs, String sortOrder) {
+        if (sUriMatcher.match(uri) == 1001) {
+            String number = getNumberFromUri(uri);
+            if (number != null) {
+                mDbHelper.prune();
+                mArgs1[0] = number;
+                return mDbHelper.getWritableDatabase().query(
+                        "cached_number_contacts", projection,
+                        "normalized_number=?", mArgs1,
+                        null, null, null);
+            }
+        }
+        return null;
+    }
+
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException(
+                "The cache does not support update operations."
+                + " Use insert to replace an existing phone number, if needed.");
+    }
+}
diff --git a/src/com/google/android/dialer/provider/DialerProvider.java b/src/com/google/android/dialer/provider/DialerProvider.java
new file mode 100644
index 0000000..0e46fb9
--- /dev/null
+++ b/src/com/google/android/dialer/provider/DialerProvider.java
@@ -0,0 +1,636 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.provider;
+
+import com.android.dialer.R;
+
+import com.google.android.common.http.UrlRules;
+import com.google.android.dialer.util.GoogleLocationSettingHelper;
+import com.google.android.dialer.util.JsonUtil;
+import com.google.android.gsf.Gservices;
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.text.Html;
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLDecoder;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.TimeUnit;
+import java.util.LinkedList;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class DialerProvider extends ContentProvider {
+    public static final Uri AUTHORITY_URI =
+            Uri.parse("content://com.google.android.dialer.provider");
+    public static final Uri NEARBY_PLACES_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "nearbyPlaces");
+
+    public static final int CHARSET_PREFIX_LEN = "charset=".length();
+
+    private static final Looper mLooper = new Handler().getLooper();
+    private static final UriMatcher sURIMatcher = new UriMatcher(-1);
+    private final LinkedList<FutureTask> mActiveTasks;
+    private String mUserAgent;
+
+    static {
+        sURIMatcher.addURI("com.google.android.dialer.provider", "nearbyPlaces/*", 0);
+    }
+
+    public DialerProvider() {
+        mActiveTasks = new LinkedList<FutureTask>();
+    }
+
+    private Cursor buildResultCursor(
+            String[] array, JSONArray jsonArray, int n) throws JSONException {
+        int indexDisplayName = -1;
+        int indexData3 = -1;
+        int indexHasPhoneNumber = -1;
+        int indexId = -1;
+        int indexContactId = -1;
+        int indexData1 = -1;
+        int indexData2 = -1;
+        int indexPhotoUri = -1;
+        int indexPhotoThumbUri = -1;
+        int indexLookup = -1;
+
+        for (int i = 0; i < array.length; ++i) {
+            String s = array[i];
+
+            if ("display_name".equals(s)) {
+                indexDisplayName = i;
+            } else if ("data3".equals(s)) {
+                indexData3 = i;
+            } else if ("has_phone_number".equals(s)) {
+                indexHasPhoneNumber = i;
+            } else if ("_id".equals(s)) {
+                indexId = i;
+            } else if ("contact_id".equals(s)) {
+                indexContactId = i;
+            } else if ("data1".equals(s)) {
+                indexData1 = i;
+            } else if ("data2".equals(s)) {
+                indexData2 = i;
+            } else if ("photo_uri".equals(s)) {
+                indexPhotoUri = i;
+            } else if ("photo_thumb_uri".equals(s)) {
+                indexPhotoThumbUri = i;
+            } else if ("lookup".equals(s)) {
+                indexLookup = i;
+            }
+        }
+
+        ContentResolver resolver = getContext().getContentResolver();
+        boolean showNearbyDistance = Gservices.getBoolean(resolver,
+                "dialer_debug_display_nearby_place_distance", false);
+
+        int n12;
+        if (Gservices.getBoolean(resolver, "dialer_enable_nearby_places_export", true)) {
+            n12 = 2;
+        } else {
+            n12 = 0;
+        }
+
+        MatrixCursor matrixCursor = new MatrixCursor(array);
+        JSONArray jsonArray2 = jsonArray.getJSONArray(1);
+
+        int n13 = 1;
+        int position = 0;
+
+        while (position < jsonArray2.length()) {
+            try {
+                JSONArray jsonArray3 = jsonArray2.getJSONArray(position);
+                String displayName = decodeHtml(jsonArray3.getString(0));
+                JSONObject jsonObject = jsonArray3.getJSONObject(3);
+                String data1 = decodeHtml(jsonObject.getString("b"));
+                String data3 = decodeHtml(jsonObject.getString("g"));
+                String optString = jsonObject.optString("f", null);
+                String photoUri = jsonObject.optString("d", null);
+
+                if (showNearbyDistance) {
+                    String miles = jsonObject.optString("c", null);
+                    if (miles != null) {
+                        displayName = displayName + " [" + miles + " miles]";
+                    }
+                }
+
+                if (!data1.isEmpty()) {
+                    Object[] array2 = new Object[array.length];
+
+                    if (indexDisplayName >= 0) {
+                        array2[indexDisplayName] = displayName;
+                    }
+                    if (indexData3 >= 0) {
+                        array2[indexData3] = data3;
+                    }
+                    if (indexHasPhoneNumber >= 0) {
+                        array2[indexHasPhoneNumber] = true;
+                    }
+                    if (indexContactId != -1) {
+                        array2[indexContactId] = n13;
+                    }
+                    if (indexData1 >= 0) {
+                        array2[indexData1] = data1;
+                    }
+                    if (indexData2 >= 0) {
+                        array2[indexData2] = 12;
+                    }
+
+                    String photoThumbUri;
+                    if (photoUri == null) {
+                        photoUri = new Uri.Builder()
+                                .scheme("android.resource")
+                                .authority("com.google.android.dialer")
+                                .appendPath(String.valueOf(
+                                        R.drawable.ic_places_picture_180_holo_light))
+                                .toString();
+                        photoThumbUri = new Uri.Builder()
+                                .scheme("android.resource")
+                                .authority("com.google.android.dialer")
+                                .appendPath(String.valueOf(
+                                        R.drawable.ic_places_picture_holo_light))
+                                .toString();
+                    } else {
+                        photoThumbUri = photoUri;
+                    }
+
+                    if (indexPhotoUri >= 0) {
+                        array2[indexPhotoUri] = photoUri;
+                    }
+                    if (indexPhotoThumbUri >= 0) {
+                        array2[indexPhotoThumbUri] = photoThumbUri;
+                    }
+                    if (indexLookup >= 0) {
+                        JSONObject put = new JSONObject()
+                                .put("vnd.android.cursor.item/name",
+                                        new JSONObject().put("data1", displayName))
+                                .put("vnd.android.cursor.item/phone_v2",
+                                        JsonUtil.newJsonArray(new JSONObject()
+                                                .put("data1", data1)
+                                                .put("data2", 12)))
+                                .put("vnd.android.cursor.item/postal-address_v2",
+                                        JsonUtil.newJsonArray(new JSONObject()
+                                                .put("data1", displayName + ", " + data3)
+                                                .put("data2", 2)));
+
+                        if (optString != null) {
+                            put.put("vnd.android.cursor.item/website",
+                                    JsonUtil.newJsonArray(new JSONObject()
+                                            .put("data1", optString)
+                                            .put("data2", 3)));
+                        }
+
+                        array2[indexLookup] = new JSONObject()
+                                .put("display_name", displayName)
+                                .put("display_name_source", 30)
+                                .put("exportSupport", n12)
+                                .put("photo_uri", photoUri)
+                                .put("vnd.android.cursor.item/contact", put)
+                                .toString();
+                    }
+                    if (indexId != -1) {
+                        array2[indexId] = n13;
+                    }
+                    matrixCursor.addRow(array2);
+                    if (n != -1 && matrixCursor.getCount() >= n) {
+                        break;
+                    }
+
+                    n13++;
+                }
+            }
+            catch (JSONException e) {
+                Log.e("DialerProvider", "Skipped the suggestions at position " + position, e);
+            }
+
+            position++;
+        }
+        return matrixCursor;
+    }
+
+    private String decodeHtml(String s) {
+        return Html.fromHtml(s).toString();
+    }
+
+    private <T> T execute(Callable<T> callable, String name, long time, TimeUnit timeUnit) {
+        FutureCallable<T> futureCallable = new FutureCallable<T>(callable);
+        FutureTask<T> future = new FutureTask<T>(futureCallable);
+        futureCallable.setFuture(future);
+
+        synchronized (mActiveTasks) {
+            mActiveTasks.addLast(future);
+            if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                Log.v("DialerProvider", "Currently running tasks: " + mActiveTasks.size());
+            }
+            while (mActiveTasks.size() > 8) {
+                Log.w("DialerProvider", "Too many tasks, canceling one");
+                mActiveTasks.removeFirst().cancel(true);
+            }
+        }
+
+        if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+            Log.v("DialerProvider", "Starting task " + name);
+        }
+
+        new Thread(future, name).start();
+        try {
+            if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                Log.v("DialerProvider", "Getting future " + name);
+            }
+            return future.get(time, timeUnit);
+        } catch (InterruptedException e) {
+            Log.w("DialerProvider", "Task was interrupted: " + name);
+            Thread.currentThread().interrupt();
+        } catch (ExecutionException e) {
+            Log.w("DialerProvider", "Task threw an exception: " + name, e);
+        } catch (TimeoutException e) {
+            Log.w("DialerProvider", "Task timed out: " + name);
+            future.cancel(true);
+        } catch (CancellationException e) {
+            Log.w("DialerProvider", "Task was cancelled: " + name);
+        }
+
+        // TODO: Is this appropriate?
+        return null;
+    }
+
+    private String executeHttpRequest(Uri uri) throws IOException {
+        String charset = null;
+
+        if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+            Log.v("DialerProvider", "executeHttpRequest(" + uri + ")");
+        }
+
+        try {
+            URLConnection conn = new URL(uri.toString()).openConnection();
+            conn.setRequestProperty("User-Agent", mUserAgent);
+
+            InputStream inputStream = conn.getInputStream();
+            charset = getCharsetFromContentType(conn.getContentType());
+
+            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+
+            byte[] buf = new byte[1000];
+            while (true) {
+                int len = inputStream.read(buf);
+                if (len <= 0) {
+                    break;
+                }
+                outputStream.write(buf, 0, len);
+            }
+
+            inputStream.close();
+            outputStream.flush();
+
+            return new String(outputStream.toByteArray(), charset);
+        } catch (UnsupportedEncodingException e) {
+            Log.w("DialerProvider", "Invalid charset: " + charset, e);
+        } catch (IOException e) {
+            // TODO: Didn't find anything that goes here in byte-code
+        }
+
+        // TODO: Is this appropriate?
+        return null;
+    }
+
+    private static String getCharsetFromContentType(String s) {
+        String[] split = s.split(";");
+        for (int i = 0; i < split.length; i++) {
+            String trimmed = split[i].trim();
+            if (trimmed.startsWith("charset=")) {
+                return trimmed.substring(CHARSET_PREFIX_LEN);
+            }
+        }
+        return "UTF-8";
+    }
+
+    private Location getLastLocation() {
+        LocationManager locationManager =
+                (LocationManager) getContext().getSystemService(Context.LOCATION_SERVICE);
+        locationManager.requestSingleUpdate(new Criteria(), new LocationListener() {
+            @Override
+            public void onLocationChanged(Location location) {
+                if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                    Log.v("DialerProvider", "onLocationChanged: " + location);
+                }
+            }
+
+            @Override
+            public void onProviderDisabled(String provider) {
+                if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                    Log.v("DialerProvider", "onProviderDisabled: " + provider);
+                }
+            }
+
+            @Override
+            public void onProviderEnabled(String provider) {
+                if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                    Log.v("DialerProvider", "onProviderEnabled: " + provider);
+                }
+            }
+
+            @Override
+            public void onStatusChanged(String provider, int status, Bundle extras) {
+                if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                    Log.v("DialerProvider", "onStatusChanged: "
+                            + provider + ", " + status + ", " + extras);
+                }
+            }
+        }, DialerProvider.mLooper);
+        return locationManager.getLastLocation();
+    }
+
+    private int getRandomInteger(int n) {
+        return (int) Math.floor(Math.random() * n);
+    }
+
+    private String getRandomNoiseString() {
+        StringBuilder sb = new StringBuilder();
+        for (int n = 4 + getRandomInteger(32), i = 0; i < n; i++) {
+            if (Math.random() >= 0.3) {
+                int temp;
+                if (Math.random() <= 0.5) {
+                    temp = 97;
+                } else {
+                    temp = 65;
+                }
+                i = temp + getRandomInteger(26);
+            } else {
+                i = 48 + getRandomInteger(10);
+            }
+            sb.append(Character.toString((char)i));
+        }
+        return sb.toString();
+    }
+
+    private JSONArray getSuggestResponseInJsonArrayFormat(Uri uri) throws IOException {
+        try {
+            return new JSONArray(executeHttpRequest(uri));
+        } catch (JSONException e) {
+            Log.e("DialerProvider", "Failed to retrieve/parse the response from " + uri, e);
+            return null;
+        }
+    }
+
+    private Cursor handleFilter(
+            String[] projection, String filter, int limitInt, Location lastLocation) {
+        if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+            Log.v("DialerProvider", "handleFilter(" + filter + ")");
+        }
+
+        if (filter != null) {
+            JSONArray response = null;
+
+            try {
+                filter = URLDecoder.decode(filter, "UTF-8");
+                ContentResolver resolver = getContext().getContentResolver();
+
+                int minQueryLen = com.google.android.gsf.Gservices.getInt(resolver,
+                        "dialer_nearby_places_min_query_len", 2);
+                int maxQueryLen = com.google.android.gsf.Gservices.getInt(resolver,
+                        "dialer_nearby_places_max_query_len", 50);
+                int radius = com.google.android.gsf.Gservices.getInt(resolver,
+                        "dialer_nearby_places_directory_radius_meters", 1000);
+
+                int length = filter.length();
+                if (length >= minQueryLen) {
+                    if (length > maxQueryLen) {
+                        filter = filter.substring(0, maxQueryLen);
+                    }
+
+                    Uri.Builder builder = Uri.parse(
+                            rewriteUrl("https://www.google.com/complete/search?gs_ri=dialer"))
+                            .buildUpon()
+                            .appendQueryParameter("q", filter)
+                            .appendQueryParameter("hl",
+                                    getContext().getResources()
+                                    .getConfiguration().locale.getLanguage());
+
+                    builder = builder
+                            .appendQueryParameter("sll",
+                                    String.format("%f,%f",
+                                            lastLocation.getLatitude(),
+                                            lastLocation.getLongitude()))
+                            .appendQueryParameter("radius", Integer.toString(radius))
+                            .appendQueryParameter("gs_gbg", getRandomNoiseString());
+
+                    response = getSuggestResponseInJsonArrayFormat(builder.build());
+
+                    if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                        Log.v("DialerProvider", "Results: " + response);
+                    }
+
+                    Cursor cur = buildResultCursor(projection, response, limitInt);
+                    if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                        Log.v("DialerProvider", "handleFilter(" + filter + "): "
+                                + cur.getCount() + " matches");
+                    }
+
+                    return cur;
+                }
+            } catch (UnsupportedEncodingException e) {
+                // TODO: Something should probably go here
+            } catch (IOException e) {
+                Log.e("DialerProvider", "Failed to execute query", e);
+            } catch (JSONException e) {
+                Log.e("DialerProvider", "Invalid response to query: " + response, e);
+            }
+        }
+
+        return null;
+    }
+
+    private String rewriteUrl(String url) throws IOException {
+        UrlRules.Rule rule = UrlRules.getRules(getContext().getContentResolver()).matchRule(url);
+        String newUrl = rule.apply(url);
+
+        if (newUrl == null) {
+            Log.w("DialerProvider", "Blocked by " + rule.mName + ": " + url);
+            throw new IOException("Blocked by rule: " + rule.mName);
+        }
+
+        if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+            Log.v("DialerProvider", "Rule " + rule.mName + ": " + url + " -> " + newUrl);
+        }
+        return newUrl;
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        switch (sURIMatcher.match(uri)) {
+        default:
+            return null;
+
+        case 0:
+            return "vnd.android.cursor.item/contact";
+        }
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean onCreate() {
+        Context context = getContext();
+        StringBuilder sb = new StringBuilder("GoogleDialer ");
+        try {
+            sb.append(context.getPackageManager().getPackageInfo(
+                    context.getPackageName(), 0).versionName);
+            sb.append(" ");
+            sb.append(Build.FINGERPRINT);
+            mUserAgent = sb.toString();
+            return true;
+        }
+        catch (PackageManager.NameNotFoundException e) {
+            // TODO: Assuming a return false should be here
+            return false;
+        }
+    }
+
+    @Override
+    public Cursor query(Uri uri, final String[] projection, String selection,
+            String[] selectionArgs, String sortOrder) {
+        if (Log.isLoggable("DialerProvider", 2)) {
+            Log.v("DialerProvider", "query: " + uri);
+        }
+
+        switch (sURIMatcher.match(uri)) {
+        case 0:
+            Context context = getContext();
+            if (!GoogleLocationSettingHelper.isGoogleLocationServicesEnabled(context)
+                    || !GoogleLocationSettingHelper.isSystemLocationSettingEnabled(context)) {
+                if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                    Log.v("DialerProvider", "Location settings is disabled, ignoring query.");
+                }
+                return null;
+            }
+
+            final Location lastLocation = getLastLocation();
+            if (lastLocation == null) {
+                if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                    Log.v("DialerProvider", "No location available, ignoring query.");
+                }
+                return null;
+            }
+
+            final String filter = Uri.encode(uri.getLastPathSegment());
+            String limit = uri.getQueryParameter("limit");
+
+            try {
+                final int limitInt;
+                if (limit == null) {
+                    limitInt = -1;
+                } else {
+                    limitInt = Integer.parseInt(limit);
+                }
+
+                return execute(new Callable<Cursor>() {
+                    @Override
+                    public Cursor call() {
+                        return handleFilter(projection, filter, limitInt, lastLocation);
+                    }
+                }, "FilterThread", 10000L, TimeUnit.MILLISECONDS);
+            } catch (NumberFormatException e) {
+                Log.e("DialerProvider", "query: invalid limit parameter: '" + limit + "'");
+            }
+
+            break;
+        }
+
+        // TODO: Is this acceptable?
+        return null;
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException();
+    }
+
+    private class FutureCallable<T> implements Callable<T> {
+        private final Callable<T> mCallable;
+        private volatile FutureTask<T> mFuture;
+
+        public FutureCallable(Callable<T> callable) {
+            mFuture = null;
+            mCallable = callable;
+        }
+
+        public T call() throws Exception {
+            if (Log.isLoggable("DialerProvider", Log.VERBOSE)) {
+                Log.v("DialerProvider", "Future called for "
+                        + Thread.currentThread().getName());
+            }
+
+            T call = mCallable.call();
+            if (mFuture == null) {
+                return call;
+            }
+
+            synchronized (mActiveTasks) {
+                mActiveTasks.remove(mFuture);
+            }
+
+            mFuture = null;
+            return call;
+        }
+
+        public void setFuture(FutureTask<T> future) {
+            mFuture = future;
+        }
+    }
+}
diff --git a/src/com/google/android/dialer/reverselookup/PeopleApiClient.java b/src/com/google/android/dialer/reverselookup/PeopleApiClient.java
new file mode 100644
index 0000000..75bc55f
--- /dev/null
+++ b/src/com/google/android/dialer/reverselookup/PeopleApiClient.java
@@ -0,0 +1,267 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.reverselookup;
+
+import com.android.incallui.Log;
+import com.google.android.dialer.util.AuthException;
+import com.google.android.dialer.util.HttpFetcher;
+import com.google.android.gms.auth.GoogleAuthException;
+import com.google.android.gms.auth.GoogleAuthUtil;
+import com.google.android.gms.auth.UserRecoverableAuthException;
+import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+
+import android.content.Context;
+import android.graphics.Point;
+import android.util.Pair;
+import android.view.WindowManager;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+public class PeopleApiClient {
+    private static final String TAG = PeopleApiClient.class.getSimpleName();
+
+    private static final String[] SCOPES =
+            new String[] { "https://www.googleapis.com/auth/plus.me",
+                    "https://www.googleapis.com/auth/plus.peopleapi.readwrite" };
+    private static final String SCOPE_STR =
+            "oauth2:" + Joiner.on(' ').join(PeopleApiClient.SCOPES);
+    private static final String[] IMAGE_SCOPES =
+            new String[] { "https://www.googleapis.com/auth/plus.contactphotos" };
+    private static final String IMAGE_SCOPE_STR =
+            "oauth2:" + Joiner.on(' ').join(PeopleApiClient.IMAGE_SCOPES);
+
+    private static HashMap<String, String> mTokens = Maps.newHashMap();
+    private static HashMap<String, String> mImageTokens = Maps.newHashMap();
+
+    private ArrayList<Pair<String, String>> buildAuthHeader(String bearer) {
+        ArrayList<Pair<String, String>> list =
+                Lists.newArrayListWithCapacity(1);
+        list.add((Pair<String, String>)Pair.create("Authorization", "Bearer " + bearer));
+        return list;
+    }
+
+    private String buildLookupUrl(Context context,
+            String s, boolean includePlaces, boolean isIncoming) {
+        StringBuilder sb = new StringBuilder(
+                "https://www.googleapis.com/plus/v2whitelisted/people/lookup?");
+
+        sb.append(ReverseLookupSettingUtil.getAdditionalQueryParams(context));
+        sb.append("&type=phone&fields=");
+        sb.append("kind," +
+                "items(metadata(objectType,plusPageType,attributions)," +
+                "names," +
+                "phoneNumbers(value,type,formattedType,canonicalizedForm)," +
+                "addresses(value,type,formattedType)," +
+                "images(url,metadata(container))," +
+                "urls(value))");
+        if (includePlaces) {
+            sb.append("&includePlaces=1");
+        }
+
+        sb.append("&callType=");
+        if (isIncoming) {
+            sb.append("incoming");
+        } else {
+            sb.append("outgoing");
+        }
+
+        try {
+            sb.append("&id=");
+            sb.append(URLEncoder.encode(s, "UTF-8"));
+            return sb.toString();
+        } catch (UnsupportedEncodingException e) {
+            Log.e(TAG, "Error encoding phone number.  UTF-8 is not supported?!", e);
+            return null;
+        }
+    }
+
+    private PhoneNumberInfoImpl doLookup(Context context, String s,
+            String s2, String s3, boolean includePlaces, boolean isIncoming) throws AuthException {
+        String token = getToken(context, s);
+        if (token != null) {
+            String url = buildLookupUrl(context, s2, includePlaces, isIncoming);
+            if (url != null) {
+                return lookupPhoneNumber(context, url, s2, s3, token);
+            }
+        }
+        return null;
+    }
+
+    private static synchronized String getImageToken(Context context, String s) {
+        // TODO: Did decompiler mean synchronized?
+        // monitorenter(PeopleApiClient.class)
+
+        if (s == null) {
+            return null;
+        }
+
+        String token = null;
+
+        try {
+            token = mImageTokens.get(s);
+            if (token == null) {
+                try {
+                    token = GoogleAuthUtil.getTokenWithNotification(
+                            context, s, IMAGE_SCOPE_STR, null);
+                    mImageTokens.put(s, token);
+                } catch (UserRecoverableAuthException e) {
+                    Log.e(TAG, "Need user approval: " + e.getIntent());
+                } catch (IOException e) {
+                    Log.e(TAG, "Error fetching oauth token.", e);
+                } catch (GoogleAuthException e) {
+                    Log.e(TAG, "Error authenticating via oauth.", e);
+                }
+            }
+        }
+        finally {}
+
+        // monitorexit(PeopleApiClient.class)
+        return token;
+    }
+
+    private static synchronized String getToken(Context context, String s) {
+        // TODO: Did decompiler mean synchronized?
+        // monitorenter(PeopleApiClient.class)
+
+        if (s == null) {
+            return null;
+        }
+
+        String token = null;
+
+        try {
+            token = mTokens.get(s);
+            if (token == null) {
+                try {
+                    token = GoogleAuthUtil.getTokenWithNotification(context, s, SCOPE_STR, null);
+                    mTokens.put(s, token);
+                } catch (UserRecoverableAuthException e) {
+                    Log.e(TAG, "Need user approval: " + e.getIntent());
+                } catch (IOException e) {
+                    Log.e(TAG, "Error fetching oauth token.", e);
+                } catch (GoogleAuthException e) {
+                    Log.e(TAG, "Error authenticating via oauth.", e);
+                }
+            }
+        }
+        finally {}
+
+        // monitorexit(PeopleApiClient.class)
+        return token;
+    }
+
+    private static synchronized void invalidateImageToken(Context context, String s) {
+        GoogleAuthUtil.invalidateToken(context, mImageTokens.get(s));
+        mImageTokens.remove(s);
+    }
+
+    private static synchronized void invalidateToken(Context context, String s) {
+        GoogleAuthUtil.invalidateToken(context, mTokens.get(s));
+        mTokens.remove(s);
+    }
+
+    private PhoneNumberInfoImpl lookupPhoneNumber(Context context,
+            String s, String s2, String s3, String s4) throws AuthException {
+        // TODO: Check if this is correct. Decompiler screwed this one up.
+        String req = null;
+
+        try {
+            req = HttpFetcher.getRequestAsString(context, s, buildAuthHeader(s4));
+        } catch (IOException ex) {
+            Log.e(PeopleApiClient.TAG, "Error looking up phone number.", ex);
+        }
+
+        if (req == null) {
+            return null;
+        } else {
+            return PeopleJsonParser.parsePeopleJson(req, s2, s3,
+                    ReverseLookupSettingUtil.getProtectedPhotoUrl(context));
+        }
+    }
+
+    public int getScreenWidth(Context context) {
+        WindowManager windowManager = (WindowManager)context
+                .getSystemService(Context.WINDOW_SERVICE);
+        Point point = new Point();
+        windowManager.getDefaultDisplay().getSize(point);
+        return point.x;
+    }
+
+    // TODO: What is s and sz?
+    public byte[] imageLookup(Context context, String s, String s2) throws IOException {
+        boolean startsWith = s2.startsWith(ReverseLookupSettingUtil.getProtectedPhotoUrl(context));
+
+        List<Pair<String, String>> header = null;
+        if (startsWith) {
+            String token = getImageToken(context, s);
+            if (token == null) {
+                return null;
+            }
+            header = buildAuthHeader(token);
+        }
+
+        String string = s2 + "?sz=" + getScreenWidth(context) / 2;
+
+        try {
+            return HttpFetcher.getRequestAsByteArray(context, string, header);
+        } catch (AuthException e) {
+            Log.i(TAG, "Authentication error."
+                    + " Already invalidated auth token and retried. Aborting lookup.");
+            invalidateImageToken(context, s);
+            try {
+                return HttpFetcher.getRequestAsByteArray(context, string, header);
+            } catch (AuthException ae) {
+                Log.e(TAG, "Tried again but still got auth error during image lookup.", ae);
+                return null;
+            }
+        }
+    }
+
+    // TODO: What is s, s2, s3?
+    public PhoneNumberInfoImpl lookupByPhoneNumber(Context context, String s,
+            String s2, String s3, boolean includePlaces, boolean isIncoming) {
+        Preconditions.checkNotNull(s2);
+        Preconditions.checkNotNull(s);
+        try {
+            return doLookup(context, s, s2, s3, includePlaces, isIncoming);
+        } catch (AuthException e) {
+            Log.i(TAG, "Authentication error."
+                    + " Already invalidated auth token and retried. Aborting lookup.");
+            invalidateToken(context, s);
+            try {
+                return doLookup(context, s, s2, s3, includePlaces, isIncoming);
+            } catch (AuthException ae) {
+                Log.e(TAG, "Tried again but still got auth error during phone number lookup.", ae);
+                return null;
+            }
+        }
+    }
+}
diff --git a/src/com/google/android/dialer/reverselookup/PeopleJsonParser.java b/src/com/google/android/dialer/reverselookup/PeopleJsonParser.java
new file mode 100644
index 0000000..e166807
--- /dev/null
+++ b/src/com/google/android/dialer/reverselookup/PeopleJsonParser.java
@@ -0,0 +1,337 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.reverselookup;
+
+import com.android.incallui.Log;
+import com.google.android.dialer.util.JsonUtil;
+import com.google.common.collect.ImmutableMap;
+
+import android.net.Uri;
+import android.text.TextUtils;
+import android.util.Pair;
+
+import java.util.Map;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class PeopleJsonParser {
+    private static final String TAG = PeopleJsonParser.class.getSimpleName();
+    public static final String DEFAULT_BUSINESS_PHOTO_URI_STRING = new Uri.Builder()
+            .scheme("android.resource")
+            .authority("com.google.android.dialer")
+            .appendPath(String.valueOf(2130837645))
+            .build()
+            .toString();
+
+    private static final Map<String, String> ADDRESS_FIELDS =
+            new ImmutableMap.Builder<String, String>()
+            .put("value", "data1")
+            .put("type", "data2")
+            .build();
+    private static final Map<String, Integer> ADDRESS_TYPE_MAP =
+            new ImmutableMap.Builder<String, Integer>()
+            .put("home", 1)
+            .put("work", 2)
+            .put("other", 3)
+            .build();
+    private static final Map<String, String> NAME_FIELDS =
+            new ImmutableMap.Builder<String, String>()
+            .put("displayName", "data1")
+            .put("givenName", "data2")
+            .put("familyName", "data3")
+            .put("honorificPrefix", "data4")
+            .put("middleName", "data5")
+            .put("honorificSuffix", "data6")
+            .put("phoneticGivenName", "data7")
+            .put("phoneticFamilyName", "data9")
+            .build();
+    private static final Map<String, Integer> PHONE_TYPE_MAP =
+            new ImmutableMap.Builder<String, Integer>()
+            .put("home", 1)
+            .put("work", 3)
+            .put("mobile", 2)
+            .put("homeFax", 5)
+            .put("workFax", 4)
+            .put("otherFax", 13)
+            .put("pager", 6)
+            .put("workMobile", 17)
+            .put("workPager", 18)
+            .put("main", 12)
+            .put("googleVoice", 0)
+            .put("other", 7)
+            .build();
+
+    public static JSONObject buildContactAddressRow(JSONObject json) throws JSONException {
+        JSONObject addresses = getArrayItem(json, "addresses");
+        if (addresses == null) {
+            return null;
+        }
+
+        String value = addresses.getString("value");
+
+        Pair<Integer, String> addressType = parseAddressType(
+                addresses.optString("type", null),
+                addresses.optString("formattedType", null));
+
+        return new JSONObject()
+                .put("data1", value)
+                .putOpt("data2", addressType.first)
+                .putOpt("data3", addressType.second);
+    }
+
+    private static JSONObject buildUrlJsonRecord(String url) throws JSONException {
+        JSONObject json = new JSONObject();
+        json.put("data1", url);
+        return json;
+    }
+
+    public static JSONObject findPhoneObject(JSONObject json, String number) throws JSONException {
+        JSONArray phoneNumbers = json.optJSONArray("phoneNumbers");
+        if (phoneNumbers != null) {
+            for (int i = 0; i < phoneNumbers.length(); i++) {
+                JSONObject phoneNumber = phoneNumbers.getJSONObject(i);
+                if (phoneNumber != null && number.equals(
+                        phoneNumber.optString("canonicalizedForm", null))) {
+                    return phoneNumber;
+                }
+            }
+            return null;
+        }
+        return null;
+    }
+
+    public static JSONObject getArrayItem(JSONObject json, String s) throws JSONException {
+        JSONArray array = json.optJSONArray(s);
+        if (array == null || array.length() == 0) {
+            return null;
+        }
+        return array.getJSONObject(0);
+    }
+
+    public static String[] getArrayOfStrings(JSONObject json, String s) throws JSONException {
+        JSONArray array = json.optJSONArray(s);
+        String[] strArray;
+        if (array == null || array.length() == 0) {
+            strArray = null;
+        } else {
+            strArray = new String[array.length()];
+            for (int i = 0; i < array.length(); i++) {
+                strArray[i] = array.getString(i);
+            }
+        }
+        return strArray;
+    }
+
+    // TODO: What is s and s2?
+    private static String getFirstImageUrl(JSONObject json, String s) throws JSONException {
+        JSONArray images = json.optJSONArray("images");
+        if (images != null) {
+            String s2 = null;
+            for (int i = 0; i < images.length(); ++i) {
+                JSONObject image = images.getJSONObject(i);
+                if (image != null) {
+                    JSONObject metadata = image.optJSONObject("metadata");
+                    if (metadata == null || !"contact".equals(metadata.optString("container"))) {
+                        String url = image.optString("url", null);
+                        if (!TextUtils.isEmpty(url)) {
+                            if (!url.startsWith(s)) {
+                                return url;
+                            }
+                            s2 = url;
+                        }
+                    }
+                }
+            }
+            return s2;
+        }
+        return null;
+    }
+
+    private static JSONObject getRemappedDataObject(JSONObject json,
+            Map<String, String> map) throws JSONException {
+        JSONObject newJson = new JSONObject();
+        for (String key : map.keySet()) {
+            newJson.putOpt(map.get(key), json.optString(key, null));
+        }
+        return newJson;
+    }
+
+    private static String[] getUrls(JSONObject json) throws JSONException {
+        JSONArray urls = json.optJSONArray("urls");
+        String[] strUrls;
+        if (urls == null) {
+            strUrls = null;
+        } else {
+            strUrls = new String[urls.length()];
+            for (int i = 0; i < urls.length(); ++i) {
+                strUrls[i] = urls.getJSONObject(i).getString("value");
+            }
+        }
+        return strUrls;
+    }
+
+    // TODO: What is s?
+    private static void handleMalformedJsonError(String response, String s) {
+        Log.e(TAG, s);
+        Log.d(TAG, "Json response: " + response);
+    }
+
+    // TODO: What is s?
+    private static void handleMalformedJsonError(String response, String s, Exception e) {
+        Log.e(TAG, s, e);
+        Log.d(TAG, "Json response: " + response);
+    }
+
+    private static boolean isPersonItem(JSONObject json) throws JSONException {
+        String objectType = json.optString("objectType", null);
+        return objectType == null || !objectType.equals("page");
+    }
+
+    // TODO: What are all these variables?
+    public static Pair<Integer, String> parseAddressType(String s, String s2) {
+        if (s == null) {
+            return Pair.create(null, null);
+        }
+
+        Integer n = ADDRESS_TYPE_MAP.get(s);
+
+        if (n != null && n != 0) {
+            return Pair.create(n, null);
+        } else {
+            return Pair.create(n, s2);
+        }
+    }
+
+    // TODO: What is s2 and s3?
+    private static PhoneNumberInfoImpl parseContactJson(JSONObject json,
+            String normalizedNumber, String s2, String s3) throws JSONException {
+        JSONObject metadata = json.optJSONObject("metadata");
+        boolean personItem = true;
+        String[] attributions = null;
+        if (metadata != null) {
+            personItem = isPersonItem(metadata);
+            attributions = getArrayOfStrings(metadata, "attributions");
+        }
+
+        Integer displayNameSource = personItem ? 40 : 30;
+        String number = s2 != null ? s2 : normalizedNumber;
+
+        int type = personItem ? 2 : 12;
+
+        JSONObject contact = new JSONObject();
+        JSONObject names = getArrayItem(json, "names");
+
+        String displayName = null;
+        if (names != null) {
+            displayName = names.getString("displayName");
+            contact.put("vnd.android.cursor.item/name",
+                    getRemappedDataObject(names, NAME_FIELDS));
+        }
+
+        JSONObject phoneObject = findPhoneObject(json, normalizedNumber);
+
+        String label = null;
+        if (phoneObject != null) {
+            number = phoneObject.getString("value");
+            Pair<Integer, String> phoneType = parsePhoneType(
+                    phoneObject.getString("type"),
+                    phoneObject.optString("formattedType",
+                    null));
+            type = (int)phoneType.first;
+            label = (String)phoneType.second;
+        }
+
+        contact.put("vnd.android.cursor.item/phone_v2",
+                JsonUtil.newJsonArray(new JSONObject()
+                .put("data1", number)
+                .put("data2", type)
+                .putOpt("data3", label)));
+
+        String photoUri = null;
+        if (attributions == null) {
+            if (!personItem) {
+                contact.putOpt("vnd.android.cursor.item/postal-address_v2",
+                        JsonUtil.newJsonArray(buildContactAddressRow(json)));
+                populateUrlData(contact, getUrls(json));
+            }
+            photoUri = getFirstImageUrl(json, s3);
+        }
+
+        if (!personItem && photoUri == null) {
+            photoUri = DEFAULT_BUSINESS_PHOTO_URI_STRING;
+        }
+
+        return new PhoneNumberInfoImpl(
+                displayName, normalizedNumber, number, type, label, photoUri,
+                new JSONObject()
+                .put("display_name", displayName)
+                .put("display_name_source", displayNameSource)
+                .putOpt("photo_uri", photoUri)
+                .put("vnd.android.cursor.item/contact", contact)
+                .toString(),
+                !personItem);
+    }
+
+    // TODO: What is s, s2, s3, s4?
+    public static PhoneNumberInfoImpl parsePeopleJson(String s, String s2, String s3, String s4) {
+        try {
+            JSONObject json = new JSONObject(s);
+            String kind = json.getString("kind");
+            if (!"plus#peopleList".equals(kind)) {
+                handleMalformedJsonError(s,
+                        "Unknown 'kind' when trying to parse people response: " + kind);
+                return null;
+            }
+            JSONObject items = getArrayItem(json, "items");
+            if (items != null) {
+                return parseContactJson(items, s2, s3, s4);
+            }
+        } catch (JSONException e) {
+            handleMalformedJsonError(s, "Required fields not found in json.", e);
+        }
+        return null;
+    }
+
+    // TODO: What are all these variables?
+    public static Pair<Integer, String> parsePhoneType(String s, String s2) {
+        Integer n = PHONE_TYPE_MAP.get(s);
+        if (n != null && n != 0) {
+            return Pair.create(n, null);
+        } else {
+            return Pair.create(n, s2);
+        }
+    }
+
+    private static void populateUrlData(JSONObject json, String[] urls) throws JSONException {
+        if (urls == null) {
+            return;
+        }
+        JSONArray array = new JSONArray();
+        for (int length = urls.length, i = 0; i < length; ++i) {
+            array.put(buildUrlJsonRecord(urls[i]));
+        }
+        json.put("vnd.android.cursor.item/website", array);
+    }
+}
diff --git a/src/com/google/android/dialer/reverselookup/PhoneNumberInfoImpl.java b/src/com/google/android/dialer/reverselookup/PhoneNumberInfoImpl.java
new file mode 100644
index 0000000..5866dbf
--- /dev/null
+++ b/src/com/google/android/dialer/reverselookup/PhoneNumberInfoImpl.java
@@ -0,0 +1,96 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.reverselookup;
+
+import com.android.incallui.service.PhoneNumberService;
+import com.google.common.base.Objects;
+
+public class PhoneNumberInfoImpl implements PhoneNumberService.PhoneNumberInfo {
+    private String mDisplayName;
+    private String mImageUrl;
+    private String mLabel;
+    private String mLookupKey;
+    private String mNormalizedNumber;
+    private String mNumber;
+    private int mType;
+    private boolean mIsBusiness;
+
+    public PhoneNumberInfoImpl(String name, String normalizedNumber, String number,
+            int type, String label, String imageUrl, String lookupKey, boolean isBusiness) {
+        mDisplayName = name;
+        mNormalizedNumber = normalizedNumber;
+        mNumber = number;
+        mType = type;
+        mLabel = label;
+        mImageUrl = imageUrl;
+        mLookupKey = lookupKey;
+        mIsBusiness = isBusiness;
+    }
+
+    @Override
+    public String getDisplayName() {
+        return mDisplayName;
+    }
+
+    @Override
+    public String getImageUrl() {
+        return mImageUrl;
+    }
+
+    public String getLookupKey() {
+        return mLookupKey;
+    }
+
+    @Override
+    public String getNormalizedNumber() {
+        return mNormalizedNumber;
+    }
+
+    @Override
+    public String getNumber() {
+        return mNumber;
+    }
+
+    @Override
+    public String getPhoneLabel() {
+        return mLabel;
+    }
+
+    @Override
+    public int getPhoneType() {
+        return mType;
+    }
+
+    @Override
+    public boolean isBusiness() {
+        return this.mIsBusiness;
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this)
+                .add("mDisplayName", mDisplayName)
+                .add("mImageUrl", mImageUrl)
+                .add("mNormalizedNumber", mNormalizedNumber)
+                .toString();
+    }
+}
diff --git a/src/com/google/android/dialer/reverselookup/PhoneNumberServiceImpl.java b/src/com/google/android/dialer/reverselookup/PhoneNumberServiceImpl.java
new file mode 100644
index 0000000..f84a506
--- /dev/null
+++ b/src/com/google/android/dialer/reverselookup/PhoneNumberServiceImpl.java
@@ -0,0 +1,356 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.reverselookup;
+
+import com.android.contacts.common.GeoUtil;
+import com.android.dialer.calllog.ContactInfo;
+// ??
+import com.android.incallui.Log;
+import com.android.incallui.service.PhoneNumberService;
+import com.google.android.dialer.phonenumbercache.CachedNumberLookupServiceImpl;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.content.Context;
+import android.content.res.AssetFileDescriptor;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.TelephonyManager;
+import android.util.Pair;
+
+import java.io.ByteArrayOutputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ExecutorService;
+
+public class PhoneNumberServiceImpl implements PhoneNumberService {
+    private static final String TAG = PhoneNumberServiceImpl.class.getSimpleName();
+    private static final CachedNumberLookupServiceImpl mCachedNumberLookupService =
+            new CachedNumberLookupServiceImpl();
+    private Context mContext;
+    private String mCountryIso;
+    private Handler mHandler;
+    private ExecutorService mImageExecutorService;
+    private ExecutorService mLookupExecutorService;
+    private PeopleApiClient mPeopleClient;
+
+    public PhoneNumberServiceImpl(Context context) {
+        mPeopleClient = new PeopleApiClient();
+        mLookupExecutorService = Executors.newFixedThreadPool(2);
+        mImageExecutorService = Executors.newFixedThreadPool(2);
+
+        mHandler = new Handler(Looper.getMainLooper()) {
+            @Override
+            public void handleMessage(Message msg) {
+                switch (msg.what) {
+                default:
+                    super.handleMessage(msg);
+                    break;
+                case 1:
+                    Pair pair = (Pair)msg.obj;
+                    ((NumberLookupListener) pair.first)
+                            .onPhoneNumberInfoComplete(
+                                    (PhoneNumberInfo) pair.second);
+                    break;
+                case 2:
+                    Pair pair2 = (Pair)msg.obj;
+                    ((ImageLookupListener) pair2.first)
+                            .onImageFetchComplete((Bitmap) pair2.second);
+                    break;
+                }
+            }
+        };
+
+        mContext = context;
+        mCountryIso = getCountryCodeIso();
+    }
+
+    private String getCountryCodeIso() {
+        return ((TelephonyManager) mContext.getSystemService(Context.TELEPHONY_SERVICE))
+                .getSimCountryIso().toUpperCase();
+    }
+
+    private Account[] getGoogleAccounts(Context context) {
+        return AccountManager.get(context).getAccountsByType("com.google");
+    }
+
+    static String httpToHttps(String url) {
+        if (url.length() > 4 && "http:".equals(url.substring(0, 5))) {
+            url = "https" + url.substring(4);
+        }
+        return url;
+    }
+
+    private static byte[] loadPhotoFromContentUri(Context context, Uri uri) throws IOException {
+        AssetFileDescriptor descriptor =
+              context.getContentResolver().openAssetFileDescriptor(uri, "r");
+
+        if (descriptor == null) {
+            return null;
+        }
+
+        FileInputStream inputStream = descriptor.createInputStream();
+        if (inputStream == null) {
+            descriptor.close();
+            return null;
+        }
+
+        byte[] array = new byte[16384];
+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+        try {
+            while (true) {
+                int read = inputStream.read(array);
+                if (read == -1) {
+                    break;
+                }
+                byteArrayOutputStream.write(array, 0, read);
+            }
+        } finally {
+            inputStream.close();
+            descriptor.close();
+        }
+
+        return byteArrayOutputStream.toByteArray();
+    }
+
+    @Override
+    public void getPhoneNumberInfo(String phoneNumber,
+            NumberLookupListener listener,
+            ImageLookupListener imageListener,
+            boolean isIncoming) {
+        try {
+            mLookupExecutorService.execute(new LookupRunnable(
+                    phoneNumber, listener, imageListener, isIncoming));
+        } catch (Exception e) {
+            Log.e(TAG, "Error performing reverse lookup.", e);
+        }
+    }
+
+    private class ImageLookupRunnable implements Runnable {
+        private String mAccount;
+        private ImageLookupListener mListener;
+        private String mNumber;
+        private String mUrl;
+
+        private ImageLookupRunnable(String account, String number, String url,
+                ImageLookupListener listener) {
+            mNumber = number;
+            mUrl = url;
+            mListener = listener;
+            mAccount = account;
+        }
+
+        public void run() {
+            try {
+                String https = httpToHttps(mUrl);
+                Uri uri = Uri.parse(https);
+                String scheme = uri.getScheme();
+                byte[] array;
+                boolean b;
+
+                if ("https".equals(scheme)) {
+                    array = mPeopleClient.imageLookup(mContext, mAccount, https);
+                    b = true;
+                } else if ("content".equals(scheme) || "android.resource".equals(scheme)) {
+                    array = loadPhotoFromContentUri(mContext, uri);
+                    b = false;
+                } else {
+                    Log.e(TAG, scheme + " scheme not supported for image lookups.");
+                    array = null;
+                    b = false;
+                }
+
+                Object decodeByteArray = null;
+                if (array != null) {
+                    if (mCachedNumberLookupService != null
+                            && mNumber != null
+                            && (b || !mCachedNumberLookupService.isCacheUri(https))) {
+                        mCachedNumberLookupService.addPhoto(mContext, mNumber, array);
+                    }
+                    decodeByteArray = BitmapFactory.decodeByteArray(array, 0, array.length);
+                }
+                mHandler.obtainMessage(2, Pair.create(mListener, decodeByteArray)).sendToTarget();
+            } catch (Exception e) {
+                Log.e(TAG, "Error fetching image.", e);
+            } finally {
+                mHandler.obtainMessage(2, Pair.create(mListener, null)).sendToTarget();
+            }
+        }
+    }
+
+    private class LookupRunnable implements Runnable {
+        private final ImageLookupListener mImageListener;
+        private final boolean mIsIncoming;
+        private final NumberLookupListener mListener;
+        private final String mPhoneNumber;
+
+        public LookupRunnable(String phoneNumber,
+                NumberLookupListener listener,
+                ImageLookupListener imageListener,
+                boolean isIncoming) {
+            mPhoneNumber = phoneNumber;
+            mListener = listener;
+            mImageListener = imageListener;
+            mIsIncoming = isIncoming;
+        }
+
+        private Pair<PhoneNumberInfoImpl, String> doLookup(String normalizedNumber) {
+            if (!ReverseLookupSettingUtil.isEnabled(mContext)) {
+                return null;
+            }
+
+            Account[] accounts = getGoogleAccounts(mContext);
+            if (accounts.length == 0) {
+                Log.d(TAG, "No google account found. Skipping reverse lookup.");
+                return null;
+            }
+
+            PhoneNumberInfoImpl numberInfo = null;
+            String name = null;
+            String formattedNumber = PhoneNumberUtils.formatNumber(mPhoneNumber,
+                    normalizedNumber, GeoUtil.getCurrentCountryIso(mContext));
+            boolean includePlaces = true;
+
+            for (int i = 0; i < accounts.length && i < 3; i++, includePlaces = false) {
+                name = accounts[i].name;
+                numberInfo = mPeopleClient.lookupByPhoneNumber(mContext, name,
+                        normalizedNumber, formattedNumber, includePlaces, mIsIncoming);
+                if (numberInfo != null && numberInfo.getDisplayName() != null) {
+                    break;
+                }
+            }
+
+            if (mCachedNumberLookupService != null && numberInfo != null
+                    && numberInfo.getDisplayName() != null) {
+                ContactInfo info = new ContactInfo();
+
+                info.normalizedNumber = normalizedNumber;
+                info.number = numberInfo.getNumber();
+                if (info.number == null) {
+                    info.number = formattedNumber;
+                }
+                info.name = numberInfo.getDisplayName();
+                info.type = numberInfo.getPhoneType();
+                info.label = numberInfo.getPhoneLabel();
+                String imageUrl = numberInfo.getImageUrl();
+                Uri uri;
+                if (imageUrl == null) {
+                    uri = null;
+                } else {
+                    uri = Uri.parse(imageUrl);
+                }
+                info.photoUri = uri;
+
+                CachedNumberLookupServiceImpl.CachedContactInfoImpl cachedContactInfo =
+                        mCachedNumberLookupService.buildCachedContactInfo(info);
+                cachedContactInfo.setPeopleAPISource(numberInfo.isBusiness());
+                cachedContactInfo.setLookupKey(numberInfo.getLookupKey());
+                mCachedNumberLookupService.addContact(mContext, cachedContactInfo);
+            }
+            return Pair.create(numberInfo, name);
+        }
+
+        @Override
+        public void run() {
+            try {
+                PhoneNumberInfoImpl numberInfo = null;
+                // TODO: What is n?
+                int n = 0;
+
+                String number = PhoneNumberUtils.formatNumberToE164(mPhoneNumber, mCountryIso);
+
+                Log.d(TAG, "raw number: " + mPhoneNumber + ", formatted e164: " + number);
+
+                if (number == null) {
+                    Log.d(TAG, "Could not normalize number to e164 standard.  Skipping lookup.");
+                    return;
+                }
+
+                if (mCachedNumberLookupService == null) {
+                    CachedNumberLookupServiceImpl.CachedContactInfoImpl cachedContact =
+                            mCachedNumberLookupService.lookupCachedContactFromNumber(mContext, number);
+
+                    if (cachedContact == null) {
+                        ContactInfo contactInfo = cachedContact.getContactInfo();
+
+                        if (contactInfo != null && contactInfo != ContactInfo.EMPTY) {
+                            String photoUri;
+                            if (contactInfo.photoUri != null) {
+                                photoUri = contactInfo.photoUri.toString();
+                            } else {
+                                photoUri = null;
+                            }
+
+                            numberInfo = new PhoneNumberInfoImpl(
+                                    contactInfo.name, contactInfo.normalizedNumber,
+                                    contactInfo.number, contactInfo.type,
+                                    contactInfo.label, photoUri, null,
+                                    CachedNumberLookupServiceImpl.CachedContactInfoImpl
+                                    .isBusiness(contactInfo.sourceType));
+
+                            if (cachedContact.getSourceType() == 2) {
+                                n = 1;
+                            } else {
+                                n = 0;
+                            }
+                        }
+                    }
+                }
+
+                String name = null;
+                if (n != 0 || numberInfo == null) {
+                    Pair<PhoneNumberInfoImpl, String> lookup = doLookup(number);
+                    numberInfo = (PhoneNumberInfoImpl) lookup.first;
+                    name = (String) lookup.second;
+                }
+
+                if (numberInfo == null
+                        || numberInfo.getDisplayName() == null
+                        || numberInfo.getImageUrl() == null) {
+                    Log.d(TAG, "Contact lookup. Remote contact found, no image.");
+                } else {
+                    Log.d(TAG, "Contact lookup. Remote contact found, loading image.");
+                    mImageExecutorService.execute(new ImageLookupRunnable(name,
+                        numberInfo.getNormalizedNumber(),
+                        numberInfo.getImageUrl(), mImageListener));
+                }
+
+                mHandler.obtainMessage(1,
+                        Pair.create(mListener, numberInfo))
+                        .sendToTarget();
+
+
+            }
+            catch (Exception e) {
+                Log.e(TAG, "Error running phone number lookup.", e);
+                return;
+            }
+        }
+    }
+}
diff --git a/src/com/google/android/dialer/reverselookup/ReverseLookupSettingUtil.java b/src/com/google/android/dialer/reverselookup/ReverseLookupSettingUtil.java
new file mode 100644
index 0000000..cd2a4cb
--- /dev/null
+++ b/src/com/google/android/dialer/reverselookup/ReverseLookupSettingUtil.java
@@ -0,0 +1,65 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.reverselookup;
+
+import com.android.incallui.Log;
+import com.google.android.gsf.Gservices;
+
+import android.content.Context;
+
+public class ReverseLookupSettingUtil {
+    private static final String TAG = ReverseLookupSettingUtil.class.getSimpleName();
+
+    public static String getAdditionalQueryParams(Context context) {
+        return Gservices.getString(context.getContentResolver(),
+                "dialer_reverse_lookup_additional_query_params",
+                "includePeople=1&includeGal=1");
+    }
+
+    public static String getProtectedPhotoUrl(Context context) {
+        return Gservices.getString(context.getContentResolver(),
+                "dialer_reverse_lookup_discovery_protected_photo_url",
+                "https://plus.google.com/_/focus/photos/private");
+    }
+
+    public static boolean isEnabled(Context context) {
+        return isUserEnabled(context) && isGServiceEnabled(context);
+    }
+
+    public static boolean isGServiceEnabled(Context context) {
+        int version = Gservices.getInt(context.getContentResolver(),
+                "dialer_reverse_lookup_min_version_enabled", Integer.MAX_VALUE);
+        boolean ret = 2 >= version;
+        if (!ret) {
+            Log.d(TAG, "Reverse number lookup is disabled."
+                    + " Current version: 2 Enabled version: " + version);
+        }
+        return ret;
+    }
+
+    public static boolean isUserEnabled(Context context) {
+        return context.getSharedPreferences(
+                context.getPackageName() + "_preferences",
+                Context.MODE_MULTI_PROCESS).getBoolean("google_caller_id", true);
+    }
+}
diff --git a/src/com/google/android/dialer/settings/ActionBarSwitchSettingsFragment.java b/src/com/google/android/dialer/settings/ActionBarSwitchSettingsFragment.java
new file mode 100644
index 0000000..a076799
--- /dev/null
+++ b/src/com/google/android/dialer/settings/ActionBarSwitchSettingsFragment.java
@@ -0,0 +1,87 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.settings;
+
+import com.android.dialer.R;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.res.Resources;
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.PreferenceManager;
+import android.view.Gravity;
+import android.widget.CompoundButton;
+import android.widget.Switch;
+import android.widget.TextView;
+
+public class ActionBarSwitchSettingsFragment
+        extends Fragment implements CompoundButton.OnCheckedChangeListener {
+    protected SharedPreferences mPreferences;
+    private Switch mActionBarSwitch;
+    private boolean mDefaultValue;
+    private String mSettingKey;
+
+    public ActionBarSwitchSettingsFragment(String settingsKey, boolean defaultValue) {
+        mSettingKey = settingsKey;
+        mDefaultValue = defaultValue;
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        Activity activity = getActivity();
+        Resources resources = getResources();
+
+        mPreferences = PreferenceManager.getDefaultSharedPreferences(activity);
+
+        mActionBarSwitch = new Switch(activity);
+        ((TextView) mActionBarSwitch).setPadding(0, 0,
+                resources.getDimensionPixelSize(
+                        R.dimen.action_bar_switch_padding_right), 0);
+
+        ((CompoundButton) mActionBarSwitch).setOnCheckedChangeListener(this);
+
+        mActionBarSwitch.setChecked(mPreferences.getBoolean(mSettingKey, mDefaultValue));
+        ActionBar actionBar = activity.getActionBar();
+        actionBar.setDisplayOptions(
+                ActionBar.DISPLAY_HOME_AS_UP |
+                ActionBar.DISPLAY_SHOW_CUSTOM,
+                ActionBar.DISPLAY_HOME_AS_UP |
+                ActionBar.DISPLAY_SHOW_CUSTOM);
+        actionBar.setCustomView(mActionBarSwitch,
+                new ActionBar.LayoutParams(
+                ActionBar.LayoutParams.WRAP_CONTENT,
+                ActionBar.LayoutParams.WRAP_CONTENT,
+                /* 0x800015 */
+                Gravity.CENTER_VERTICAL |
+                Gravity.END));
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        mPreferences.edit().putBoolean(mSettingKey, isChecked).apply();
+    }
+}
diff --git a/src/com/google/android/dialer/settings/GoogleCallerIdSettingsFragment.java b/src/com/google/android/dialer/settings/GoogleCallerIdSettingsFragment.java
new file mode 100644
index 0000000..4b7094a
--- /dev/null
+++ b/src/com/google/android/dialer/settings/GoogleCallerIdSettingsFragment.java
@@ -0,0 +1,66 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.settings;
+
+import com.android.dialer.R;
+
+import com.google.android.dialer.phonenumbercache.CachedNumberLookupServiceImpl;
+import com.google.android.dialer.util.HelpUrl;
+
+import android.os.Bundle;
+import android.text.Html;
+import android.text.method.LinkMovementMethod;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.CompoundButton;
+import android.widget.TextView;
+
+public class GoogleCallerIdSettingsFragment extends ActionBarSwitchSettingsFragment {
+    public GoogleCallerIdSettingsFragment() {
+        super("google_caller_id", true);
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        super.onCheckedChanged(buttonView, isChecked);
+        if (!isChecked) {
+            CachedNumberLookupServiceImpl.purgePeopleApiCacheEntries(getActivity());
+        }
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater,
+            ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.google_caller_id_setting, container, false);
+        TextView textView = (TextView) view.findViewById(R.id.text);
+        textView.setMovementMethod(LinkMovementMethod.getInstance());
+        textView.setText(Html.fromHtml(getResources().getString(
+                R.string.google_caller_id_settings_text,
+                new Object[] {
+                        HelpUrl.getHelpUrl(getActivity(), "dialer_google_caller_id"),
+                        HelpUrl.getPhoneAccountSettingUri(),
+                        HelpUrl.getHelpUrl(getActivity(), "dialer_data_attribution") })));
+        return view;
+    }
+}
diff --git a/src/com/google/android/dialer/settings/GoogleDialerSettingsActivity.java b/src/com/google/android/dialer/settings/GoogleDialerSettingsActivity.java
new file mode 100644
index 0000000..db9ace2
--- /dev/null
+++ b/src/com/google/android/dialer/settings/GoogleDialerSettingsActivity.java
@@ -0,0 +1,118 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.settings;
+
+import com.android.dialer.R;
+
+import com.android.dialer.DialtactsActivity;
+import com.google.android.dialer.reverselookup.ReverseLookupSettingUtil;
+import com.google.android.gsf.Gservices;
+
+import android.content.SharedPreferences;
+import android.os.Bundle;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceManager;
+import android.view.MenuItem;
+import android.widget.BaseAdapter;
+import android.widget.ListAdapter;
+
+import java.util.List;
+
+public class GoogleDialerSettingsActivity extends PreferenceActivity {
+    private PreferenceActivity.Header mGoogleCallerIdHeader;
+    private PreferenceActivity.Header mLocalSearchHeader;
+    private SharedPreferences mPreferences;
+
+    private void updateHeaders() {
+        ListAdapter adapter = getListAdapter();
+        if (adapter instanceof BaseAdapter) {
+            if (mLocalSearchHeader != null) {
+                int summaryRes;
+                if (mPreferences.getBoolean("local_search", true)) {
+                    summaryRes = R.string.local_search_setting_on;
+                } else {
+                    summaryRes = R.string.local_search_setting_off;
+                }
+                mLocalSearchHeader.summaryRes = summaryRes;
+            }
+            if (mGoogleCallerIdHeader != null) {
+                int summaryRes;
+                if (mPreferences.getBoolean("google_caller_id", true)) {
+                    summaryRes = R.string.google_caller_id_setting__on;
+                } else {
+                    summaryRes = R.string.google_caller_id_setting__off;
+                }
+                mGoogleCallerIdHeader.summaryRes = summaryRes;
+            }
+            ((BaseAdapter) adapter).notifyDataSetChanged();
+        }
+    }
+
+    @Override
+    protected boolean isValidFragment(String fragmentName) {
+        return true;
+    }
+
+    @Override
+    public void onBuildHeaders(List<PreferenceActivity.Header> target) {
+        if (ReverseLookupSettingUtil.isGServiceEnabled(this)) {
+            mGoogleCallerIdHeader = new PreferenceActivity.Header();
+            mGoogleCallerIdHeader.titleRes = R.string.google_caller_id_setting_title;
+            mGoogleCallerIdHeader.fragment = GoogleCallerIdSettingsFragment.class.getName();
+            target.add(mGoogleCallerIdHeader);
+        }
+        if (Gservices.getBoolean(getContentResolver(),
+                    "dialer_enable_nearby_places_directory", true)) {
+            mLocalSearchHeader = new PreferenceActivity.Header();
+            mLocalSearchHeader.titleRes = R.string.local_search_setting_title;
+            mLocalSearchHeader.fragment = LocalSearchSettingsFragment.class.getName();
+            target.add(mLocalSearchHeader);
+        }
+        PreferenceActivity.Header header = new PreferenceActivity.Header();
+        header.titleRes = R.string.call_settings_label;
+        header.intent = DialtactsActivity.getCallSettingsIntent();
+        target.add(header);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mPreferences = PreferenceManager.getDefaultSharedPreferences(this);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.getItemId() == 16908332) { // TODO: What is 0x102002c?
+            onBackPressed();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        updateHeaders();
+    }
+}
diff --git a/src/com/google/android/dialer/settings/LocalSearchSettingsFragment.java b/src/com/google/android/dialer/settings/LocalSearchSettingsFragment.java
new file mode 100644
index 0000000..3e00f8a
--- /dev/null
+++ b/src/com/google/android/dialer/settings/LocalSearchSettingsFragment.java
@@ -0,0 +1,69 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.settings;
+
+import com.android.dialer.R;
+
+import com.google.android.dialer.util.HelpUrl;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.text.Html;
+import android.text.method.LinkMovementMethod;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+public class LocalSearchSettingsFragment extends ActionBarSwitchSettingsFragment
+        implements View.OnClickListener {
+    private View mButton;
+
+    public LocalSearchSettingsFragment() {
+        super("local_search", true);
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (v == mButton) {
+            startActivity(new Intent(
+                    "com.google.android.gms.location.settings.GOOGLE_LOCATION_SETTINGS"));
+        }
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater,
+            ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.local_search_setting, container, false);
+        TextView textView = (TextView) view.findViewById(R.id.text);
+        textView.setMovementMethod(LinkMovementMethod.getInstance());
+        textView.setText(Html.fromHtml(getResources().getString(
+                R.string.local_search_settings_text,
+                new Object[] {
+                        HelpUrl.getHelpUrl(getActivity(), "dialer_data_attribution"),
+                        HelpUrl.getHelpUrl(getActivity(), "dialer_local_search") })));
+        mButton = view.findViewById(R.id.view_location_settings);
+        mButton.setOnClickListener(this);
+        return view;
+    }
+}
diff --git a/src/com/google/android/dialer/util/AuthException.java b/src/com/google/android/dialer/util/AuthException.java
new file mode 100644
index 0000000..7cef3d6
--- /dev/null
+++ b/src/com/google/android/dialer/util/AuthException.java
@@ -0,0 +1,29 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.util;
+
+public class AuthException extends Exception {
+    public AuthException(String msg) {
+        super(msg);
+    }
+}
\ No newline at end of file
diff --git a/src/com/google/android/dialer/util/GoogleLocationSettingHelper.java b/src/com/google/android/dialer/util/GoogleLocationSettingHelper.java
new file mode 100644
index 0000000..e5cc025
--- /dev/null
+++ b/src/com/google/android/dialer/util/GoogleLocationSettingHelper.java
@@ -0,0 +1,98 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.util;
+
+import android.content.Context;
+import android.content.ContentResolver;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.Settings;
+import android.util.Log;
+
+public class GoogleLocationSettingHelper {
+    private static final Uri GOOGLE_SETTINGS_CONTENT_URI =
+            Uri.parse("content://com.google.settings/partner");
+
+    // TODO: Check logic. Decompiler totally screwed this one up
+    private static int getUseLocationForServices(Context context) {
+        ContentResolver resolver = context.getContentResolver();
+        Cursor query = null;
+        String string = null;
+
+        try {
+            query = resolver.query(GOOGLE_SETTINGS_CONTENT_URI,
+                    new String[] { "value" },
+                    "name=?",
+                    new String[] { "use_location_for_services" },
+                    null);
+
+            if (query != null) {
+                if (query.moveToNext()) {
+                    string = query.getString(0);
+                }
+            }
+            if (string == null) {
+                return 2;
+            }
+        } catch (RuntimeException e) {
+            Log.w("GoogleDialer", "Failed to get 'Use My Location' setting", e);
+        } finally {
+            if (query != null) {
+                query.close();
+            }
+        }
+
+        try {
+            return Integer.parseInt(string);
+        } catch (NumberFormatException e) {
+            return 2;
+        }
+    }
+
+    public static boolean isEnforceable(Context context) {
+        return context.getPackageManager().resolveActivity(
+                new Intent("com.google.android.gsf.GOOGLE_APPS_LOCATION_SETTINGS"),
+                PackageManager.MATCH_DEFAULT_ONLY) != null;
+    }
+
+    public static boolean isGoogleLocationServicesEnabled(Context context) {
+        return !isEnforceable(context) || getUseLocationForServices(context) == 1;
+    }
+
+    public static boolean isSystemLocationSettingEnabled(Context context) {
+        try {
+            int locationMode = Settings.Secure.getInt(
+                    context.getContentResolver(), "location_mode");
+            if (locationMode != 0) {
+                return true;
+            } else {
+                return false;
+            }
+        } catch (Settings.SettingNotFoundException e) {
+            Log.w("GoogleDialer", "Failed to get System Location setting", e);
+            return false;
+        }
+    }
+}
diff --git a/src/com/google/android/dialer/util/HelpUrl.java b/src/com/google/android/dialer/util/HelpUrl.java
new file mode 100644
index 0000000..50d3651
--- /dev/null
+++ b/src/com/google/android/dialer/util/HelpUrl.java
@@ -0,0 +1,55 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.util;
+
+import android.content.Context;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.text.TextUtils;
+import android.util.Log;
+
+public class HelpUrl {
+    public static Uri getHelpUrl(Context context, String fromWhere) {
+        if (TextUtils.isEmpty(fromWhere)) {
+            throw new IllegalArgumentException("getHelpUrl(): fromWhere must be non-empty");
+        }
+        Uri.Builder uri = Uri.parse("http://support.google.com/mobile").buildUpon();
+        uri.appendQueryParameter("p", fromWhere);
+        try {
+            uri.appendQueryParameter("version",
+                    String.valueOf(context.getPackageManager().getPackageInfo(
+                    ((PackageItemInfo)context.getApplicationInfo()).packageName, 0).versionCode));
+            return uri.build();
+        }
+        catch (PackageManager.NameNotFoundException e) {
+            Log.e("Dialer", "Error finding package " +
+                    ((PackageItemInfo)context.getApplicationInfo()).packageName);
+            return uri.build();
+        }
+    }
+
+    public static Uri getPhoneAccountSettingUri() {
+        return Uri.parse("https://www.google.com/settings/phone");
+    }
+}
diff --git a/src/com/google/android/dialer/util/HttpFetcher.java b/src/com/google/android/dialer/util/HttpFetcher.java
new file mode 100644
index 0000000..a605c2c
--- /dev/null
+++ b/src/com/google/android/dialer/util/HttpFetcher.java
@@ -0,0 +1,164 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.util;
+
+import com.android.incallui.Log;
+import com.android.services.telephony.common.MoreStrings;
+import com.google.android.common.http.UrlRules;
+import com.google.android.dialer.util.AuthException;
+import com.google.common.base.Preconditions;
+import com.google.common.io.Closeables;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.SystemClock;
+import android.util.Pair;
+
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.List;
+
+public class HttpFetcher {
+    private static final String TAG = HttpFetcher.class.getSimpleName();
+
+    private static void addHeaders(HttpURLConnection connection, List<Pair<String, String>> list) {
+        if (list != null) {
+            for (Pair<String, String> pair : list) {
+                connection.setRequestProperty(pair.first, pair.second);
+            }
+        }
+    }
+
+    // TODO: Check logic.
+    public static byte[] getRequestAsByteArray(Context context, String url,
+            List<Pair<String, String>> list) throws IOException, AuthException {
+        Preconditions.checkNotNull(url);
+        String rewrittenUrl = reWriteUrl(context, url);
+
+        if (rewrittenUrl == null) {
+            if (Log.DEBUG) {
+                Log.d(TAG, "url " + obfuscateUrl(url) + " is blocked.  Ignoring request.");
+            }
+            return null;
+        } else {
+            if (!rewrittenUrl.equals(url) && Log.DEBUG) {
+                Log.d(TAG, "Original url: " + obfuscateUrl(url) +
+                        ", after re-write: " + obfuscateUrl(rewrittenUrl));
+            }
+            if (Log.DEBUG) {
+                Log.d(TAG, "fetching " + obfuscateUrl(rewrittenUrl));
+            }
+
+            byte[] byteArray = null;
+            HttpURLConnection connection = null;
+            InputStream inputStream = null;
+            boolean failed = false;
+            long uptimeMillis = SystemClock.uptimeMillis();;
+            int responseCode = 0;
+            ByteArrayOutputStream byteArrayOutputStream = null;
+
+            try {
+                connection = (HttpURLConnection)new URL(rewrittenUrl).openConnection();
+                addHeaders(connection, list);
+                responseCode = connection.getResponseCode();
+                Log.d(TAG, "response code: " + responseCode);
+                int n = responseCode / 100;
+                if (n == 2) {
+                    inputStream = connection.getInputStream();
+                    byteArrayOutputStream = new ByteArrayOutputStream();
+                    byte[] array = new byte[1024];
+                    while (true) {
+                        int read = inputStream.read(array);
+                        if (read == -1) {
+                            break;
+                        }
+                        byteArrayOutputStream.write(array, 0, read);
+                    }
+                } else {
+                    failed = true;
+                }
+            } finally {
+                Closeables.closeQuietly(inputStream);
+                if (connection != null) {
+                    connection.disconnect();
+                }
+            }
+
+            if (failed) {
+                handleBadResponse(rewrittenUrl, byteArrayOutputStream.toByteArray());
+                if (responseCode == 401) {
+                    throw new AuthException("Auth error");
+                }
+                return null;
+            } else {
+                byteArray = byteArrayOutputStream.toByteArray();
+                Log.d(TAG, "received " + byteArray.length + " bytes");
+                Log.d(TAG, "fetch took " + (SystemClock.uptimeMillis() - uptimeMillis) + " ms");
+                return byteArray;
+            }
+        }
+    }
+
+    public static String getRequestAsString(Context context, String request,
+            List<Pair<String, String>> list) throws IOException, AuthException {
+        byte[] response = getRequestAsByteArray(context, request, list);
+        if (response == null) {
+            return null;
+        }
+        String responseStr = new String(response);
+        Log.d(TAG, "response body: ");
+        Log.d(TAG, responseStr);
+        return responseStr;
+    }
+
+    private static void handleBadResponse(String url, byte[] response) {
+        Log.w(TAG, "Got bad response code from url: " + url);
+        Log.w(TAG, new String(response));
+    }
+
+    private static String obfuscateUrl(String url) {
+        Uri uri = Uri.parse(url);
+        Uri.Builder builder = new Uri.Builder().scheme(uri.getScheme())
+                .authority(uri.getAuthority()).path(uri.getPath());
+        for (String param : uri.getQueryParameterNames()) {
+            if ("access_token".equals(param)) {
+                builder.appendQueryParameter(param, "token");
+            } else {
+                String queryParam = uri.getQueryParameter(param);
+                if ("id".equals(param)) {
+                    builder.appendQueryParameter(param, MoreStrings.toSafeString(queryParam));
+                } else {
+                    builder.appendQueryParameter(param, queryParam);
+                }
+            }
+        }
+        return builder.toString();
+    }
+
+    private static String reWriteUrl(Context context, String url) {
+        return UrlRules.getRules(context.getContentResolver()).matchRule(url).apply(url);
+    }
+}
diff --git a/src/com/google/android/dialer/util/JsonUtil.java b/src/com/google/android/dialer/util/JsonUtil.java
new file mode 100644
index 0000000..399691c
--- /dev/null
+++ b/src/com/google/android/dialer/util/JsonUtil.java
@@ -0,0 +1,36 @@
+/*
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+/*
+ * This is a reverse-engineered implementation of com.google.android.Dialer.
+ * There is no guarantee that this implementation will work correctly or even
+ * work at all. Use at your own risk.
+ */
+
+package com.google.android.dialer.util;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+public class JsonUtil {
+    public static JSONArray newJsonArray(JSONObject... json) {
+        JSONArray array = new JSONArray();
+        for (int length = json.length, i = 0; i < length; i++) {
+            array.put(json[i]);
+        }
+        return array;
+    }
+}
diff --git a/src/com/google/android/gsf/Gservices.java b/src/com/google/android/gsf/Gservices.java
new file mode 100644
index 0000000..77e0dcb
--- /dev/null
+++ b/src/com/google/android/gsf/Gservices.java
@@ -0,0 +1,237 @@
+/*
+  * Copyright (C) 2009 The Android Open Source Project
+  * Copyright (C) 2013 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+
+package com.google.android.gsf;
+
+import android.content.ContentResolver;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+import java.util.TreeMap;
+
+/**
+  * Gservices provides access to a key-value store that is can be
+  * updated remote (by the google checkin service).
+  */
+public class Gservices {
+    public static final String TAG = "Gservices";
+
+    public final static Uri CONTENT_URI =
+        Uri.parse("content://com.google.android.gsf.gservices");
+    public final static Uri CONTENT_PREFIX_URI =
+        Uri.parse("content://com.google.android.gsf.gservices/prefix");
+
+    public static final Pattern TRUE_PATTERN =
+        Pattern.compile("^(1|true|t|on|yes|y)$", Pattern.CASE_INSENSITIVE);
+    public static final Pattern FALSE_PATTERN =
+        Pattern.compile("^(0|false|f|off|no|n)$", Pattern.CASE_INSENSITIVE);
+
+    private static HashMap<String, String> sCache;
+    private static Object sVersionToken;
+    private static String[] sPreloadedPrefixes = new String[0];
+
+    public static synchronized void bulkCacheByPrefix(
+            ContentResolver resolver, String... prefixes) {
+        Map<String, String> stringsByPrefix = getStringsByPrefix(resolver, prefixes);
+        ensureCacheInitializedLocked(resolver);
+        sPreloadedPrefixes = prefixes;
+        for (Map.Entry<String, String> entry : stringsByPrefix.entrySet()) {
+            sCache.put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    private static void ensureCacheInitializedLocked(final ContentResolver cr) {
+        if (sCache == null) {
+            sCache = new HashMap<String, String>();
+            sVersionToken = new Object();
+
+            // Create a thread to host a Handler for ContentObserver callbacks.
+            // The callback will clear the cache to force the resolver to be consulted
+            // on future gets. The version is also updated.
+            new Thread(TAG) {
+                public void run() {
+                    Looper.prepare();
+                    cr.registerContentObserver(CONTENT_URI, true,
+                        new ContentObserver(new Handler(Looper.myLooper())) {
+                            public void onChange(boolean selfChange) {
+                                synchronized (Gservices.class) {
+                                    sCache.clear();
+                                    sVersionToken = new Object();
+                                    if (sPreloadedPrefixes.length > 0) {
+                                        bulkCacheByPrefix(cr, sPreloadedPrefixes);
+                                    }
+                                }
+                            } });
+                    Looper.loop();
+                }
+            }.start();
+        }
+    }
+
+    /**
+      * Look up a key in the database.
+      * @param cr to access the database with
+      * @param key to look up in the table
+      * @param defValue the value to return if the value from the database is null
+      * @return the corresponding value, or defValue if not present
+      */
+    public static String getString(ContentResolver cr, String key, String defValue) {
+        final Object version;
+        synchronized (Gservices.class) {
+            ensureCacheInitializedLocked(cr);
+            version = sVersionToken;
+
+            if (sCache.containsKey(key)) {
+                String value = sCache.get(key);
+                return (value != null) ? value : defValue;
+            }
+        }
+
+        final String[] prefixes = sPreloadedPrefixes;
+        for (int length = prefixes.length, i = 0; i < length; i++) {
+            if (key.startsWith(prefixes[i])) {
+                return defValue;
+            }
+        }
+
+        Cursor cursor = cr.query(CONTENT_URI, null, null, new String[]{ key }, null);
+        if (cursor == null) return defValue;
+
+        try {
+            if (!cursor.moveToFirst()) {
+                sCache.put(key, null);
+                return defValue;
+            }
+            String value = cursor.getString(1);
+            synchronized (Gservices.class) {
+                // There is a chance that the version change, and thus the cache clearing,
+                // happened after the query, meaning the value we got could be stale. Don't
+                // store it in the cache in this case.
+                if (version == sVersionToken) {
+                    sCache.put(key, value);
+                }
+            }
+            return (value != null) ? value : defValue;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+    }
+
+    /**
+      * Look up a key in the database.
+      * @param cr to access the database with
+      * @param key to look up in the table
+      * @return the corresponding value, or null if not present
+      */
+    public static String getString(ContentResolver cr, String key) {
+        return getString(cr, key, null);
+    }
+
+    /**
+      * Look up the value for key in the database, convert it to an int
+      * using Integer.parseInt and return it. If it is null or if a
+      * NumberFormatException is caught during the conversion then
+      * return defValue.
+      */
+    public static int getInt(ContentResolver cr, String key, int defValue) {
+        String valString = getString(cr, key);
+        int value;
+        try {
+            value = valString != null ? Integer.parseInt(valString) : defValue;
+        } catch (NumberFormatException e) {
+            value = defValue;
+        }
+        return value;
+    }
+
+    /**
+      * Look up the value for key in the database, convert it to a long
+      * using Long.parseLong and return it. If it is null or if a
+      * NumberFormatException is caught during the conversion then
+      * return defValue.
+      */
+    public static long getLong(ContentResolver cr, String key, long defValue) {
+        String valString = getString(cr, key);
+        long value;
+        try {
+            value = valString != null ? Long.parseLong(valString) : defValue;
+        } catch (NumberFormatException e) {
+            value = defValue;
+        }
+        return value;
+    }
+
+    public static boolean getBoolean(ContentResolver cr, String key, boolean defValue) {
+        String valString = getString(cr, key);
+        if (valString == null || valString.equals("")) {
+            return defValue;
+        } else if (TRUE_PATTERN.matcher(valString).matches()) {
+            return true;
+        } else if (FALSE_PATTERN.matcher(valString).matches()) {
+            return false;
+        } else {
+            // Log a possible app bug
+            Log.w(TAG, "attempt to read gservices key " + key + " (value \"" +
+                  valString + "\") as boolean");
+            return defValue;
+        }
+    }
+
+    /**
+      * Look up values for all keys beginning with any of the given prefixes.
+      *
+      * @return a Map<String, String> of the matching key-value pairs.
+      */
+    public static Map<String, String> getStringsByPrefix(ContentResolver cr,
+                                                          String... prefixes) {
+        Cursor c = cr.query(CONTENT_PREFIX_URI, null, null, prefixes, null);
+        TreeMap<String, String> out = new TreeMap<String, String>();
+        if (c == null) return out;
+
+        try {
+            while (c.moveToNext()) {
+                out.put(c.getString(0), c.getString(1));
+            }
+        } finally {
+            c.close();
+        }
+        return out;
+    }
+
+    /**
+      * Returns a token that represents the current version of the data within gservices
+      * @param cr the ContentResolver that Gservices should use to fill its cache
+      * @return an Object that represents the current version of the Gservices values.
+      */
+    public static Object getVersionToken(ContentResolver cr) {
+        synchronized (Gservices.class) {
+            // Even though we don't need the cache itself, we need the cache version, so we make
+            // that the cache has been initialized before we return its version.
+            ensureCacheInitializedLocked(cr);
+            return sVersionToken;
+        }
+    }
+}
-- 
1.8.5.2


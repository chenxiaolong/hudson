From a5a55b117544df9bc576d187f5040f8ad31e3cce Mon Sep 17 00:00:00 2001
From: Xiao-Long Chen <chenxiaolong@cxl.epac.to>
Date: Fri, 31 Jan 2014 22:41:09 -0500
Subject: [PATCH] Dialer: Add support for forward and reverse lookups

Change-Id: I848db0bbbe6a648064d1eace4993814a16aa9fa0
---
 Android.mk                                         |   8 +-
 AndroidManifest.xml                                |  22 +
 assets/contacts_extensions.properties              |   1 +
 proguard.flags                                     |   5 +
 .../ic_places_picture_180_holo_light.png           | Bin 0 -> 698 bytes
 res/drawable-hdpi/ic_places_picture_holo_light.png | Bin 0 -> 424 bytes
 .../ic_places_picture_180_holo_light.png           | Bin 0 -> 1140 bytes
 .../ic_places_picture_holo_light.png               | Bin 0 -> 632 bytes
 .../ic_places_picture_180_holo_light.png           | Bin 0 -> 1171 bytes
 .../ic_places_picture_holo_light.png               | Bin 0 -> 636 bytes
 res/values/strings.xml                             |   3 +
 .../dialer/database/DialerDatabaseHelper.java      |  99 +++-
 .../DialerExtendedPhoneDirectoriesManager.java     |  58 +++
 src/com/android/dialer/lookup/DialerProvider.java  | 531 ++++++++++++++++++++
 src/com/android/dialer/lookup/ForwardLookup.java   | 118 +++++
 src/com/android/dialer/lookup/LookupSettings.java  |  96 ++++
 .../dialer/lookup/PhoneNumberCacheContract.java    |  45 ++
 .../dialer/lookup/PhoneNumberCacheProvider.java    | 467 +++++++++++++++++
 src/com/android/dialer/lookup/ReverseLookup.java   | 419 ++++++++++++++++
 .../android/dialer/lookup/google/GoogleAuth.java   | 223 +++++++++
 .../dialer/lookup/google/GoogleForwardLookup.java  | 314 ++++++++++++
 .../lookup/google/GoogleLookupJsonParser.java      | 550 +++++++++++++++++++++
 .../dialer/lookup/google/GoogleReverseLookup.java  | 446 +++++++++++++++++
 .../android/dialer/lookup/google/Gservices.java    | 240 +++++++++
 src/com/android/dialer/lookup/google/UrlRules.java | 232 +++++++++
 .../lookup/opencnam/OpenCnamReverseLookup.java     | 116 +++++
 .../openstreetmap/OpenStreetMapForwardLookup.java  | 177 +++++++
 .../dialer/lookup/whitepages/WhitePagesApi.java    | 220 +++++++++
 .../lookup/whitepages/WhitePagesReverseLookup.java | 100 ++++
 .../dialer/lookup/yellowpages/YellowPagesApi.java  | 231 +++++++++
 .../yellowpages/YellowPagesReverseLookup.java      | 139 ++++++
 .../dialer/lookup/zabasearch/ZabaSearchApi.java    | 163 ++++++
 .../lookup/zabasearch/ZabaSearchReverseLookup.java | 100 ++++
 .../service/CachedNumberLookupServiceImpl.java     | 322 ++++++++++++
 src/com/android/dialerbind/ObjectFactory.java      |   4 +-
 35 files changed, 5444 insertions(+), 5 deletions(-)
 create mode 100644 assets/contacts_extensions.properties
 create mode 100644 res/drawable-hdpi/ic_places_picture_180_holo_light.png
 create mode 100644 res/drawable-hdpi/ic_places_picture_holo_light.png
 create mode 100644 res/drawable-xhdpi/ic_places_picture_180_holo_light.png
 create mode 100644 res/drawable-xhdpi/ic_places_picture_holo_light.png
 create mode 100644 res/drawable-xxhdpi/ic_places_picture_180_holo_light.png
 create mode 100644 res/drawable-xxhdpi/ic_places_picture_holo_light.png
 create mode 100644 src/com/android/dialer/lookup/DialerExtendedPhoneDirectoriesManager.java
 create mode 100644 src/com/android/dialer/lookup/DialerProvider.java
 create mode 100644 src/com/android/dialer/lookup/ForwardLookup.java
 create mode 100644 src/com/android/dialer/lookup/LookupSettings.java
 create mode 100644 src/com/android/dialer/lookup/PhoneNumberCacheContract.java
 create mode 100644 src/com/android/dialer/lookup/PhoneNumberCacheProvider.java
 create mode 100644 src/com/android/dialer/lookup/ReverseLookup.java
 create mode 100644 src/com/android/dialer/lookup/google/GoogleAuth.java
 create mode 100644 src/com/android/dialer/lookup/google/GoogleForwardLookup.java
 create mode 100644 src/com/android/dialer/lookup/google/GoogleLookupJsonParser.java
 create mode 100644 src/com/android/dialer/lookup/google/GoogleReverseLookup.java
 create mode 100644 src/com/android/dialer/lookup/google/Gservices.java
 create mode 100644 src/com/android/dialer/lookup/google/UrlRules.java
 create mode 100644 src/com/android/dialer/lookup/opencnam/OpenCnamReverseLookup.java
 create mode 100644 src/com/android/dialer/lookup/openstreetmap/OpenStreetMapForwardLookup.java
 create mode 100644 src/com/android/dialer/lookup/whitepages/WhitePagesApi.java
 create mode 100644 src/com/android/dialer/lookup/whitepages/WhitePagesReverseLookup.java
 create mode 100644 src/com/android/dialer/lookup/yellowpages/YellowPagesApi.java
 create mode 100644 src/com/android/dialer/lookup/yellowpages/YellowPagesReverseLookup.java
 create mode 100644 src/com/android/dialer/lookup/zabasearch/ZabaSearchApi.java
 create mode 100644 src/com/android/dialer/lookup/zabasearch/ZabaSearchReverseLookup.java
 create mode 100644 src/com/android/dialer/service/CachedNumberLookupServiceImpl.java

diff --git a/Android.mk b/Android.mk
index 899d589..588b745 100644
--- a/Android.mk
+++ b/Android.mk
@@ -9,13 +9,18 @@ incallui_dir := ../InCallUI
 src_dirs := src $(contacts_common_dir)/src $(incallui_dir)/src
 res_dirs := res $(contacts_common_dir)/res $(incallui_dir)/res
 
+# Google Play Services resource files
+res_dirs += ../../../external/google/google_play_services/libproject/google-play-services_lib/res
+
 LOCAL_SRC_FILES := $(call all-java-files-under, $(src_dirs))
 LOCAL_RESOURCE_DIR := $(addprefix $(LOCAL_PATH)/, $(res_dirs))
+LOCAL_ASSET_DIR := $(LOCAL_PATH)/assets
 
 LOCAL_AAPT_FLAGS := \
     --auto-add-overlay \
     --extra-packages com.android.contacts.common \
-    --extra-packages com.android.incallui
+    --extra-packages com.android.incallui \
+    --extra-packages com.google.android.gms
 
 LOCAL_JAVA_LIBRARIES := telephony-common
 LOCAL_STATIC_JAVA_LIBRARIES := \
@@ -27,6 +32,7 @@ LOCAL_STATIC_JAVA_LIBRARIES := \
     android-support-v13 \
     android-support-v4 \
     android-ex-variablespeed \
+    gservices
 
 LOCAL_REQUIRED_MODULES := libvariablespeed
 
diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index e011d80..5e33587 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -52,6 +52,12 @@
      presses home. -->
     <uses-permission android:name="android.permission.STOP_APP_SWITCHES" />
 
+    <!-- Allow the Dialer to access accounts for lookup services -->
+    <uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" />
+
+    <uses-permission android:name="com.google.android.providers.gsf.permission.READ_GSERVICES" />
+    <uses-feature android:name="com.google.android.feature.GOOGLE_EXPERIENCE" android:required="true" />
+
     <application
         android:name="DialerApplication"
         android:label="@string/applicationLabel"
@@ -63,6 +69,12 @@
         <meta-data android:name="com.google.android.backup.api_key"
             android:value="AEdPqrEAAAAIBXgtCEKQ6W0PXVnW-ZVia2KmlV2AxsTw3GjAeQ" />
 
+<!--
+        <meta-data
+            android:name="com.google.android.gms.version"
+            android:value="@integer/google_play_services_version" />
+-->
+
         <!-- The entrance point for Phone UI.
              stateAlwaysHidden is set to suppress keyboard show up on
              dialpad screen. -->
@@ -305,5 +317,15 @@
             </intent-filter>
         </receiver>
 
+        <provider android:name="com.android.dialer.lookup.DialerProvider"
+                  android:authorities="com.android.dialer.provider"
+                  android:exported="false"
+                  android:multiprocess="false" />
+
+        <provider android:name="com.android.dialer.lookup.PhoneNumberCacheProvider"
+                  android:authorities="com.android.dialer.cacheprovider"
+                  android:exported="false"
+                  android:multiprocess="false" />
+
     </application>
 </manifest>
diff --git a/assets/contacts_extensions.properties b/assets/contacts_extensions.properties
new file mode 100644
index 0000000..ade11c4
--- /dev/null
+++ b/assets/contacts_extensions.properties
@@ -0,0 +1 @@
+extendedPhoneDirectories=com.android.dialer.lookup.DialerExtendedPhoneDirectoriesManager
diff --git a/proguard.flags b/proguard.flags
index 40ef035..fa3712b 100644
--- a/proguard.flags
+++ b/proguard.flags
@@ -12,4 +12,9 @@
 @com.android.dialer.NeededForReflection *;
 }
 
+# Keep DialerExtendedPhoneDirectoriesManager for assets/contacts_extensions.properties
+-keep class com.android.dialer.lookup.DialerExtendedPhoneDirectoriesManager extends * {
+  *;
+}
+
 -verbose
diff --git a/res/drawable-hdpi/ic_places_picture_180_holo_light.png b/res/drawable-hdpi/ic_places_picture_180_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..f0bbe73459344c4dafbc47fa6b15ad5e230b01b8
GIT binary patch
literal 698
zcmeAS@N?(olHy`uVBq!ia0y~yVB`Z~4xj)-?5$;$3=B+-o-U3d6}R5rx$DPdD8Lrr
z=J@gdU-`4k4YEw!&i0wB1?hE3Z}UECT)r%4v+cA=jr!8xxxWUha}+!{(8$crCu4!k
zScuF)NIO5oqPCH_{SZP4vQe$b9Eb&v?XP??*YAqV*R*~vv2K0a%{+~`_(h-ZZtR%x
z@$PK)Ck18LoYRP~_)Pd|O|_d{3P*N4RDRsC{drOA_Vn2dAOD3sy0hkU{M)`?1!>23
zAHIp~puXh%55*l>?&du&zyGs4{weMC`=q0lRd*M3zMHNbp57hBz5ndR;&%I!vsJ%K
zmQ8sC^P>jP$!BgH@|DUsVUanr;>0tV%WP7glI{jQR!qMy`}N`6zjYSYGD{HwC(@Uu
zJIBG<vfbhEvnp1pV{7~u98~892W<dY)#CYL>)r}WmBre={4D>g-s$k;=g;0$)<wtt
z{SwEs{@t$IKvOsVt^4_F&G~)rr*ob|i4~dZ=KE$B0?y5IuC?Glf6?qhK_tVItn7oY
zQ+;;a{>^U^<MQ=Y>6@=#9lOoFFFPDwQ^@JAiEKcXUSr!zOBShD{}=q);LyBS1QO|B
zmlYlm^INcRj`M<rJDeNa1h*?(crck2EDs6<EKw40|Lf}e8Olt@`;Q&>mOEKgzV<P<
Xa?2V1Oo`GKP@?p7^>bP0l+XkKCiF3c

literal 0
HcmV?d00001

diff --git a/res/drawable-hdpi/ic_places_picture_holo_light.png b/res/drawable-hdpi/ic_places_picture_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..f70e8e711155f7ee77fc2b3fc42e1e62f059720f
GIT binary patch
literal 424
zcmV;Z0ayNsP)<h;3K|Lk000e1NJLTq003YB003YJ00000$MY!U0004RNkl<ZXx{CZ
z(Q<+?5Jm3|=oF~_|F88wq(zO~K18uvDFI^#+szC!3zKkQ6AlY}!(*F+0SsUO0~o*n
z1~7mD3}65Q{1PC)*i+mfP6n)FhSJwl0bFJg_dr)qPmyAhBwMBi_|vNRrUPAt2?3h}
zp+zYGwI`HUN(<O}9xs}^9ie5FIz{9uIbXtOnq(<#mtjJ{f`qcrM}+d!fK|6P^?J`T
zHB~%D6@$~k391Mo04Q4z0qS<VD%$dVeJ?{*K`q{;ilG!~ma0e&$Z=Lh+l2`MYg5Ji
ztBT07qZd#g04)mveBWQF;&}d#9RXJXV6!E_ilYFHCxik3wpXeMZQl^eN&@uFiIuXd
z2uDvnddrR(t0Hs=+Eo987^8|Tzom+BlmOsz_U0l+6{}mTP-QpkZBdvio>LW`<5V&B
zNp3vR230isepOWHR8exYDqI-ieozHW6`d5^kSb`ZFn|I6%L_-7|9SL&qkRI9X}H1T
S^IK8?0000<MNUMnLSTYfm#kR;

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_places_picture_180_holo_light.png b/res/drawable-xhdpi/ic_places_picture_180_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..6409ab185d7ae07f5bbbe65011f317b26fd6fb22
GIT binary patch
literal 1140
zcmeAS@N?(olHy`uVBq!ia0y~yV9Wqv4xj)-e4iaB0|Se-r;B4q#jUq@Z|2={5NSv}
zmczJ7^Zoy%+O93Wn>U=8JUeXfjLBIOB)8T5Uz*zUlc{XUWX_kjJ&vz%W{}$A(9EWL
zVF9a@Nk$`x;m8eQ@J4|d7nnedX0Z$)1Ednj0IH<3mM`^}Qr^2SDX!-HskQL)pN00u
z&!5*UegEQ#)dMMBDHA4A9Dj9(=Wb{B*H4Pp{mp#Nvuo4!*qyn1biQ8xrd#plk6QD(
z?9F=jR{kv!+;jGK>4w}lmjY{FzTmo|7gs8s^LAZs?Yh~D;GjUW^o!`#5)0`w?2m07
z`CqQPWO9DqB3a*qtM6ar{Z`V8HO$fjF3(If?DhI+bT;A8q*vl4^9o+3ulrwgeA;WC
z-y!pEm_(&Ztod_h@~hUi&zBvS*G=~0|GP_X;qv~2DK+118}{v8`^B4o`EI!-{a+;=
z*txBWSM3da@~iPJ=YHn${=mJn7v8sW07m2m4%9dc4>`=~&6n2p(M4&-#F*Rmw{to7
zMzJhjli~RMiQ%mb$MoFIx9rVdJbSwB$$$6j@m5}|^gn!BQRZ*%j4esjvTdES!9_aw
z?Yx&C{O7s3SA9};-alov*XJku{%|b)>iyx<^wo@)*KGMKC{rZ3R`BmvK^?=r^PhQF
zxj&!f8^34er-$}_mHqtlvbW4$h$R*NUA&Cjs(XG?ylvu3c0RjR{E~B?E_FQL6mHOW
zY~Dqy!;R|G7CHMZwq4%+;No=CIkB#*Qx-?YZ7C|dA@$T|o!yfpORGQ6U!IuW_iA(Q
zhyO*t56@o;3Ktg4l>WNhcR$zGJ7VXJ7tQ~6;H3Lk#lt@n>H{yVKWILuZ~DPcC*MYY
zc=7Y>1lGB`=WlJVxzEBM@28jP_&hE4-_C<2g0;`zSluv_`*O$9Dy3Zb&CXi>YoGM=
zUSA5V6U`Do|FL=P-2<KVUlp4-=WG<YbM`{MEFup%Dl<TG*o*8{FAKJnm0e6&H1V6o
z+2lF?-Y<50HP}>lmC0;bP#jcy;`Y^r^Z)#K|AMVL?%3qrZo4I$NXnK{xBi{Jzsu*X
oe|62&=ld>Xen0a)zjo^v^~&hge`h5G`h$uSPgg&ebxsLQ0D^f73jhEB

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_places_picture_holo_light.png b/res/drawable-xhdpi/ic_places_picture_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..7c92a6030c376ce8947d96c278b6c6c157eee92c
GIT binary patch
literal 632
zcmeAS@N?(olHy`uVBq!ia0vp^4Is<`Bp9BB+KDqTFxh*$IEGZ*dOPcO*<u48*Zv-7
zh3)75{Ga~Sc-izVmjzbyCoQvhT%g@J)wF%OPIGQqj_k=GrT&O-MG6dz91aXj0u2l-
zSeOY9Pyes>cJo<$nXx5SlI{GbkdrA4k7^<+xI<Plfi*?k5M7?USZ%g3!<;6DfOOff
zDf0KuvMQWcXB600&8qNl`bQbBxw+gf3>_}M9H9;kl8i}<XWwG84qd>0d3G>E!1sjh
zn}5m#itV<u->CeC?ZQeUfmILA9p1>YrS-Am$tgT67V}se)?NFyY_aQMqi(C*U(7qc
z^Gk~Kt*yTyD%KazoA7jT__V*alSB5W-Voby;=84XQxEethbdY+%q4Gq`*-)rE=%PD
zUJMStWm=UpDjr%L{%E(UxN?TAeu9b0f%^9yPgXK9=$dmmoIC%FecS66nI~`0p4-@N
zU#ZKGu=ncw6B{<YvFP9Y^~n?=zl(=An{JLyIUa6p?p(g!XO>$9`$G$kh6RD2XGI<t
zTcyi(TRvg(ZOtv)R!0S$Ox$(LvpAIdzKoTbjQAy+juYFSimdv%>!*R-ud~7zuPgDt
zxcz#KkLVrWwGq*iFPA)zD}DMdA>?{T&dM#TxXnG;<<GdNdh^Ok_q~q#_-s*FjLN=g
z*88{^zS`%$INi>0;n4!&8wX|_niIgv5+UWVyuf8wfA&%PH8a<Uwk!4Dxwy`<WQ+1H
z4ZiKyx?;s_zfP_=<al!<-+iW4kXZh+RqOCty_bJZx}7)wYdt^a%s<X|+DDmZ-AM2P
OB`Hr=KbLh*2~7aMkP%A&

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_places_picture_180_holo_light.png b/res/drawable-xxhdpi/ic_places_picture_180_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..97b98225783cd4741d87f6365aa2a00756cc5e7a
GIT binary patch
literal 1171
zcmeAS@N?(olHy`uVBq!ia0y~yV3Gl04xj+TjHwz67#LWhJY5_^DsH{Kb2h8RK&0W~
zHVw6oT^aZP@BPJR+%4EHn0|5Jfdb8xx**H+>OiMI9lQ6`??0F;zm1_#f$vD8g#h~_
z2bm6LAP2#M2oqG`AcJPY5k{C<FoV$*G+IC{gDL1>MzA0b!cb7yfaFN9YOr&W^kFD?
zM9}RR3JAL$!*d<XdD-v2En9#0-Nlc`Phv<@#qT$mko>8@_if$E6xq*WeZOV;uB*yy
zpUnUE2}*cjcndR91y(-gYTNkY<&+vvb$Hxk`W|b<G&60DIcSjoaL4(F6|sj3twq<q
z{rtb~Uh`z;{h|nWB3Q5_h8bZ$CP%GHkm#Q0cXE135hA1zESMG)?}0c#(=`H4i}D~s
z;j;4dx?OFL7jhq;UTpD>O`W|?8={+tD9Hh<X;xnW4V1VYUpD=gEh;N|u)PVC?1%_Z
zsGHY^Lml;FQBx`B@wZ=2ES<mZVa1C>AD_zf?LK(2@je$McVMJem{$>T6%AJNfHP}n
zQ=(3l)lzZ2y>IH;=ggJ)u@-C_wm?DX28IxZ0^&1KGnYwu_2q+U@6PH=?@&B7_w|-e
QU}3}H>FVdQ&MBb@0B}N`{{R30

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_places_picture_holo_light.png b/res/drawable-xxhdpi/ic_places_picture_holo_light.png
new file mode 100644
index 0000000000000000000000000000000000000000..43029bd81bf60c5a9fe13432d0955531f842c9bb
GIT binary patch
literal 636
zcmeAS@N?(olHy`uVBq!ia0vp^2SAtuNHCOdH@?llz~t=d;uunK>+NmFq9zA{)<h{b
zrh{6O@BB~N>7u2#rN_Z)wSi8QprpWx`%|xKeK2G;@t=A=<8HqN6UYoQK*DW?^1rIQ
zyOd_iPdNUN<5J8s_9=P_5B?~B_E+S!=$z6lfnw-3wgTl#tfs3k-?eRHjG6Vn_o_+e
z>d?DkbE8ch{Brj!_-(dr!snH1r>)eh=IXq&j*Hz8q&;Wn)DIK4-U^MiQ23nu%(_!U
z_s`{2<}X*XZkwDBzkKFpgBC>H1h1CeK^_Z29$h!*t^2X+n7*N*yOn(H`kIRmR=VUZ
z7216%V&bx!F9d(AN}U#x6u^DRkq2b_Y;V<Rd>%)o_L^+p)aANNXz9+|o~jnyj6kUa
z$AUW*yDw-mPW4xvBfsy~av{%n{e}O|%RJi8d(o>mtD-^XZOEev>!~mF7FzvS^Jwo{
zv-WSvAKQH_Ti^U~d@?aoV{hm=Cy*r@x<ZtsCVAc1zq-QUhQvIt8H=ayxijC(BW-WE
zQEf&Ti<fHGqjzCGcW0YQe5_lRrstp~XmaC$4hu-{5}{_ft^TT$b}X-YY8Cdgx6Jmc
zW>Dwn7a@;+uUzTkqIED5lmwOtW&5el*>?R-p4P<3tNTKnth3+OtX2$WDoKC0c~8fg
zyH*NQE2^`!3^V2~5ds+t2OGYIIHf#oh$;=7ot1x9KKb#Uon?>u%R%y<u6{1-oD!M<
Dj9u?@

literal 0
HcmV?d00001

diff --git a/res/values/strings.xml b/res/values/strings.xml
index 55cdea4..d4fbfbf 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -635,4 +635,7 @@
 
     <!-- Content description for dismiss button on badge. [CHAR LIMIT=NONE] -->
     <string name="description_dismiss">Dismiss</string>
+
+    <!-- Forward lookup -->
+    <string name="nearby_places">Nearby places</string>
 </resources>
diff --git a/src/com/android/dialer/database/DialerDatabaseHelper.java b/src/com/android/dialer/database/DialerDatabaseHelper.java
index b9e4b9a..ef6b221 100644
--- a/src/com/android/dialer/database/DialerDatabaseHelper.java
+++ b/src/com/android/dialer/database/DialerDatabaseHelper.java
@@ -65,6 +65,7 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
     private static final Object mLock = new Object();
     private static final AtomicBoolean sInUpdate = new AtomicBoolean(false);
     private final Context mContext;
+    private final String[] mArgs1 = new String[1];
 
     /**
      * SmartDial DB version ranges:
@@ -72,7 +73,7 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
      *   0-98   KeyLimePie
      * </pre>
      */
-    public static final int DATABASE_VERSION = 4;
+    public static final int DATABASE_VERSION = 70004;
     public static final String DATABASE_NAME = "dialer.db";
 
     /**
@@ -91,6 +92,8 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
         static final String PREFIX_TABLE = "prefix_table";
         /** Database properties for internal use */
         static final String PROPERTIES = "properties";
+        /** Cached contacts for Google number lookup */
+        static final String CACHED_CONTACTS = "cached_number_contacts";
     }
 
     public interface SmartDialDbColumns {
@@ -120,6 +123,21 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
         String PROPERTY_VALUE = "property_value";
     }
 
+    public interface CachedContactsColumns {
+        static final String NORMALIZED_NUMBER = "normalized_number";
+        static final String NUMBER = "number";
+        static final String PHONE_TYPE = "phone_type";
+        static final String PHONE_LABEL = "phone_label";
+        static final String HAS_PHOTO = "has_photo";
+        static final String HAS_THUMBNAIL = "has_thumbnail";
+        static final String PHOTO_URI = "photo_uri";
+        static final String TIME_LAST_UPDATED = "time_last_updated";
+        static final String SOURCE_NAME = "source_name";
+        static final String SOURCE_TYPE = "source_type";
+        static final String SOURCE_ID = "source_id";
+        static final String LOOKUP_KEY = "lookup_key";
+    }
+
     /** Query options for querying the contact database.*/
     public static interface PhoneQuery {
        static final Uri URI = Phone.CONTENT_URI.buildUpon().
@@ -182,6 +200,35 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
                 ContactsContract.DeletedContacts.CONTACT_DELETED_TIMESTAMP + " > ?";
     }
 
+    /** Query options for querying the cache database */
+    public interface CachedNumberQuery {
+        static final String[] PROJECTION = new String[] {
+            SmartDialDbColumns.DISPLAY_NAME_PRIMARY, // 0
+            CachedContactsColumns.HAS_PHOTO,         // 1
+            CachedContactsColumns.HAS_THUMBNAIL,     // 2
+            CachedContactsColumns.PHOTO_URI,         // 3
+            CachedContactsColumns.NUMBER,            // 4
+            CachedContactsColumns.PHONE_TYPE,        // 5
+            CachedContactsColumns.PHONE_LABEL,       // 6
+            CachedContactsColumns.SOURCE_NAME,       // 7
+            CachedContactsColumns.SOURCE_TYPE,       // 8
+            CachedContactsColumns.SOURCE_ID,         // 9
+            CachedContactsColumns.LOOKUP_KEY         // 10
+        };
+
+        static final int CACHE_DISPLAY_NAME = 0;
+        static final int CACHE_HAS_PHOTO = 1;
+        static final int CACHE_HAS_THUMBNAIL = 2;
+        static final int CACHE_PHOTO_URI = 3;
+        static final int CACHE_NUMBER = 4;
+        static final int CACHE_PHONE_TYPE = 5;
+        static final int CACHE_PHONE_LABEL = 6;
+        static final int CACHE_SOURCE_NAME = 7;
+        static final int CACHE_SOURCE_TYPE = 8;
+        static final int CACHE_SOURCE_ID = 9;
+        static final int CACHE_LOOKUP_KEY = 10;
+    }
+
     /**
      * Gets the sorting order for the smartdial table. This computes a SQL "ORDER BY" argument by
      * composing contact status and recent contact details together.
@@ -371,6 +418,26 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
                 PropertiesColumns.PROPERTY_VALUE + " TEXT " +
                 ");");
 
+        db.execSQL("CREATE TABLE " + Tables.CACHED_CONTACTS + " (" +
+                CachedContactsColumns.NORMALIZED_NUMBER + " TEXT PRIMARY KEY NOT NULL, " +
+                CachedContactsColumns.NUMBER + " TEXT NOT NULL, " +
+                CachedContactsColumns.PHONE_TYPE + " INTEGER DEFAULT 0, " +
+                CachedContactsColumns.PHONE_LABEL + " TEXT,display_name TEXT, " +
+                CachedContactsColumns.HAS_PHOTO + " INTEGER DEFAULT 0, " +
+                CachedContactsColumns.HAS_THUMBNAIL + " INTEGER DEFAULT 0, " +
+                CachedContactsColumns.PHOTO_URI + " TEXT, " +
+                CachedContactsColumns.TIME_LAST_UPDATED + " LONG NOT NULL, " +
+                CachedContactsColumns.SOURCE_NAME + " TEXT, " +
+                CachedContactsColumns.SOURCE_TYPE + " INTEGER DEFAULT 0, " +
+                CachedContactsColumns.SOURCE_ID + " TEXT, " +
+                CachedContactsColumns.LOOKUP_KEY + " TEXT" +
+        ");");
+
+        db.execSQL("CREATE INDEX " + "cached_number_index" +
+                " ON " + Tables.CACHED_CONTACTS + " (" +
+                CachedContactsColumns.NORMALIZED_NUMBER +
+        ");");
+
         setProperty(db, DATABASE_VERSION_PROPERTY, String.valueOf(DATABASE_VERSION));
         resetSmartDialLastUpdatedTime();
     }
@@ -379,6 +446,7 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
         db.execSQL("DROP TABLE IF EXISTS " + Tables.PREFIX_TABLE);
         db.execSQL("DROP TABLE IF EXISTS " + Tables.SMARTDIAL_TABLE);
         db.execSQL("DROP TABLE IF EXISTS " + Tables.PROPERTIES);
+        db.execSQL("DROP TABLE IF EXISTS " + Tables.CACHED_CONTACTS);
     }
 
     @Override
@@ -394,7 +462,10 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
             Log.e(TAG, "Malformed database version..recreating database");
         }
 
-        if (oldVersion < 4) {
+        int curVer = 4;
+        int base = 70000;
+        if (oldVersion <= curVer
+                || (oldVersion >= base && oldVersion < base + curVer)) {
             setupTables(db);
             return;
         }
@@ -972,4 +1043,28 @@ public class DialerDatabaseHelper extends SQLiteOpenHelper {
         }
         return result;
     }
+
+    // Cached contacts database
+
+    public void prune() {
+        prune(2592000000L); // 30 days: 30 * 24 * 60 * 60 * 1000
+    }
+
+    public void prune(long timestamp) {
+        mArgs1[0] = Long.toString(System.currentTimeMillis() - timestamp);
+        getWritableDatabase().execSQL(
+                "DELETE FROM " + Tables.CACHED_CONTACTS + " WHERE " +
+                CachedContactsColumns.TIME_LAST_UPDATED + "<?", mArgs1);
+    }
+
+    public void purgeAll() {
+        getWritableDatabase().execSQL("DELETE FROM " + Tables.CACHED_CONTACTS);
+    }
+
+    public void purgeSource(int type) {
+        mArgs1[0] = Integer.toString(type);
+        getWritableDatabase().execSQL(
+                "DELETE FROM " + Tables.CACHED_CONTACTS + " WHERE " +
+                CachedContactsColumns.SOURCE_TYPE + "=?", mArgs1);
+    }
 }
diff --git a/src/com/android/dialer/lookup/DialerExtendedPhoneDirectoriesManager.java b/src/com/android/dialer/lookup/DialerExtendedPhoneDirectoriesManager.java
new file mode 100644
index 0000000..dee2a2b
--- /dev/null
+++ b/src/com/android/dialer/lookup/DialerExtendedPhoneDirectoriesManager.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup;
+
+import com.android.dialer.R;
+
+import com.android.contacts.common.extensions.ExtendedPhoneDirectoriesManager;
+import com.android.contacts.common.list.DirectoryPartition;
+
+import android.content.Context;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class DialerExtendedPhoneDirectoriesManager
+        implements ExtendedPhoneDirectoriesManager {
+    public static final String TAG =
+            DialerExtendedPhoneDirectoriesManager.class.getSimpleName();
+
+    /**
+     * Return a list of extended directories to add. May return null if no directories are to be
+     * added.
+     */
+    @Override
+    public List<DirectoryPartition> getExtendedDirectories(Context context) {
+        ArrayList<DirectoryPartition> list = new ArrayList<DirectoryPartition>();
+
+        if (LookupSettings.isForwardLookupEnabled(context)) {
+            DirectoryPartition dp = new DirectoryPartition(false, true);
+            dp.setContentUri(DialerProvider.FORWARD_LOOKUP_URI.toString());
+            dp.setLabel(context.getString(R.string.nearby_places));
+            dp.setPriorityDirectory(false);
+            dp.setPhotoSupported(true);
+            dp.setDisplayNumber(false);
+            dp.setResultLimit(3);
+            list.add(dp);
+        } else {
+            Log.i(TAG, "Forward lookup is disabled");
+        }
+
+        return list;
+    }
+}
diff --git a/src/com/android/dialer/lookup/DialerProvider.java b/src/com/android/dialer/lookup/DialerProvider.java
new file mode 100644
index 0000000..119f711
--- /dev/null
+++ b/src/com/android/dialer/lookup/DialerProvider.java
@@ -0,0 +1,531 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup;
+
+import com.android.dialer.lookup.ForwardLookup.ForwardLookupDetails;
+import com.android.dialer.R;
+
+import android.content.ContentProvider;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.StructuredName;
+import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
+import android.provider.ContactsContract.CommonDataKinds.Website;
+import android.provider.ContactsContract.Contacts;
+import android.provider.ContactsContract.Directory;
+import android.provider.ContactsContract.DisplayNameSources;
+import android.provider.Settings;
+import android.util.Log;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.TimeUnit;
+import java.util.LinkedList;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class DialerProvider extends ContentProvider {
+    private static final String TAG = DialerProvider.class.getSimpleName();
+
+    private static final boolean DEBUG_SHOW_DISTANCE = false;
+    private static final boolean ALLOW_CONTACT_EXPORT = true;
+
+    public static final Uri AUTHORITY_URI =
+            Uri.parse("content://com.android.dialer.provider");
+    public static final Uri FORWARD_LOOKUP_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "forwardLookup");
+
+    private static final Looper mLooper = new Handler().getLooper();
+    private static final UriMatcher sURIMatcher = new UriMatcher(-1);
+    private final LinkedList<FutureTask> mActiveTasks =
+            new LinkedList<FutureTask>();
+
+    static {
+        sURIMatcher.addURI("com.android.dialer.provider", "forwardLookup/*", 0);
+    }
+
+    private class FutureCallable<T> implements Callable<T> {
+        private final Callable<T> mCallable;
+        private volatile FutureTask<T> mFuture;
+
+        public FutureCallable(Callable<T> callable) {
+            mFuture = null;
+            mCallable = callable;
+        }
+
+        public T call() throws Exception {
+            Log.v(TAG, "Future called for " + Thread.currentThread().getName());
+
+            T result = mCallable.call();
+            if (mFuture == null) {
+                return result;
+            }
+
+            synchronized (mActiveTasks) {
+                mActiveTasks.remove(mFuture);
+            }
+
+            mFuture = null;
+            return result;
+        }
+
+        public void setFuture(FutureTask<T> future) {
+            mFuture = future;
+        }
+    }
+
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, final String[] projection, String selection,
+            String[] selectionArgs, String sortOrder) {
+        Log.v(TAG, "query: " + uri);
+
+        int match = sURIMatcher.match(uri);
+
+        switch (match) {
+        case 0:
+            Context context = getContext();
+            if (!isLocationEnabled()) {
+                Log.v(TAG, "Location settings is disabled, ignoring query.");
+                return null;
+            }
+
+            final Location lastLocation = getLastLocation();
+            if (lastLocation == null) {
+                Log.v(TAG, "No location available, ignoring query.");
+                return null;
+            }
+
+            final String filter = Uri.encode(uri.getLastPathSegment());
+            String limit = uri.getQueryParameter("limit");
+
+            int maxResults = -1;
+
+            try {
+                if (limit != null) {
+                    maxResults = Integer.parseInt(limit);
+                }
+            } catch (NumberFormatException e) {
+                Log.e(TAG, "query: invalid limit parameter: '" + limit + "'");
+            }
+
+            final int finalMaxResults = maxResults;
+
+            return execute(new Callable<Cursor>() {
+                @Override
+                public Cursor call() {
+                    return handleFilter(projection, filter, finalMaxResults,
+                            lastLocation);
+                }
+            }, "FilterThread", 10000, TimeUnit.MILLISECONDS);
+        }
+
+        return null;
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection,
+            String[] selectionArgs) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        int match = sURIMatcher.match(uri);
+
+        switch (match) {
+        case 0:
+            return Contacts.CONTENT_ITEM_TYPE;
+
+        default:
+            return null;
+        }
+    }
+
+    /**
+     * Check if the location services is on.
+     *
+     * @return Whether location services are enabled
+     */
+    private boolean isLocationEnabled() {
+        try {
+            int mode = Settings.Secure.getInt(
+                getContext().getContentResolver(),
+                Settings.Secure.LOCATION_MODE);
+
+            return mode != Settings.Secure.LOCATION_MODE_OFF;
+        } catch (Settings.SettingNotFoundException e) {
+            Log.e(TAG, "Failed to get location mode", e);
+            return false;
+        }
+    }
+
+    /**
+     * Get location from last location query.
+     *
+     * @return The last location
+     */
+    private Location getLastLocation() {
+        LocationManager locationManager = (LocationManager)
+                getContext().getSystemService(Context.LOCATION_SERVICE);
+
+        // ACCURACY_COARSE maybe?
+        locationManager.requestSingleUpdate(new Criteria(),
+                new LocationListener() {
+            @Override
+            public void onLocationChanged(Location location) {
+                Log.v(TAG, "onLocationChanged: " + location);
+            }
+
+            @Override
+            public void onProviderDisabled(String provider) {
+                Log.v(TAG, "onProviderDisabled: " + provider);
+            }
+
+            @Override
+            public void onProviderEnabled(String provider) {
+                Log.v(TAG, "onProviderEnabled: " + provider);
+            }
+
+            @Override
+            public void onStatusChanged(String provider, int status, Bundle extras) {
+                Log.v(TAG, "onStatusChanged: "
+                        + provider + ", " + status + ", " + extras);
+            }
+        }, DialerProvider.mLooper);
+
+        return locationManager.getLastLocation();
+    }
+
+    /**
+     * Process filter/query and perform the lookup.
+     *
+     * @param projection Columns to include in query
+     * @param filter String to lookup
+     * @param maxResults Maximum number of results
+     * @param lastLocation Coordinates of last location query
+     * @return Cursor for the results
+     */
+    private Cursor handleFilter(String[] projection, String filter,
+            int maxResults, Location lastLocation) {
+        Log.v(TAG, "handleFilter(" + filter + ")");
+
+        if (filter != null) {
+            try {
+                filter = URLDecoder.decode(filter, "UTF-8");
+            } catch (UnsupportedEncodingException e) {
+            }
+
+            ForwardLookup fl = ForwardLookup.getInstance(getContext());
+            ForwardLookupDetails[] results =
+                    fl.lookup(getContext(), filter, lastLocation);
+
+            if (results == null || results.length == 0) {
+                Log.v(TAG, "handleFilter(" + filter + "): No results");
+                return null;
+            }
+
+            Cursor cur = null;
+            try {
+                cur = buildResultCursor(projection, results, maxResults);
+
+                Log.v(TAG, "handleFilter(" + filter + "): "
+                        + cur.getCount() + " matches");
+            } catch (JSONException e) {
+                Log.e(TAG, "JSON failure", e);
+            }
+
+            return cur;
+        }
+
+        return null;
+    }
+
+    /**
+     * Query results.
+     *
+     * @param projection Columns to include in query
+     * @param results Results for the forward lookup
+     * @param maxResults Maximum number of rows/results to add to cursor
+     * @return Cursor for forward lookup query results
+     */
+    private Cursor buildResultCursor(String[] projection,
+            ForwardLookupDetails[] results, int maxResults)
+            throws JSONException {
+        int indexDisplayName = -1;
+        int indexPhoneLabel = -1;
+        int indexPhoneNumber = -1;
+        int indexPhoneType = -1;
+        int indexHasPhoneNumber = -1;
+        int indexId = -1;
+        int indexContactId = -1;
+        int indexPhotoUri = -1;
+        int indexPhotoThumbUri = -1;
+        int indexLookupKey = -1;
+
+        for (int i = 0; i < projection.length; i++) {
+            String column = projection[i]; // v4
+
+            if (column.equals(Contacts.DISPLAY_NAME)) {
+                indexDisplayName = i;
+            } else if (column.equals(Phone.LABEL)) {
+                indexPhoneLabel = i;
+            } else if (column.equals(Contacts.HAS_PHONE_NUMBER)) {
+                indexHasPhoneNumber = i;
+            } else if (column.equals(Contacts._ID)) {
+                indexId = i;
+            } else if (column.equals(Phone.CONTACT_ID)) {
+                indexContactId = i;
+            } else if (column.equals(Phone.NUMBER)) {
+                indexPhoneNumber = i;
+            } else if (column.equals(Phone.TYPE)) {
+                indexPhoneType = i;
+            } else if (column.equals(Contacts.PHOTO_URI)) {
+                indexPhotoUri = i;
+            } else if (column.equals(Contacts.PHOTO_THUMBNAIL_URI)) {
+                indexPhotoThumbUri = i;
+            } else if (column.equals(Contacts.LOOKUP_KEY)) {
+                indexLookupKey = i;
+            }
+        }
+
+        int exportSupport;
+        if (ALLOW_CONTACT_EXPORT) {
+            exportSupport = Directory.EXPORT_SUPPORT_ANY_ACCOUNT;
+        } else {
+            exportSupport = Directory.EXPORT_SUPPORT_NONE;
+        }
+
+        MatrixCursor cursor = new MatrixCursor(projection);
+
+        int id = 1;
+
+        for (int i = 0; i < results.length; i++) {
+            String displayName = results[i].getDisplayName();
+            String phoneNumber = results[i].getPhoneNumber();
+            String address = results[i].getAddress();
+            String profileUrl = results[i].getWebsite();
+            String photoUri = results[i].getPhotoUri();
+            String distance = results[i].getDistance();
+
+            if (DEBUG_SHOW_DISTANCE) {
+                if (distance != null) {
+                    displayName = displayName + " [" + distance + " miles]";
+                }
+            }
+
+            if (!phoneNumber.isEmpty()) {
+                Object[] row = new Object[projection.length];
+
+                if (indexDisplayName >= 0) {
+                    row[indexDisplayName] = displayName;
+                }
+
+                if (indexPhoneLabel >= 0) {
+                    row[indexPhoneLabel] = address;
+                }
+
+                if (indexHasPhoneNumber >= 0) {
+                    row[indexHasPhoneNumber] = true;
+                }
+
+                if (indexContactId >= 0) {
+                    row[indexContactId] = id;
+                }
+
+                if (indexPhoneNumber >= 0) {
+                    row[indexPhoneNumber] = phoneNumber;
+                }
+
+                if (indexPhoneType >= 0) {
+                    row[indexPhoneType] = Phone.TYPE_MAIN;
+                }
+
+                String photoThumbUri;
+
+                // Use default place icon if no photo exists
+                if (photoUri == null) {
+                    photoUri = new Uri.Builder()
+                            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+                            .authority("com.android.dialer")
+                            .appendPath(String.valueOf(
+                                    R.drawable.ic_places_picture_180_holo_light))
+                            .toString();
+
+                    photoThumbUri = new Uri.Builder()
+                            .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+                            .authority("com.android.dialer")
+                            .appendPath(String.valueOf(
+                                    R.drawable.ic_places_picture_holo_light))
+                            .toString();
+                } else {
+                    photoThumbUri = photoUri;
+                }
+
+                if (indexPhotoUri >= 0) {
+                    row[indexPhotoUri] = photoUri;
+                }
+
+                if (indexPhotoThumbUri >= 0) {
+                    row[indexPhotoThumbUri] = photoThumbUri;
+                }
+
+                if (indexLookupKey >= 0) {
+                    JSONObject contactRows = new JSONObject()
+                    .put(StructuredName.CONTENT_ITEM_TYPE,
+                            new JSONObject().put(
+                                    StructuredName.DISPLAY_NAME, displayName))
+                    .put(Phone.CONTENT_ITEM_TYPE,
+                            newJsonArray(new JSONObject()
+                                    .put(Phone.NUMBER, phoneNumber)
+                                    .put(Phone.TYPE, Phone.TYPE_MAIN)))
+                    .put(StructuredPostal.CONTENT_ITEM_TYPE,
+                            newJsonArray(new JSONObject()
+                                    .put(StructuredPostal.FORMATTED_ADDRESS,
+                                            displayName + ", " + address)
+                                    .put(StructuredPostal.TYPE,
+                                            StructuredPostal.TYPE_WORK)));
+
+                    if (profileUrl != null) {
+                        contactRows.put(Website.CONTENT_ITEM_TYPE,
+                                newJsonArray(new JSONObject()
+                                        .put(Website.URL, profileUrl)
+                                        .put(Website.TYPE, Website.TYPE_PROFILE)));
+                    }
+
+                    row[indexLookupKey] = new JSONObject()
+                            .put(Contacts.DISPLAY_NAME, displayName)
+                            .put(Contacts.DISPLAY_NAME_SOURCE,
+                                    DisplayNameSources.ORGANIZATION)
+                            .put(Directory.EXPORT_SUPPORT, exportSupport)
+                            .put(Contacts.PHOTO_URI, photoUri)
+                            .put(Contacts.CONTENT_ITEM_TYPE, contactRows)
+                            .toString();
+                }
+
+                if (indexId >= 0) {
+                    row[indexId] = id;
+                }
+
+                cursor.addRow(row);
+
+                if (maxResults != -1 && cursor.getCount() >= maxResults) {
+                    break;
+                }
+
+                id++;
+            }
+        }
+
+        return cursor;
+    }
+
+    /**
+     * Create new JSONArray of JSONObjects.
+     *
+     * @param objs JSONObjects
+     * @return JSONArray of JSONObject
+     */
+    private static JSONArray newJsonArray(JSONObject... objs) {
+        JSONArray array = new JSONArray();
+        for (int i = 0; i < objs.length; i++) {
+            array.put(objs[i]);
+        }
+        return array;
+    }
+
+    /**
+     * Execute thread that is killed after a specified amount of time.
+     *
+     * @param callable The thread
+     * @param name Name of the thread
+     * @param timeout Maximum time the thread can run
+     * @param timeUnit Units of 'timeout'
+     * @return Instance of the thread
+     */
+    private <T> T execute(Callable<T> callable, String name, long timeout,
+            TimeUnit timeUnit) {
+        FutureCallable<T> futureCallable = new FutureCallable<T>(callable);
+        FutureTask<T> future = new FutureTask<T>(futureCallable);
+        futureCallable.setFuture(future);
+
+        synchronized (mActiveTasks) {
+            mActiveTasks.addLast(future);
+            Log.v(TAG, "Currently running tasks: " + mActiveTasks.size());
+
+            while (mActiveTasks.size() > 8) {
+                Log.w(TAG, "Too many tasks, canceling one");
+                mActiveTasks.removeFirst().cancel(true);
+            }
+        }
+
+        Log.v(TAG, "Starting task " + name);
+
+        new Thread(future, name).start();
+
+        try {
+            Log.v(TAG, "Getting future " + name);
+            return future.get(timeout, timeUnit);
+        } catch (InterruptedException e) {
+            Log.w(TAG, "Task was interrupted: " + name);
+            Thread.currentThread().interrupt();
+        } catch (ExecutionException e) {
+            Log.w(TAG, "Task threw an exception: " + name, e);
+        } catch (TimeoutException e) {
+            Log.w(TAG, "Task timed out: " + name);
+            future.cancel(true);
+        } catch (CancellationException e) {
+            Log.w(TAG, "Task was cancelled: " + name);
+        }
+
+        return null;
+    }
+}
diff --git a/src/com/android/dialer/lookup/ForwardLookup.java b/src/com/android/dialer/lookup/ForwardLookup.java
new file mode 100644
index 0000000..7041ff2
--- /dev/null
+++ b/src/com/android/dialer/lookup/ForwardLookup.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup;
+
+import com.android.dialer.lookup.google.GoogleForwardLookup;
+import com.android.dialer.lookup.openstreetmap.OpenStreetMapForwardLookup;
+
+import android.content.Context;
+import android.location.Location;
+import android.util.Log;
+
+public abstract class ForwardLookup {
+    private static final String TAG = ForwardLookup.class.getSimpleName();
+
+    private static ForwardLookup INSTANCE = null;
+
+    public static ForwardLookup getInstance(Context context) {
+        String provider = LookupSettings.getForwardLookupProvider(context);
+
+        if (INSTANCE == null || !isInstance(provider)) {
+            Log.d(TAG, "Chosen forward lookup provider: " + provider);
+
+            if (provider.equals(LookupSettings.FLP_GOOGLE)) {
+                INSTANCE = new GoogleForwardLookup(context);
+            } else if (provider.equals(LookupSettings.FLP_OPENSTREETMAP)) {
+                INSTANCE = new OpenStreetMapForwardLookup(context);
+            }
+        }
+
+        return INSTANCE;
+    }
+
+    private static boolean isInstance(String provider) {
+        if (provider.equals(LookupSettings.FLP_GOOGLE)
+                && INSTANCE instanceof GoogleForwardLookup) {
+            return true;
+        } else if (provider.equals(LookupSettings.FLP_OPENSTREETMAP)
+                && INSTANCE instanceof OpenStreetMapForwardLookup) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public abstract ForwardLookupDetails[] lookup(Context context,
+            String filter, Location lastLocation);
+
+    public class ForwardLookupDetails {
+        private String mAddress;
+        private String mDisplayName;
+        private String mDistance;
+        private String mPhoneNumber;
+        private String mPhotoUri;
+        private String mWebsite;
+
+        public void setAddress(String address) {
+            mAddress = address;
+        }
+
+        public String getAddress() {
+            return mAddress;
+        }
+
+        public void setDisplayName(String displayName) {
+            mDisplayName = displayName;
+        }
+
+        public String getDisplayName() {
+            return mDisplayName;
+        }
+
+        public void setDistance(String distance) {
+            mDistance = distance;
+        }
+
+        public String getDistance() {
+            return mDistance;
+        }
+
+        public void setPhoneNumber(String phoneNumber) {
+            mPhoneNumber = phoneNumber;
+        }
+
+        public String getPhoneNumber() {
+            return mPhoneNumber;
+        }
+
+        public void setPhotoUri(String photoUri) {
+            mPhotoUri = photoUri;
+        }
+
+        public String getPhotoUri() {
+            return mPhotoUri;
+        }
+
+        public void setWebsite(String website) {
+            mWebsite = website;
+        }
+
+        public String getWebsite() {
+            return mWebsite;
+        }
+    }
+}
diff --git a/src/com/android/dialer/lookup/LookupSettings.java b/src/com/android/dialer/lookup/LookupSettings.java
new file mode 100644
index 0000000..9120925
--- /dev/null
+++ b/src/com/android/dialer/lookup/LookupSettings.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup;
+
+import android.content.Context;
+import android.provider.Settings;
+
+import com.google.android.gms.common.ConnectionResult;
+import com.google.android.gms.common.GooglePlayServicesUtil;
+
+public final class LookupSettings {
+    private static final String TAG = LookupSettings.class.getSimpleName();
+
+    /** Forward lookup providers */
+    public static final String FLP_GOOGLE = "Google";
+    public static final String FLP_OPENSTREETMAP = "OpenStreetMap";
+
+    /** Reverse lookup providers */
+    public static final String RLP_GOOGLE = "Google";
+    public static final String RLP_OPENCNAM = "OpenCnam";
+    public static final String RLP_WHITEPAGES = "WhitePages";
+    public static final String RLP_YELLOWPAGES = "YellowPages";
+    public static final String RLP_ZABASEARCH = "ZabaSearch";
+
+    private LookupSettings() {
+    }
+
+    public static boolean isForwardLookupEnabled(Context context) {
+        return Settings.System.getInt(context.getContentResolver(),
+                Settings.System.ENABLE_FORWARD_LOOKUP, 1) != 0;
+    }
+
+    public static boolean isReverseLookupEnabled(Context context) {
+        return Settings.System.getInt(context.getContentResolver(),
+                Settings.System.ENABLE_REVERSE_LOOKUP, 1) != 0;
+    }
+
+    public static String getForwardLookupProvider(Context context) {
+        String provider = getString(context,
+                Settings.System.FORWARD_LOOKUP_PROVIDER);
+
+        if (provider == null) {
+            putString(context,
+                    Settings.System.FORWARD_LOOKUP_PROVIDER, FLP_GOOGLE);
+
+            provider = getString(context,
+                    Settings.System.FORWARD_LOOKUP_PROVIDER);
+        }
+
+        return provider;
+    }
+
+    public static String getReverseLookupProvider(Context context) {
+        boolean gservicesAvailable =
+                GooglePlayServicesUtil.isGooglePlayServicesAvailable(
+                context) == ConnectionResult.SUCCESS;
+
+        String provider = getString(context,
+                Settings.System.REVERSE_LOOKUP_PROVIDER);
+
+        if (provider == null) {
+            // If Google Play Services is not available, default to the next
+            // provider in the list (OpenCnam)
+            putString(context,
+                    Settings.System.REVERSE_LOOKUP_PROVIDER,
+                    gservicesAvailable ? RLP_GOOGLE : RLP_OPENCNAM);
+
+            provider = getString(context,
+                    Settings.System.REVERSE_LOOKUP_PROVIDER);
+        }
+
+        return provider;
+    }
+
+    private static String getString(Context context, String key) {
+        return Settings.System.getString(context.getContentResolver(), key);
+    }
+
+    private static void putString(Context context, String key, String value) {
+        Settings.System.putString(context.getContentResolver(), key, value);
+    }
+}
diff --git a/src/com/android/dialer/lookup/PhoneNumberCacheContract.java b/src/com/android/dialer/lookup/PhoneNumberCacheContract.java
new file mode 100644
index 0000000..e86a642
--- /dev/null
+++ b/src/com/android/dialer/lookup/PhoneNumberCacheContract.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup;
+
+import android.net.Uri;
+
+public final class PhoneNumberCacheContract {
+    public static final Uri AUTHORITY_URI =
+            Uri.parse("content://com.android.dialer.cacheprovider");
+    public static final Uri CONTACT_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "contact");
+    public static final Uri PHOTO_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "photo");
+    public static final Uri THUMBNAIL_URI =
+            Uri.withAppendedPath(AUTHORITY_URI, "thumbnail");
+
+    private PhoneNumberCacheContract() {
+    }
+
+    public static Uri getContactLookupUri(String number) {
+        return CONTACT_URI.buildUpon().appendPath(number).build();
+    }
+
+    public static Uri getPhotoLookupUri(String number) {
+        return PHOTO_URI.buildUpon().appendPath(number).build();
+    }
+
+    public static Uri getThumbnailLookupUri(String number) {
+        return THUMBNAIL_URI.buildUpon().appendPath(number).build();
+    }
+}
diff --git a/src/com/android/dialer/lookup/PhoneNumberCacheProvider.java b/src/com/android/dialer/lookup/PhoneNumberCacheProvider.java
new file mode 100644
index 0000000..1206fea
--- /dev/null
+++ b/src/com/android/dialer/lookup/PhoneNumberCacheProvider.java
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup;
+
+import com.android.contacts.common.GeoUtil;
+import com.android.dialer.database.DialerDatabaseHelper;
+import com.android.dialer.database.DialerDatabaseHelper.CachedContactsColumns;
+import com.android.dialer.database.DialerDatabaseHelper.SmartDialDbColumns;
+import com.android.dialer.database.DialerDatabaseHelper.Tables;
+import com.android.dialer.service.CachedNumberLookupServiceImpl;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PathPermission;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteDoneException;
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+public class PhoneNumberCacheProvider extends ContentProvider {
+    private static final String TAG = PhoneNumberCacheProvider.class.getSimpleName();
+    private static final String AUTHORITY = "com.android.dialer.cacheprovider";
+
+    public static final int CONTACT_ID = 1000;
+    public static final int CONTACT = 1001;
+    public static final int PHOTO = 2000;
+    public static final int THUMBNAIL = 3000;
+
+    private static final Set<String> SUPPORTED_UPDATE_COLUMNS
+            = new HashSet<String>();
+    private static final UriMatcher sUriMatcher = new UriMatcher(-1);
+    private final String[] mArgs1;
+    private DialerDatabaseHelper mDbHelper;
+    private File mPhotoPath;
+    private File mThumbnailPath;
+
+    static {
+        sUriMatcher.addURI(AUTHORITY, "contact", CONTACT_ID);
+        sUriMatcher.addURI(AUTHORITY, "contact/*", CONTACT);
+        sUriMatcher.addURI(AUTHORITY, "photo/*", PHOTO);
+        sUriMatcher.addURI(AUTHORITY, "thumbnail/*", THUMBNAIL);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.NUMBER);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.PHONE_TYPE);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.PHONE_LABEL);
+        SUPPORTED_UPDATE_COLUMNS.add(SmartDialDbColumns.DISPLAY_NAME_PRIMARY);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.PHOTO_URI);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.SOURCE_NAME);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.SOURCE_TYPE);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.SOURCE_ID);
+        SUPPORTED_UPDATE_COLUMNS.add(CachedContactsColumns.LOOKUP_KEY);
+    }
+
+    public PhoneNumberCacheProvider() {
+        mArgs1 = new String[1];
+    }
+
+    public PhoneNumberCacheProvider(Context context, String readPermission,
+            String writePermission, PathPermission[] pathPermissions) {
+        super(context, readPermission, writePermission, pathPermissions);
+        mArgs1 = new String[1];
+    }
+
+    @Override
+    public boolean onCreate() {
+        mDbHelper = DialerDatabaseHelper.getInstance(getContext());
+        createPhotoDirectoriesIfDoNotExist();
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+            String[] selectionArgs, String sortOrder) {
+        int type = sUriMatcher.match(uri);
+
+        if (type == CONTACT) {
+            String number = getNumberFromUri(uri);
+
+            if (number != null) {
+                mDbHelper.prune();
+                mArgs1[0] = number;
+                return mDbHelper.getWritableDatabase().query(
+                        Tables.CACHED_CONTACTS, projection,
+                        CachedContactsColumns.NORMALIZED_NUMBER + "=?",
+                        mArgs1, null, null, null);
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        int type = sUriMatcher.match(uri);
+
+        switch (type) {
+        case CONTACT_ID:
+        case CONTACT:
+            String number;
+            if (type == CONTACT_ID) {
+                number = getNumberFromValues(values);
+            } else {
+                number = getNumberFromUri(uri);
+            }
+
+            for (String key : values.keySet()) {
+                if (!SUPPORTED_UPDATE_COLUMNS.contains(key)) {
+                    values.remove(key);
+                    Log.e(TAG, "Ignoring unsupported column for update: " + key);
+                }
+            }
+
+            mDbHelper.prune();
+            values.put(CachedContactsColumns.NORMALIZED_NUMBER, number);
+            values.put(CachedContactsColumns.TIME_LAST_UPDATED,
+                    System.currentTimeMillis());
+
+            SQLiteDatabase db = mDbHelper.getWritableDatabase();
+            mArgs1[0] = number;
+            Integer sourceType = values.getAsInteger(
+                    CachedContactsColumns.SOURCE_TYPE);
+
+            boolean overrideCache = false;
+
+            if (sourceType != null && CachedNumberLookupServiceImpl
+                    .CachedContactInfoImpl.isLookupSource(sourceType)) {
+                overrideCache = true;
+            } else {
+                int prevSourceType = -1;
+
+                try {
+                    prevSourceType = (int) DatabaseUtils.longForQuery(db,
+                            "SELECT " + CachedContactsColumns.SOURCE_TYPE +
+                            " FROM " + Tables.CACHED_CONTACTS + " WHERE " +
+                            CachedContactsColumns.NORMALIZED_NUMBER + "=?",
+                            mArgs1);
+                } catch (SQLiteDoneException ex) {
+                }
+
+                boolean peopleApiSource = CachedNumberLookupServiceImpl
+                        .CachedContactInfoImpl.isLookupSource(
+                        prevSourceType);
+
+                if (!peopleApiSource) {
+                    overrideCache = true;
+                }
+            }
+
+            if (overrideCache) {
+                db.insertWithOnConflict(Tables.CACHED_CONTACTS,
+                        null, values, SQLiteDatabase.CONFLICT_REPLACE);
+            }
+
+            return uri;
+
+        default:
+            throw new IllegalArgumentException("Unknown URI");
+        }
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values,
+            String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException(
+                "The cache does not support update operations."
+                + " Use insert to replace an existing phone number, if needed.");
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        if (sUriMatcher.match(uri) == CONTACT) {
+            mDbHelper.prune();
+
+            String number = getNumberFromUri(uri);
+            mArgs1[0] = number;
+            SQLiteDatabase db = mDbHelper.getWritableDatabase();
+            deleteFiles(number);
+            return db.delete(Tables.CACHED_CONTACTS,
+                    CachedContactsColumns.NORMALIZED_NUMBER
+                    + "=?", mArgs1);
+        }
+        throw new IllegalArgumentException(
+                "Unknown URI or phone number not provided");
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        return null;
+    }
+
+    @Override
+    public ParcelFileDescriptor openFile(Uri uri, String mode)
+            throws FileNotFoundException {
+        int type = sUriMatcher.match(uri);
+
+        switch (type) {
+        case PHOTO:
+        case THUMBNAIL:
+            String number = getNumberFromUri(uri);
+
+            if (!isNumberInCache(number)) {
+                throw new FileNotFoundException("Phone number does not exist in cache");
+            }
+
+            if (mode.equals("r")) {
+                return openFileForRead(number, type == PHOTO);
+            } else {
+                return openFileForWrite(number, type == PHOTO);
+            }
+
+        default:
+            throw new FileNotFoundException("Unknown or unsupported URI");
+        }
+    }
+
+    /**
+     * Create directories for storing cached photos and thumbnails.
+     */
+    private void createPhotoDirectoriesIfDoNotExist() {
+        mPhotoPath = new File(getContext().getFilesDir(), "photos/raw");
+        mThumbnailPath = new File(getContext().getFilesDir(), "thumbnails/raw");
+        createDirectoryIfDoesNotExist(mPhotoPath);
+        createDirectoryIfDoesNotExist(mThumbnailPath);
+    }
+
+    /**
+     * Create a directory if it doesn't already exist.
+     *
+     * @param dir File object representing the directory
+     */
+    private void createDirectoryIfDoesNotExist(File dir) {
+        if (!dir.exists() && !dir.mkdirs()) {
+            throw new RuntimeException(
+                    "Unable to create photo storage directory " + dir.getPath());
+        }
+    }
+
+    /**
+     * Get phone number from ContentValues and return it E-164 formatted.
+     *
+     * @param values The ContentValues containing the phone number
+     * @return The phone number
+     */
+    private String getNumberFromValues(ContentValues values) {
+        String number = values.getAsString("number");
+
+        if (number == null || number.length() == 0) {
+            throw new IllegalArgumentException("Phone number not provided");
+        }
+
+        return getE164Number(number);
+    }
+
+    /**
+     * Get phone number of content URI.
+     *
+     * @param uri The URI
+     * @return A string containing the E-164 formatted phone number
+     */
+    private String getNumberFromUri(Uri uri) {
+        if (uri.getPathSegments().size() != 2) {
+            throw new IllegalArgumentException(
+                    "Invalid URI or phone number not provided");
+        }
+        return getE164Number(uri.getLastPathSegment());
+    }
+
+    /**
+     * Format phone number as E-164.
+     *
+     * @param number The phone number to format
+     * @return The E-164 formatted phone number
+     */
+    private String getE164Number(String number) {
+        return PhoneNumberUtils.formatNumberToE164(number,
+                GeoUtil.getCurrentCountryIso(getContext()));
+    }
+
+    /**
+     * Check if phone number is in the cache.
+     *
+     * @param number The phone number to check
+     * @return Whether the number is in the cache
+     */
+    private boolean isNumberInCache(String number) {
+        SQLiteDatabase db = mDbHelper.getReadableDatabase();
+
+        mArgs1[0] = number;
+        long entries = DatabaseUtils.queryNumEntries(db,
+                DialerDatabaseHelper.Tables.CACHED_CONTACTS,
+                DialerDatabaseHelper.CachedContactsColumns
+                        .NORMALIZED_NUMBER + "=?", mArgs1);
+
+        return entries > 0;
+    }
+
+    /**
+     * Open photo or thumbnail file for a phone number for reading.
+     *
+     * @param number The phone number
+     * @param fullPhoto Whether to open the photo or thumbnail
+     * @return The ParcelFileDescriptor for the file
+     */
+    private ParcelFileDescriptor openFileForRead(
+            String number, boolean fullPhoto) throws FileNotFoundException {
+        File file;
+
+        if (fullPhoto) {
+            file = getPhotoForNumber(number);
+        } else {
+            file = getThumbnailForNumber(number);
+        }
+
+        if (file.exists()) {
+            return ParcelFileDescriptor.open(file,
+                    ParcelFileDescriptor.MODE_READ_ONLY);
+        } else {
+            setHavePhoto(number, fullPhoto, false);
+            throw new FileNotFoundException(
+                    "No photo file found for number: " + number);
+        }
+    }
+
+    /**
+     * Open photo or thumbnail file for a phone number for writing.
+     *
+     * @param number The phone number
+     * @param fullPhoto Whether to open the photo or thumbnail
+     * @return The ParcelFileDescriptor for the file
+     */
+    private ParcelFileDescriptor openFileForWrite(
+            String number, boolean fullPhoto) {
+        File file;
+
+        if (fullPhoto) {
+            file = getPhotoForNumber(number);
+        } else {
+            file = getThumbnailForNumber(number);
+        }
+
+        try {
+            if (!file.exists()) {
+                file.createNewFile();
+                setHavePhoto(number, fullPhoto, true);
+            }
+
+            return ParcelFileDescriptor.open(file,
+                    ParcelFileDescriptor.MODE_READ_WRITE);
+        } catch (FileNotFoundException e) {
+            return null;
+        } catch (IOException e) {
+            Log.e(TAG, "Failed create new file for cached photo.", e);
+            return null;
+        }
+    }
+
+    /**
+     * Get File object for photo in the photo cache directory.
+     *
+     * @param number The phone number
+     * @return File object for photo
+     */
+    private File getPhotoForNumber(String number) {
+        return new File(mPhotoPath, number);
+    }
+
+    /**
+     * Get File object for thumbnail in the thumbnail cache directory.
+     *
+     * @param number The phone number
+     * @return File object for thumbnail
+     */
+    private File getThumbnailForNumber(String number) {
+        return new File(mThumbnailPath, number);
+    }
+
+    /**
+     * Write whether the photo or thumbnail for a phone number exists to the
+     * database.
+     *
+     * @param number The phone number
+     * @param fullPhoto Whether to set for the photo or thumbnail
+     * @param haveFile Whether the file exists
+     */
+    private void setHavePhoto(String number, boolean fullPhoto, boolean haveFile) {
+        SQLiteDatabase db = mDbHelper.getWritableDatabase();
+
+        mArgs1[0] = number;
+        StringBuilder sb = new StringBuilder();
+        sb.append("UPDATE " + Tables.CACHED_CONTACTS + " SET ");
+
+        if (fullPhoto) {
+            sb.append(CachedContactsColumns.HAS_PHOTO);
+        } else {
+            sb.append(CachedContactsColumns.HAS_THUMBNAIL);
+        }
+
+        sb.append("=");
+        sb.append(haveFile ? "1" : "0");
+        sb.append(" WHERE ");
+        sb.append(CachedContactsColumns.NORMALIZED_NUMBER + "=?");
+        sb.append(";");
+
+        db.execSQL(sb.toString(), mArgs1);
+    }
+
+    /**
+     * Delete photo or thumbnail file for phone number.
+     *
+     * @param number The phone number
+     * @param fullPhoto Whether to delete the photo or thumbnail
+     * @return Whether the delete operation succeeded
+     */
+    private boolean deleteFile(String number, boolean fullPhoto) {
+        File file;
+
+        if (fullPhoto) {
+            file = getPhotoForNumber(number);
+        } else {
+            file = getThumbnailForNumber(number);
+        }
+
+        return file.delete();
+    }
+
+    /**
+     * Delete photo and thumbnail for phone number.
+     *
+     * @param number The phone number
+     * @return Whether the delete operation succeeded
+     */
+    private boolean deleteFiles(String number) {
+        boolean deletedPhoto = deleteFile(number, true);
+        boolean deletedThumbnail = deleteFile(number, false);
+
+        if (!deletedPhoto && !deletedThumbnail) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+}
diff --git a/src/com/android/dialer/lookup/ReverseLookup.java b/src/com/android/dialer/lookup/ReverseLookup.java
new file mode 100644
index 0000000..04fe00a
--- /dev/null
+++ b/src/com/android/dialer/lookup/ReverseLookup.java
@@ -0,0 +1,419 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup;
+
+import com.android.dialer.R;
+import com.android.dialer.lookup.google.GoogleReverseLookup;
+import com.android.dialer.lookup.opencnam.OpenCnamReverseLookup;
+import com.android.dialer.lookup.whitepages.WhitePagesReverseLookup;
+import com.android.dialer.lookup.yellowpages.YellowPagesReverseLookup;
+import com.android.dialer.lookup.zabasearch.ZabaSearchReverseLookup;
+import com.android.incallui.service.PhoneNumberServiceImpl.PhoneNumberInfoImpl;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.net.Uri;
+import android.util.Log;
+import android.util.Pair;
+
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.StructuredName;
+import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
+import android.provider.ContactsContract.CommonDataKinds.Website;
+import android.provider.ContactsContract.Contacts;
+
+import java.util.ArrayList;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public abstract class ReverseLookup {
+    private static final String TAG = ReverseLookup.class.getSimpleName();
+
+    private static ReverseLookup INSTANCE = null;
+
+    public static ReverseLookup getInstance(Context context) {
+        String provider = LookupSettings.getReverseLookupProvider(context);
+
+        if (INSTANCE == null || !isInstance(provider)) {
+            Log.d(TAG, "Chosen reverse lookup provider: " + provider);
+
+            if (provider.equals(LookupSettings.RLP_GOOGLE)) {
+                INSTANCE = new GoogleReverseLookup(context);
+            } else if (provider.equals(LookupSettings.RLP_OPENCNAM)) {
+                INSTANCE = new OpenCnamReverseLookup(context);
+            } else if (provider.equals(LookupSettings.RLP_WHITEPAGES)) {
+                INSTANCE = new WhitePagesReverseLookup(context);
+            } else if (provider.equals(LookupSettings.RLP_YELLOWPAGES)) {
+                INSTANCE = new YellowPagesReverseLookup(context);
+            } else if (provider.equals(LookupSettings.RLP_ZABASEARCH)) {
+                INSTANCE = new ZabaSearchReverseLookup(context);
+            }
+        }
+
+        return INSTANCE;
+    }
+
+    private static boolean isInstance(String provider) {
+        if (provider.equals(LookupSettings.RLP_GOOGLE)
+                && INSTANCE instanceof GoogleReverseLookup) {
+            return true;
+        } else if (provider.equals(LookupSettings.RLP_OPENCNAM)
+                && INSTANCE instanceof OpenCnamReverseLookup) {
+            return true;
+        } else if (provider.equals(LookupSettings.RLP_WHITEPAGES)
+                && INSTANCE instanceof WhitePagesReverseLookup) {
+            return true;
+        } else if (provider.equals(LookupSettings.RLP_YELLOWPAGES)
+                && INSTANCE instanceof YellowPagesReverseLookup) {
+            return true;
+        } else if (provider.equals(LookupSettings.RLP_ZABASEARCH)
+                && INSTANCE instanceof ZabaSearchReverseLookup) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Lookup image
+     *
+     * @param context The application context
+     * @param url The image URL
+     * @param data Extra data (a authentication token, perhaps)
+     */
+    public abstract byte[] lookupImage(Context context, String url, Object data);
+
+    /**
+     * Perform phone number lookup.
+     *
+     * @param context The application context
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param isIncoming Whether the call is incoming or outgoing
+     * @return The phone number info object
+     */
+    public abstract Pair<PhoneNumberInfoImpl, Object> lookupNumber(
+            Context context, String normalizedNumber, String formattedNumber,
+            boolean isIncoming);
+
+    public static class ContactBuilder {
+        private static final String TAG =
+                ContactBuilder.class.getSimpleName();
+
+        private static final boolean DEBUG = true;
+
+        /** Default photo for businesses if no other image is found */
+        public static final String PHOTO_URI_BUSINESS =
+                new Uri.Builder()
+                .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+                .authority("com.android.dialer")
+                .appendPath(String.valueOf(
+                        R.drawable.ic_places_picture_180_holo_light))
+                .build()
+                .toString();
+
+        private ArrayList<Address> mAddresses = new ArrayList<Address>();
+        private ArrayList<PhoneNumber> mPhoneNumbers
+                = new ArrayList<PhoneNumber>();
+        private ArrayList<WebsiteUrl> mWebsites
+                = new ArrayList<WebsiteUrl>();
+
+        private Name mName;
+
+        private String mNormalizedNumber;
+        private String mFormattedNumber;
+        private int mDisplayNameSource;
+        private String mPhotoUri;
+
+        private boolean mIsBusiness;
+
+        public ContactBuilder(String normalizedNumber, String formattedNumber) {
+            mNormalizedNumber = normalizedNumber;
+            mFormattedNumber = formattedNumber;
+        }
+
+        public void addAddress(Address address) {
+            if (DEBUG) Log.d(TAG, "Adding address: " + address);
+            if (address != null) {
+                mAddresses.add(address);
+            }
+        }
+
+        public Address[] getAddresses() {
+            return mAddresses.toArray(new Address[mAddresses.size()]);
+        }
+
+        public void addPhoneNumber(PhoneNumber phoneNumber) {
+            if (DEBUG) Log.d(TAG, "Adding phone number: " + phoneNumber);
+            if (phoneNumber != null) {
+                mPhoneNumbers.add(phoneNumber);
+            }
+        }
+
+        public PhoneNumber[] getPhoneNumbers() {
+            return mPhoneNumbers.toArray(
+                    new PhoneNumber[mPhoneNumbers.size()]);
+        }
+
+        public void addWebsite(WebsiteUrl website) {
+            if (DEBUG) Log.d(TAG, "Adding website: " + website);
+            if (website != null) {
+                mWebsites.add(website);
+            }
+        }
+
+        public Website[] getWebsites() {
+            return mWebsites.toArray(new Website[mWebsites.size()]);
+        }
+
+        public void setName(Name name) {
+            if (DEBUG) Log.d(TAG, "Setting name: " + name);
+            if (name != null) {
+                mName = name;
+            }
+        }
+
+        public Name getName() {
+            return mName;
+        }
+
+        public void setDisplayNameSource(int source) {
+            if (DEBUG) Log.d(TAG, "Setting display name source: " + source);
+            mDisplayNameSource = source;
+        }
+
+        public int getDisplayNameSource() {
+            return mDisplayNameSource;
+        }
+
+        public void setPhotoUri(String photoUri) {
+            if (DEBUG) Log.d(TAG, "Setting photo URI: " + photoUri);
+            mPhotoUri = photoUri;
+        }
+
+        public String getPhotoUri() {
+            return mPhotoUri;
+        }
+
+        public void setIsBusiness(boolean isBusiness) {
+            if (DEBUG) Log.d(TAG, "Setting isBusiness to: " + isBusiness);
+            mIsBusiness = isBusiness;
+        }
+
+        public boolean isBusiness() {
+            return mIsBusiness;
+        }
+
+        public PhoneNumberInfoImpl build() {
+            if (mName == null) {
+                throw new IllegalStateException("Name has not been set");
+            }
+
+            // Use the incoming call's phone number if no other phone number
+            // is specified. The reverse lookup source could present the phone
+            // number differently (eg. without the area code).
+            if (mPhoneNumbers.size() == 0) {
+                PhoneNumber pn = new PhoneNumber();
+                // Use the formatted number where possible
+                pn.number = mFormattedNumber != null
+                        ? mFormattedNumber : mNormalizedNumber;
+                pn.type = Phone.TYPE_MAIN;
+                addPhoneNumber(pn);
+            }
+
+            try {
+                JSONObject contact = new JSONObject();
+
+                // Insert the name
+                contact.put(StructuredName.CONTENT_ITEM_TYPE,
+                        mName.getJsonObject());
+
+                // Insert phone numbers
+                JSONArray phoneNumbers = new JSONArray();
+                for (int i = 0; i < mPhoneNumbers.size(); i++) {
+                    phoneNumbers.put(mPhoneNumbers.get(i).getJsonObject());
+                }
+                contact.put(Phone.CONTENT_ITEM_TYPE, phoneNumbers);
+
+                // Insert addresses if there are any
+                if (mAddresses.size() > 0) {
+                    JSONArray addresses = new JSONArray();
+                    for (int i = 0; i < mAddresses.size(); i++) {
+                        addresses.put(mAddresses.get(i).getJsonObject());
+                    }
+                    contact.put(StructuredPostal.CONTENT_ITEM_TYPE, addresses);
+                }
+
+                // Insert websites if there are any
+                if (mWebsites.size() > 0) {
+                    JSONArray websites = new JSONArray();
+                    for (int i = 0; i < mWebsites.size(); i++) {
+                        websites.put(mWebsites.get(i).getJsonObject());
+                    }
+                    contact.put(Website.CONTENT_ITEM_TYPE, websites);
+                }
+
+                return new PhoneNumberInfoImpl(
+                        mName.displayName,
+                        mNormalizedNumber,
+                        mPhoneNumbers.get(0).number,
+                        mPhoneNumbers.get(0).type,
+                        mPhoneNumbers.get(0).label,
+                        mPhotoUri,
+                        new JSONObject()
+                        .put(Contacts.DISPLAY_NAME, mName.displayName)
+                        .put(Contacts.DISPLAY_NAME_SOURCE, mDisplayNameSource)
+                        .putOpt(Contacts.PHOTO_URI, mPhotoUri)
+                        .put(Contacts.CONTENT_ITEM_TYPE, contact)
+                        .toString(),
+                        mIsBusiness);
+            } catch (JSONException e) {
+                Log.e(TAG, "Failed to build contact", e);
+                return null;
+            }
+        }
+
+        // android.provider.ContactsContract.CommonDataKinds.StructuredPostal
+        public static class Address {
+            public String formattedAddress;
+            public int type;
+            public String label;
+            public String street;
+            public String poBox;
+            public String neighborhood;
+            public String city;
+            public String region;
+            public String postCode;
+            public String country;
+
+            public JSONObject getJsonObject() throws JSONException {
+                JSONObject json = new JSONObject();
+                json.putOpt(StructuredPostal.FORMATTED_ADDRESS,
+                        formattedAddress);
+                json.put(StructuredPostal.TYPE, type);
+                json.put(StructuredPostal.LABEL, label);
+                json.put(StructuredPostal.STREET, street);
+                json.put(StructuredPostal.POBOX, poBox);
+                json.put(StructuredPostal.NEIGHBORHOOD, neighborhood);
+                json.put(StructuredPostal.CITY, city);
+                json.put(StructuredPostal.REGION, region);
+                json.put(StructuredPostal.POSTCODE, postCode);
+                json.put(StructuredPostal.COUNTRY, country);
+                return json;
+            }
+
+            public String toString() {
+                return "formattedAddress: " + formattedAddress + "; " +
+                        "type: " + type + "; " +
+                        "label: " + label + "; " +
+                        "street: " + street + "; " +
+                        "poBox: " + poBox + "; " +
+                        "neighborhood: " + neighborhood + "; " +
+                        "city: " + city + "; " +
+                        "region: " + region + "; " +
+                        "postCode: " + postCode + "; " +
+                        "country: " + country;
+            }
+        }
+
+        // android.provider.ContactsContract.CommonDataKinds.StructuredName
+        public static class Name {
+            public String displayName;
+            public String givenName;
+            public String familyName;
+            public String prefix;
+            public String middleName;
+            public String suffix;
+            public String phoneticGivenName;
+            public String phoneticMiddleName;
+            public String phoneticFamilyName;
+
+            public JSONObject getJsonObject() throws JSONException {
+                JSONObject json = new JSONObject();
+                json.putOpt(StructuredName.DISPLAY_NAME, displayName);
+                json.putOpt(StructuredName.GIVEN_NAME, givenName);
+                json.putOpt(StructuredName.FAMILY_NAME, familyName);
+                json.putOpt(StructuredName.PREFIX, prefix);
+                json.putOpt(StructuredName.MIDDLE_NAME, middleName);
+                json.putOpt(StructuredName.SUFFIX, suffix);
+                json.putOpt(StructuredName.PHONETIC_GIVEN_NAME,
+                        phoneticGivenName);
+                json.putOpt(StructuredName.PHONETIC_MIDDLE_NAME,
+                        phoneticMiddleName);
+                json.putOpt(StructuredName.PHONETIC_FAMILY_NAME,
+                        phoneticFamilyName);
+                return json;
+            }
+
+            public String toString() {
+                return "displayName: " + displayName + "; " +
+                        "givenName: " + givenName + "; " +
+                        "familyName: " + familyName + "; " +
+                        "prefix: " + prefix + "; " +
+                        "middleName: " + middleName + "; " +
+                        "suffix: " + suffix + "; " +
+                        "phoneticGivenName: " + phoneticGivenName + "; " +
+                        "phoneticMiddleName: " + phoneticMiddleName + "; " +
+                        "phoneticFamilyName: " + phoneticFamilyName;
+            }
+        }
+
+        // android.provider.ContactsContract.CommonDataKinds.Phone
+        public static class PhoneNumber {
+            public String number;
+            public int type;
+            public String label;
+
+            public JSONObject getJsonObject() throws JSONException {
+                JSONObject json = new JSONObject();
+                json.put(Phone.NUMBER, number);
+                json.put(Phone.TYPE, type);
+                json.putOpt(Phone.LABEL, label);
+                return json;
+            }
+
+            public String toString() {
+                return "number: " + number + "; " +
+                        "type: " + type + "; " +
+                        "label: " + label;
+            }
+        }
+
+        // android.provider.ContactsContract.CommonDataKinds.Website
+        public static class WebsiteUrl {
+            public String url;
+            public int type;
+            public String label;
+
+            public JSONObject getJsonObject() throws JSONException {
+                JSONObject json = new JSONObject();
+                json.put(Website.URL, url);
+                json.put(Website.TYPE, type);
+                json.putOpt(Website.LABEL, label);
+                return json;
+            }
+
+            public String toString() {
+                return "url: " + url + "; " +
+                        "type: " + type + "; " +
+                        "label: " + label;
+            }
+        }
+    }
+}
diff --git a/src/com/android/dialer/lookup/google/GoogleAuth.java b/src/com/android/dialer/lookup/google/GoogleAuth.java
new file mode 100644
index 0000000..9928cbb
--- /dev/null
+++ b/src/com/android/dialer/lookup/google/GoogleAuth.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.google;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Build;
+import android.telephony.TelephonyManager;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.entity.UrlEncodedFormEntity;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.message.BasicNameValuePair;
+
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Request URLs without going through Google Play Services because we need to
+ * imitate the package and signature for com.google.android.dialer in order to
+ * get the needed data.
+ */
+public class GoogleAuth {
+    private static GoogleAuth INSTANCE = null;
+
+    private Context mContext = null;
+
+    /** Authentication URL */
+    private static final String AUTH_URL =
+            "https://android.clients.google.com/auth";
+
+    /** Token revoke URL */
+    private static final String REVOKE_URL =
+            "https://accounts.google.com/o/oauth2/revoke?token=";
+
+    /** Google Dialer package name */
+    private static final String PACKAGE = "com.google.android.dialer";
+
+    /** Google's signing key certificate fingerprint
+      * https://androidobservatory.org/cert/38918A453D07199354F8B19AF05EC6562CED5788 */
+    private static final String FINGERPRINT = "38918a453d07199354f8b19af05ec6562ced5788";
+
+    private static final String ACCOUNT_TYPE = "HOSTED_OR_GOOGLE";
+
+    private String mDeviceCountry;
+    private String mOperatorCountry;
+    private String mLanguage;
+
+    private static final String mPlayServicesVersion = "4132538";
+    private static final String mSystemPartition = "1";
+    private static final String mHasPermission = "1";
+    private static final String mSource = "android";
+
+    private static final String KEY_DEVICE_COUNTRY = "device_country";
+    private static final String KEY_OPERATOR_COUNTRY = "operatorCountry";
+    private static final String KEY_LANG = "lang";
+    private static final String KEY_SDK_VERSION = "sdk_version";
+    private static final String KEY_PLAY_SERVICES_VERSION = "google_play_services_version";
+    private static final String KEY_ACCOUNT_TYPE = "accountType";
+    private static final String KEY_SYSTEM_PARTITION = "system_partition";
+    private static final String KEY_EMAIL = "Email";
+    private static final String KEY_HAS_PERMISSION = "has_permission";
+    private static final String KEY_SERVICE = "service";
+    private static final String KEY_SOURCE = "source";
+    private static final String KEY_ANDROID_ID = "androidId";
+    private static final String KEY_APP = "app";
+    private static final String KEY_CLIENT_SIGNATURE = "client_sig";
+    private static final String KEY_CALLER_PACKAGE = "callerPkg";
+    private static final String KEY_CALLER_SIGNATURE = "callerSig";
+    private static final String KEY_TOKEN = "Token";
+
+    public GoogleAuth(Context context) {
+        mContext = context.getApplicationContext();
+
+        mDeviceCountry = context.getResources().getConfiguration().locale.getCountry();
+
+        TelephonyManager tm = (TelephonyManager)
+                context.getSystemService(Context.TELEPHONY_SERVICE);
+        mOperatorCountry = tm.getNetworkCountryIso();
+        //mOperatorCountry = tm.getSimCountryIso();
+
+        mLanguage = Locale.getDefault().toString();
+    }
+
+    public static GoogleAuth getInstance(Context context) {
+        if (INSTANCE == null) {
+            INSTANCE = new GoogleAuth(context);
+        }
+        return INSTANCE;
+    }
+
+    /**
+     * Get OAuth2 access token
+     *
+     * @param scope OAuth2 scope
+     * @return The OAuth2 access token
+     */
+    public String getToken(Account account, String scope) {
+        String refreshToken = getRefreshToken(account);
+
+        HttpClient client = new DefaultHttpClient();
+        HttpPost post = new HttpPost(AUTH_URL);
+
+        try {
+            List<NameValuePair> pairs = new ArrayList<NameValuePair>(1);
+            pairs.add(new BasicNameValuePair(KEY_DEVICE_COUNTRY, mDeviceCountry));
+            pairs.add(new BasicNameValuePair(KEY_OPERATOR_COUNTRY, mOperatorCountry));
+            pairs.add(new BasicNameValuePair(KEY_LANG, mLanguage));
+            pairs.add(new BasicNameValuePair(KEY_SDK_VERSION,
+                    Integer.toString(Build.VERSION.SDK_INT)));
+            pairs.add(new BasicNameValuePair(KEY_PLAY_SERVICES_VERSION,
+                    mPlayServicesVersion));
+            pairs.add(new BasicNameValuePair(KEY_ACCOUNT_TYPE, ACCOUNT_TYPE));
+            pairs.add(new BasicNameValuePair(KEY_SYSTEM_PARTITION, mSystemPartition));
+            pairs.add(new BasicNameValuePair(KEY_EMAIL, account.name));
+            pairs.add(new BasicNameValuePair(KEY_HAS_PERMISSION, mHasPermission));
+            pairs.add(new BasicNameValuePair(KEY_SERVICE, scope));
+            pairs.add(new BasicNameValuePair(KEY_SOURCE, mSource));
+            pairs.add(new BasicNameValuePair(KEY_ANDROID_ID, getAndroidId()));
+            pairs.add(new BasicNameValuePair(KEY_APP, PACKAGE));
+            pairs.add(new BasicNameValuePair(KEY_CLIENT_SIGNATURE, FINGERPRINT));
+            pairs.add(new BasicNameValuePair(KEY_CALLER_PACKAGE, PACKAGE));
+            pairs.add(new BasicNameValuePair(KEY_CALLER_SIGNATURE, FINGERPRINT));
+            pairs.add(new BasicNameValuePair(KEY_TOKEN, refreshToken));
+
+            post.setEntity(new UrlEncodedFormEntity(pairs));
+
+            HttpResponse response = client.execute(post);
+            BufferedReader in = new BufferedReader(
+                    new InputStreamReader(response.getEntity().getContent()));
+
+            // OAuth2 access token
+            String token = null;
+
+            String line;
+            while ((line = in.readLine()) != null) {
+                if (line.length() > 5 && line.startsWith("Auth=")) {
+                    token = line.substring(5);
+                }
+            }
+
+            return token;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    /**
+     * Invalidate a OAuth2 access token
+     *
+     * @param token The token
+     */
+    public void invalidateToken(String token) {
+        String url = REVOKE_URL + token;
+        HttpClient client = new DefaultHttpClient();
+        HttpGet request = new HttpGet(url);
+
+        try {
+            HttpResponse response = client.execute(request);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Get the OAuth2 refresh token for a Google account.
+     *
+     * @param account The Google account
+     * @return The refresh token
+     */
+    private String getRefreshToken(Account account) {
+        AccountManager am = AccountManager.get(mContext);
+        // Google stores the token in the password field
+        return am.getPassword(account);
+    }
+
+    /**
+     * Get Android ID (ie. GTalk ID) from Gservices.
+     *
+     * @return Android ID
+     */
+    private String getAndroidId() {
+        // Not a problem for installations without gapps since this code won't
+        // be called if there are no Google accounts registered in
+        // AccountManager
+        String[] query = new String[] { "android_id" };
+        Cursor cursor = mContext.getContentResolver().query(
+                Uri.parse("content://com.google.android.gsf.gservices"),
+                null, null, query, null);
+
+        if (cursor.moveToFirst() && cursor.getColumnCount() >= 2) {
+            return Long.toHexString(Long.parseLong(cursor.getString(1)));
+        }
+
+        return null;
+    }
+}
diff --git a/src/com/android/dialer/lookup/google/GoogleForwardLookup.java b/src/com/android/dialer/lookup/google/GoogleForwardLookup.java
new file mode 100644
index 0000000..75c075a
--- /dev/null
+++ b/src/com/android/dialer/lookup/google/GoogleForwardLookup.java
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.google;
+
+import com.android.dialer.lookup.ForwardLookup;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.location.Location;
+import android.net.Uri;
+import android.os.Build;
+import android.text.Html;
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class GoogleForwardLookup extends ForwardLookup {
+    private static final String TAG =
+            GoogleForwardLookup.class.getSimpleName();
+
+    private static final String QUERY_FILTER = "q";
+    private static final String QUERY_LANGUAGE = "hl";
+    private static final String QUERY_LOCATION = "sll";
+    private static final String QUERY_RADIUS = "radius";
+    private static final String QUERY_RANDOM = "gs_gbg";
+
+    private static final String RESULT_ADDRESS = "a";
+    private static final String RESULT_NUMBER = "b";
+    private static final String RESULT_DISTANCE = "c";
+    private static final String RESULT_PHOTO_URI = "d";
+    private static final String RESULT_WEBSITE = "f";
+    private static final String RESULT_CITY = "g";
+
+    /** Base for the query URL */
+    private static final String LOOKUP_URL =
+            "https://www.google.com/complete/search?gs_ri=dialer";
+
+    /** Minimum query length
+     * (default for dialer_nearby_places_min_query_len) */
+    private static final int MIN_QUERY_LEN = 2;
+
+    /** Maximum query length
+     * (default for dialer_nearby_places_max_query_len) */
+    private static final int MAX_QUERY_LEN = 50;
+
+    /** Radius (in miles)
+     * (default for dialer_nearby_places_directory_radius_meters) */
+    private static final int RADIUS = 1000;
+
+    /** User agent string */
+    private String mUserAgent = "";
+
+    public GoogleForwardLookup(Context context) {
+        StringBuilder sb = new StringBuilder("GoogleDialer ");
+        try {
+            sb.append(context.getPackageManager().getPackageInfo(
+                    context.getPackageName(), 0).versionName);
+            sb.append(" ");
+            sb.append(Build.FINGERPRINT);
+            mUserAgent = sb.toString();
+        } catch (PackageManager.NameNotFoundException e) {
+        }
+    }
+
+    @Override
+    public ForwardLookupDetails[] lookup(Context context,
+            String filter, Location lastLocation) {
+        int length = filter.length();
+
+        if (length >= MIN_QUERY_LEN) {
+            if (length > MAX_QUERY_LEN) {
+                filter = filter.substring(0, MAX_QUERY_LEN);
+            }
+
+            try {
+                Uri.Builder builder = Uri.parse(
+                        rewriteUrl(context, LOOKUP_URL)).buildUpon();
+
+                // Query string
+                builder = builder.appendQueryParameter(QUERY_FILTER, filter);
+
+                // Language
+                builder = builder.appendQueryParameter(QUERY_LANGUAGE,
+                        context.getResources().getConfiguration()
+                        .locale.getLanguage());
+
+                // Location (latitude and longitude)
+                builder = builder.appendQueryParameter(QUERY_LOCATION,
+                        String.format("%f,%f",
+                                lastLocation.getLatitude(),
+                                lastLocation.getLongitude()));
+
+                // Radius distance
+                builder = builder.appendQueryParameter(QUERY_RADIUS,
+                        Integer.toString(RADIUS));
+
+                // Random string (not really required)
+                builder = builder.appendQueryParameter(QUERY_RANDOM,
+                        getRandomNoiseString());
+
+                String httpResponse = httpGetRequest(
+                        builder.build().toString());
+
+                JSONArray results = new JSONArray(httpResponse);
+
+                Log.v(TAG, "Results: " + results);
+
+                return getEntries(results);
+            } catch (IOException e) {
+                Log.e(TAG, "Failed to execute query", e);
+            } catch (JSONException e) {
+                Log.e(TAG, "JSON error", e);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Parse JSON results and return them as an array of ForwardLookupDetails
+     *
+     * @param results The JSON results returned from the server
+     * @return Array of ForwardLookupDetails containing the result information
+     */
+    private ForwardLookupDetails[] getEntries(JSONArray results)
+            throws JSONException {
+        ArrayList<ForwardLookupDetails> details =
+                new ArrayList<ForwardLookupDetails>();
+
+        JSONArray entries = results.getJSONArray(1);
+
+        for (int i = 0; i < entries.length(); i++) {
+            ForwardLookupDetails fld = new ForwardLookupDetails();
+
+            try {
+                JSONArray entry = entries.getJSONArray(i);
+
+                String displayName = decodeHtml(entry.getString(0));
+
+                JSONObject params = entry.getJSONObject(3);
+
+                String phoneNumber = decodeHtml(
+                        params.getString(RESULT_NUMBER));
+
+                // Google uses the city instead of the address
+                //String address = decodeHtml(params.getString(RESULT_ADDRESS));
+                String address = decodeHtml(params.getString(RESULT_CITY));
+
+                String profileUrl = params.optString(RESULT_WEBSITE, null);
+                String photoUri = params.optString(RESULT_PHOTO_URI, null);
+
+                String distance = params.optString(RESULT_DISTANCE, null);
+
+                fld.setDisplayName(displayName);
+                fld.setPhoneNumber(phoneNumber);
+                fld.setAddress(address);
+                fld.setWebsite(profileUrl);
+                fld.setPhotoUri(photoUri);
+                fld.setDistance(distance);
+
+                details.add(fld);
+            } catch (JSONException e) {
+                Log.e(TAG, "Skipping the suggestions at index " + i, e);
+            }
+        }
+
+        if (details.size() > 0) {
+            return details.toArray(new ForwardLookupDetails[details.size()]);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Rewrite URL (eg. if a website has been moved)
+     *
+     * @param context A valid context
+     * @param url Original URL
+     * @return New URL
+     */
+    private String rewriteUrl(Context context, String url) throws IOException {
+        UrlRules.Rule rule = UrlRules.getRules(
+                context.getContentResolver()).matchRule(url);
+        String newUrl = rule.apply(url);
+
+        if (newUrl == null) {
+            Log.w(TAG, "Blocked by " + rule.mName + ": " + url);
+            throw new IOException("Blocked by rule: " + rule.mName);
+        }
+
+        Log.v(TAG, "Rule " + rule.mName + ": " + url + " -> " + newUrl);
+        return newUrl;
+    }
+
+    /**
+     * Generate a random string of alphanumeric characters of length [4, 36)
+     *
+     * @return Random alphanumeric string
+     */
+    private String getRandomNoiseString() {
+        StringBuilder garbage = new StringBuilder();
+
+        int length = getRandomInteger(32) + 4;
+
+        for (int i = 0; i < length; i++) {
+            int asciiCode;
+
+            if (Math.random() >= 0.3) {
+                if (Math.random() <= 0.5) {
+                    // Lowercase letters
+                    asciiCode = getRandomInteger(26) + 97;
+                } else {
+                    // Uppercase letters
+                    asciiCode = getRandomInteger(26) + 65;
+                }
+            } else {
+                // Numbers
+                asciiCode = getRandomInteger(10) + 48;
+            }
+
+            garbage.append(Character.toString((char) asciiCode));
+        }
+
+        return garbage.toString();
+    }
+
+    /**
+     * Generate number in the range [0, max).
+     *
+     * @param max Upper limit (non-inclusive)
+     * @return Random number inside [0, max)
+     */
+    private int getRandomInteger(int max) {
+        return (int) Math.floor(Math.random() * max);
+    }
+
+    /**
+     * Fetch a URL and return the response as a string encoded in either
+     * UTF-8 or the charset specified in the Content-Type header.
+     *
+     * @param url URL
+     * @return Response from server
+     */
+    private String httpGetRequest(String url) throws IOException {
+        HttpClient client = new DefaultHttpClient();
+        HttpGet request = new HttpGet(url.toString());
+
+        request.setHeader("User-Agent", mUserAgent);
+
+        HttpResponse response = client.execute(request);
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        response.getEntity().writeTo(out);
+
+        String charset = getCharsetFromContentType(
+                response.getEntity().getContentType().getValue());
+
+        return new String(out.toByteArray(), charset);
+    }
+
+    /**
+     * Extract the content encoding from the HTTP 'Content-Type' header.
+     *
+     * @param contentType The 'Content-Type' header
+     * @return The charset or "UTF-8"
+     */
+    private static String getCharsetFromContentType(String contentType) {
+        String[] split = contentType.split(";");
+
+        for (int i = 0; i < split.length; i++) {
+            String trimmed = split[i].trim();
+            if (trimmed.startsWith("charset=")) {
+                return trimmed.substring(8);
+            }
+        }
+
+        return "UTF-8";
+    }
+
+    /**
+     * Convert HTML to unformatted plain text.
+     *
+     * @param s HTML content
+     * @return Unformatted plain text
+     */
+    private String decodeHtml(String s) {
+        return Html.fromHtml(s).toString();
+    }
+}
diff --git a/src/com/android/dialer/lookup/google/GoogleLookupJsonParser.java b/src/com/android/dialer/lookup/google/GoogleLookupJsonParser.java
new file mode 100644
index 0000000..150b681
--- /dev/null
+++ b/src/com/android/dialer/lookup/google/GoogleLookupJsonParser.java
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.google;
+
+import com.android.dialer.lookup.ReverseLookup.ContactBuilder;
+import com.android.incallui.service.PhoneNumberServiceImpl;
+
+import com.google.common.collect.ImmutableMap;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
+import android.provider.ContactsContract.DisplayNameSources;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/* The JSON schema (not yet complete)
+{
+    "type": "object",
+    "$schema": "http://json-schema.org/draft-03/schema",
+    "id": "http://jsonschema.net",
+    "required": true,
+    "properties": {
+        "items": {
+            "type": "array",
+            "id": "http://jsonschema.net/items",
+            "required": false,
+            "items": {
+                "type": "object",
+                "id": "http://jsonschema.net/items/0",
+                "required": false,
+                "properties": {
+                    "addresses": {
+                        "type": "array",
+                        "id": "http://jsonschema.net/items/0/addresses",
+                        "required": false,
+                        "items": {
+                            "type": "object",
+                            "id": "http://jsonschema.net/items/0/addresses/0",
+                            "required": false,
+                            "properties": {
+                                "value": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/addresses/0/value",
+                                    "required": false
+                                }
+                            }
+                        }
+                    },
+                    "metadata": {
+                        "type": "object",
+                        "id": "http://jsonschema.net/items/0/metadata",
+                        "required": false,
+                        "properties": {
+                            "objectType": {
+                                "type": "string",
+                                "id": "http://jsonschema.net/items/0/metadata/objectType",
+                                "required": false
+                            },
+                            "plusPageType": {
+                                "type": "string",
+                                "id": "http://jsonschema.net/items/0/metadata/plusPageType",
+                                "required": false
+                            }
+                        }
+                    },
+                    "names": {
+                        "type": "array",
+                        "id": "http://jsonschema.net/items/0/names",
+                        "required": false,
+                        "items": {
+                            "type": "object",
+                            "id": "http://jsonschema.net/items/0/names/0",
+                            "required": false,
+                            "properties": {
+                                "displayName": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/names/0/displayName",
+                                    "required": false
+                                },
+                                "familyName": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/names/0/familyName",
+                                    "required": false
+                                },
+                                "givenName": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/names/0/givenName",
+                                    "required": false
+                                },
+                                "metadata": {
+                                    "type": "object",
+                                    "id": "http://jsonschema.net/items/0/names/0/metadata",
+                                    "required": false,
+                                    "properties": {
+                                        "container": {
+                                            "type": "string",
+                                            "id": "http://jsonschema.net/items/0/names/0/metadata/container",
+                                            "required": false
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    },
+                    "phoneNumbers": {
+                        "type": "array",
+                        "id": "http://jsonschema.net/items/0/phoneNumbers",
+                        "required": false,
+                        "items": {
+                            "type": "object",
+                            "id": "http://jsonschema.net/items/0/phoneNumbers/0",
+                            "required": false,
+                            "properties": {
+                                "formattedType": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/phoneNumbers/0/formattedType",
+                                    "required": false
+                                },
+                                "type": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/phoneNumbers/0/type",
+                                    "required": false
+                                },
+                                "value": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/phoneNumbers/0/value",
+                                    "required": false
+                                }
+                            }
+                        }
+                    },
+                    "urls": {
+                        "type": "array",
+                        "id": "http://jsonschema.net/items/0/urls",
+                        "required": false,
+                        "items": {
+                            "type": "object",
+                            "id": "http://jsonschema.net/items/0/urls/0",
+                            "required": false,
+                            "properties": {
+                                "value": {
+                                    "type": "string",
+                                    "id": "http://jsonschema.net/items/0/urls/0/value",
+                                    "required": false
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "kind": {
+            "type": "string",
+            "id": "http://jsonschema.net/kind",
+            "required": false
+        }
+    }
+}
+ */
+
+public final class GoogleLookupJsonParser {
+    private static final String TAG =
+            GoogleLookupJsonParser.class.getSimpleName();
+
+    private GoogleLookupJsonParser() {
+    }
+
+    /** Map address fields to the respective fields in StructuredPostal */
+    private static final Map<String, Integer> ADDRESS_TYPE_MAP =
+            new ImmutableMap.Builder<String, Integer>()
+            .put("home", StructuredPostal.TYPE_HOME)
+            .put("work", StructuredPostal.TYPE_WORK)
+            .put("other", StructuredPostal.TYPE_OTHER)
+            .build();
+
+    /** Unused */
+    private static final Map<String, Integer> PHONE_TYPE_MAP =
+            new ImmutableMap.Builder<String, Integer>()
+            .put("home", Phone.TYPE_HOME)
+            .put("work", Phone.TYPE_WORK)
+            .put("mobile", Phone.TYPE_MOBILE)
+            .put("homeFax", Phone.TYPE_FAX_HOME)
+            .put("workFax", Phone.TYPE_FAX_WORK)
+            .put("otherFax", Phone.TYPE_OTHER_FAX)
+            .put("pager", Phone.TYPE_PAGER)
+            .put("workMobile", Phone.TYPE_WORK_MOBILE)
+            .put("workPager", Phone.TYPE_WORK_PAGER)
+            .put("main", Phone.TYPE_MAIN)
+            .put("googleVoice", Phone.TYPE_CUSTOM)
+            .put("other", Phone.TYPE_OTHER)
+            .build();
+
+    /**
+     * Parse JSON data from phone number lookup.
+     *
+     * @param json The JSON data
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param photoUrl The URL to the image
+     * @return The phone number info object
+     */
+    public static PhoneNumberServiceImpl.PhoneNumberInfoImpl
+            parsePeopleJson(String json, String normalizedNumber,
+            String formattedNumber, String photoUrl) {
+        try {
+            JSONObject peopleList = new JSONObject(json);
+
+            String kind = peopleList.getString("kind");
+            if (!"plus#peopleList".equals(kind)) {
+                Log.e(TAG, "The value of 'kind' is not recognized: " + kind
+                        + "JSON: " + peopleList);
+                return null;
+            }
+
+            JSONObject item = getArrayItem(peopleList, "items");
+            if (item != null) {
+                return parseContactJson(item, normalizedNumber,
+                        formattedNumber, photoUrl);
+            }
+        } catch (JSONException e) {
+            Log.e(TAG, "Failed to parse JSON: " + json, e);
+        }
+        return null;
+    }
+
+    /**
+     * Parse item object from the number lookup JSON data.
+     *
+     * @param item The JSON data representing the item
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param photoUrl The URL to the image
+     * @return The phone number info object
+     */
+    private static PhoneNumberServiceImpl.PhoneNumberInfoImpl
+            parseContactJson(JSONObject item, String normalizedNumber,
+            String formattedNumber, String photoUrl) throws JSONException {
+        // The metadata object contains information on what
+        JSONObject metadata = item.optJSONObject("metadata");
+
+        // Whether the item represents a person
+        boolean personItem = true;
+
+        // TODO: Unknown
+        String[] attributions = null;
+        if (metadata != null) {
+            personItem = isPersonItem(metadata);
+            attributions = getArrayOfStrings(metadata, "attributions");
+        }
+
+        Integer displayNameSource = personItem
+                ? DisplayNameSources.STRUCTURED_NAME
+                : DisplayNameSources.ORGANIZATION;
+        String number = formattedNumber != null
+                ? formattedNumber : normalizedNumber;
+        int type = personItem ? Phone.TYPE_MOBILE : Phone.TYPE_MAIN;
+
+        ContactBuilder builder = new ContactBuilder(
+                normalizedNumber, formattedNumber);
+
+        // List of names of the person or place
+        JSONObject names = getArrayItem(item, "names");
+
+        if (names != null) {
+            ContactBuilder.Name n = getNameObject(names);
+            builder.setName(n);
+        }
+
+        // Find 'phoneNumbers' object matching the number if it exists
+        JSONObject phoneObject = findPhoneObject(item, normalizedNumber);
+
+        String label = null;
+        if (phoneObject != null) {
+            number = phoneObject.getString("value");
+
+            String typeStr = phoneObject.getString("type");
+            String formattedType =
+                    phoneObject.optString("formattedType", null);
+            Integer typeInt = PHONE_TYPE_MAP.get(type);
+
+            type = typeInt;
+
+            if (typeInt != null && typeInt != Phone.TYPE_CUSTOM) {
+                label = null;
+            } else {
+                label = formattedType;
+            }
+        }
+
+        ContactBuilder.PhoneNumber pn = new ContactBuilder.PhoneNumber();
+        pn.number = number;
+        pn.type = type;
+        pn.label = label;
+        builder.addPhoneNumber(pn);
+
+        String photoUri = null;
+        if (attributions == null) {
+            if (!personItem) {
+                ContactBuilder.Address a = getAddressObject(item);
+                builder.addAddress(a);
+
+                ContactBuilder.WebsiteUrl[] websites = getWebsiteObjects(item);
+                for (int i = 0; i < websites.length; i++) {
+                    builder.addWebsite(websites[i]);
+                }
+            }
+
+            photoUri = getFirstImageUrl(item, photoUrl);
+        }
+
+        if (!personItem && photoUri == null) {
+            photoUri = ContactBuilder.PHOTO_URI_BUSINESS;
+        }
+
+        builder.setDisplayNameSource(displayNameSource);
+        builder.setPhotoUri(photoUri);
+        builder.setIsBusiness(!personItem);
+
+        return builder.build();
+    }
+
+    /**
+     * Check if item represents a person.
+     *
+     * @param metadata The JSON 'metadata' object
+     * @return Whether the item represents a person
+     */
+    private static boolean isPersonItem(JSONObject metadata)
+            throws JSONException {
+        String type = metadata.optString("objectType", null);
+        return type == null || !type.equals("page");
+    }
+
+    /**
+     * Get names from the 'names' JSON object of a lookup item.
+     *
+     * @param names The JSON object containing the names
+     * @return Name object containing the names
+     */
+    private static ContactBuilder.Name getNameObject(JSONObject names) {
+        ContactBuilder.Name n = new ContactBuilder.Name();
+        n.displayName = names.optString("displayName", null);
+        n.givenName = names.optString("givenName", null);
+        n.familyName = names.optString("familyName", null);
+        n.prefix = names.optString("honorificPrefix", null);
+        n.middleName = names.optString("middleName", null);
+        n.suffix = names.optString("honorificSuffix", null);
+        n.phoneticGivenName = names.optString("phoneticGivenName", null);
+        n.phoneticFamilyName = names.optString("phoneticFamilyName", null);
+        return n;
+    }
+
+    /**
+     * Get addresses from the JSON object of a lookup item.
+     *
+     * @param item The JSON object representing a lookup item
+     * @return Address object containing the addresses
+     */
+    public static ContactBuilder.Address getAddressObject(
+            JSONObject item) throws JSONException {
+        // Get address from JSON
+        JSONObject addresses = getArrayItem(item, "addresses");
+        if (addresses == null) {
+            return null;
+        }
+
+        String address = addresses.getString("value");
+
+        String type = addresses.optString("type", null);
+        String formattedType = addresses.optString("formattedType", null);
+
+        ContactBuilder.Address a = new ContactBuilder.Address();
+        a.formattedAddress = address;
+
+        if (type != null) {
+            Integer typeInt = ADDRESS_TYPE_MAP.get(type);
+            a.type = typeInt;
+
+            if (typeInt != null && typeInt != StructuredPostal.TYPE_CUSTOM) {
+                a.label = null;
+            } else {
+                a.label = formattedType;
+            }
+        }
+
+        return a;
+    }
+
+    /**
+     * Get website URLs from the JSON object of a lookup item.
+     *
+     * @param item The JSON object representing a lookup item
+     * @return WebsiteUrl objects containing the URLs
+     */
+    private static ContactBuilder.WebsiteUrl[] getWebsiteObjects(
+            JSONObject item) throws JSONException {
+        // Get URLs from JSON
+        JSONArray urls = item.optJSONArray("urls");
+
+        if (urls == null) {
+            return null;
+        }
+
+        ArrayList<ContactBuilder.WebsiteUrl> websites =
+                new ArrayList<ContactBuilder.WebsiteUrl>();
+
+        for (int i = 0; i < urls.length(); i++) {
+            ContactBuilder.WebsiteUrl w = new ContactBuilder.WebsiteUrl();
+            w.url = urls.getJSONObject(i).getString("value");
+            websites.add(w);
+        }
+
+        if (websites.size() > 0) {
+            return websites.toArray(
+                    new ContactBuilder.WebsiteUrl[websites.size()]);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Find JSON object containing the phone number.
+     *
+     * @param json The JSON object to find the phone number in
+     * @param normalizedNumber The phone number to find
+     * @return The JSON object containing the phone number
+     */
+    public static JSONObject findPhoneObject(JSONObject json,
+            String normalizedNumber) throws JSONException {
+        JSONArray phoneNumbers = json.optJSONArray("phoneNumbers");
+
+        if (phoneNumbers != null) {
+            for (int i = 0; i < phoneNumbers.length(); i++) {
+                JSONObject phoneNumber = phoneNumbers.getJSONObject(i);
+
+                if (phoneNumber != null && normalizedNumber.equals(
+                        phoneNumber.optString("canonicalizedForm", null))) {
+                    return phoneNumber;
+                }
+            }
+
+            return null;
+        }
+
+        return null;
+    }
+
+    /**
+     * Get the URL of the first photo that is not the photoUrl parameter.
+     *
+     * @param json The JSON object representing the contact
+     * @param photoUrl The photo's URL
+     * @return The URL of the first photo that is not photoUrl
+     */
+    private static String getFirstImageUrl(JSONObject json, String photoUrl)
+            throws JSONException {
+        JSONArray images = json.optJSONArray("images");
+
+        if (images != null) {
+            String ret = null;
+
+            for (int i = 0; i < images.length(); i++) {
+                JSONObject image = images.getJSONObject(i);
+                if (image != null) {
+                    JSONObject metadata = image.optJSONObject("metadata");
+                    if (metadata == null
+                            || !"contact".equals(metadata.optString("container"))) {
+                        String url = image.optString("url", null);
+                        if (!TextUtils.isEmpty(url)) {
+                            if (!url.startsWith(photoUrl)) {
+                                return url;
+                            }
+
+                            ret = url;
+                        }
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        return null;
+    }
+
+    /**
+     * Find JSON array from a JSON object and get first element.
+     *
+     * @param json The JSON object containing the JSON array
+     * @param name The name of the JSON array
+     * @return The first element of the JSON array
+     */
+    public static JSONObject getArrayItem(JSONObject json, String name)
+            throws JSONException {
+        JSONArray array = json.optJSONArray(name);
+
+        if (array == null || array.length() == 0) {
+            return null;
+        }
+
+        return array.getJSONObject(0);
+    }
+
+    /**
+     * Find a JSON array and return its strings as a string array.
+     *
+     * @param json The JSON object containing the JSON array
+     * @param name The name of the JSON array
+     * @return The string array containing the strings
+     */
+    public static String[] getArrayOfStrings(JSONObject json, String name)
+            throws JSONException {
+        JSONArray array = json.optJSONArray(name);
+
+        String[] ret;
+
+        if (array == null || array.length() == 0) {
+            ret = null;
+        } else {
+            ret = new String[array.length()];
+            for (int i = 0; i < array.length(); i++) {
+                ret[i] = array.getString(i);
+            }
+        }
+
+        return ret;
+    }
+}
diff --git a/src/com/android/dialer/lookup/google/GoogleReverseLookup.java b/src/com/android/dialer/lookup/google/GoogleReverseLookup.java
new file mode 100644
index 0000000..723c534
--- /dev/null
+++ b/src/com/android/dialer/lookup/google/GoogleReverseLookup.java
@@ -0,0 +1,446 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.google;
+
+import com.android.dialer.lookup.ReverseLookup;
+import com.android.incallui.service.PhoneNumberServiceImpl.PhoneNumberInfoImpl;
+import com.android.services.telephony.common.MoreStrings;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.content.Context;
+import android.graphics.Point;
+import android.net.Uri;
+import android.util.Log;
+import android.util.Pair;
+import android.view.WindowManager;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.HashMap;
+
+public class GoogleReverseLookup extends ReverseLookup {
+    private static final String TAG =
+            GoogleReverseLookup.class.getSimpleName();
+
+    private static final boolean DEBUG = false;
+    private static final String DEBUG_URL =
+            "http://10.8.8.228:8000/plus/v2whitelisted/people/lookup";
+
+    // Maximum number of Google accounts to use for lookups
+    private static final int MAX_ACCOUNTS = 3;
+
+    // There is currently no user agent restrictions, but that could
+    // potentially change
+    private static final String USER_AGENT =
+            "Dalvik/1.6.0 (Linux; U; Android 4.4.2; Nexus 5 Build/KOT49H)";
+
+    /** OAuth2 scope for obtaining token for doing a phone number lookup */
+    private static final String SCOPES = "oauth2:" +
+            "https://www.googleapis.com/auth/plus.me" + " " +
+            "https://www.googleapis.com/auth/plus.peopleapi.readwrite";
+
+    /** OAuth2 cope for obtaining token to download images */
+    private static final String IMAGE_SCOPES = "oauth2:" +
+            "https://www.googleapis.com/auth/plus.contactphotos";
+
+    private static final String LOOKUP_URL =
+            "https://www.googleapis.com/plus/v2whitelisted/people/lookup";
+
+    private static final String PHOTO_URL =
+            "https://plus.google.com/_/focus/photos/private";
+
+    private static HashMap<String, String> mTokens
+            = new HashMap<String, String>();
+    private static HashMap<String, String> mImageTokens
+            = new HashMap<String, String>();
+
+    private static class AuthException extends Exception {
+        public AuthException(String msg) {
+            super(msg);
+        }
+    }
+
+    public GoogleReverseLookup(Context context) {
+    }
+
+    /**
+     * Get OAuth2 access token for performing the reverse lookup.
+     *
+     * @param context The application context
+     * @param account The Google account
+     * @return The OAuth2 access token
+     */
+    private static synchronized String getToken(
+            Context context, Account account) {
+        if (account == null) {
+            return null;
+        }
+
+        String token = null;
+
+        try {
+            token = mTokens.get(account.name);
+            if (token == null) {
+                token = GoogleAuth.getInstance(context)
+                        .getToken(account, SCOPES);
+                if (token != null) {
+                    mTokens.put(account.name, token);
+                }
+            }
+        } finally {
+        }
+
+        return token;
+    }
+
+    /**
+     * Get OAuth2 access token for downloading contact images.
+     *
+     * @param context The application context
+     * @param account The Google account
+     * @return The OAuth2 access token
+     */
+    private static synchronized String getImageToken(
+            Context context, Account account) {
+        if (account == null) {
+            return null;
+        }
+
+        String token = null;
+
+        try {
+            token = mImageTokens.get(account.name);
+            if (token == null) {
+                token = GoogleAuth.getInstance(context)
+                        .getToken(account, IMAGE_SCOPES);
+                if (token != null) {
+                    mImageTokens.put(account.name, token);
+                }
+            }
+        } finally {}
+
+        return token;
+    }
+
+    /**
+     * Invalidate an OAuth2 access token for reverse lookup.
+     *
+     * @param context The application context
+     * @param account The Google account
+     */
+    private static synchronized void invalidateToken(
+            Context context, Account account) {
+        GoogleAuth.getInstance(context).invalidateToken(
+                mTokens.get(account.name));
+        mTokens.remove(account.name);
+    }
+
+    /**
+     * Invalidate an OAuth2 access token for contact image downloads.
+     *
+     * @param context The application context
+     * @param account The Google account
+     */
+    private static synchronized void invalidateImageToken(
+            Context context, Account account) {
+        GoogleAuth.getInstance(context).invalidateToken(
+                mImageTokens.get(account.name));
+        mImageTokens.remove(account.name);
+    }
+
+    /**
+     * Remove personally identifiable information from a URL
+     *
+     * @param url Original URL
+     * @return New URL with personal information replaced with dummy text
+     */
+    private static String obfuscateUrl(String url) {
+        Uri uri = Uri.parse(url);
+        Uri.Builder builder = new Uri.Builder();
+
+        builder.scheme(uri.getScheme());
+        builder.encodedAuthority(uri.getEncodedAuthority());
+        builder.path(uri.getPath());
+
+        for (String name : uri.getQueryParameterNames()) {
+            String value = uri.getQueryParameter(name);
+
+            if (name.equals("access_token")) {
+                builder.appendQueryParameter(name, "token");
+            } else if (name.equals("id")) {
+                builder.appendQueryParameter(name,
+                        MoreStrings.toSafeString(value));
+            } else {
+                builder.appendQueryParameter(name, value);
+            }
+        }
+
+        return builder.toString();
+    }
+
+    /**
+     * Perform an HTTP GET request and return the result as a string.
+     *
+     * @param context The application context
+     * @param request The URL
+     * @param token The OAuth2 access token
+     * @return The byte array containing the response
+     */
+    private static byte[] httpGetRequest(Context context, String url,
+            String token) throws IOException, AuthException {
+        if (url == null) {
+            throw new NullPointerException("URL is null");
+        }
+
+        // Rewrite the URL if needed (domain change, etc.)
+        String rewrittenUrl = UrlRules.getRules(context.getContentResolver())
+                .matchRule(url).apply(url);
+
+        if (rewrittenUrl == null) {
+            Log.d(TAG, "URL is blocked. Ignoring request: " + obfuscateUrl(url));
+            return null;
+        }
+
+        if (!rewrittenUrl.equals(url)) {
+            Log.d(TAG, "Original URL: " + obfuscateUrl(url));
+            Log.d(TAG, "Rewritten URL: " + obfuscateUrl(rewrittenUrl));
+        } else {
+            Log.d(TAG, "Original and rewritten URL are identical.");
+        }
+
+        Log.e(TAG, "Fetching " + obfuscateUrl(rewrittenUrl));
+
+        HttpClient client = new DefaultHttpClient();
+        HttpGet request = new HttpGet(rewrittenUrl);
+
+        request.setHeader("User-Agent", USER_AGENT);
+
+        // Set authentication token
+        if (token != null) {
+            request.setHeader("Authorization", "Bearer " + token);
+        }
+
+        HttpResponse response = client.execute(request);
+
+        int responseCode = response.getStatusLine().getStatusCode();
+        Log.d(TAG, "HTTP response code: " + responseCode);
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        response.getEntity().writeTo(out);
+        byte[] responseBytes = out.toByteArray();
+
+        if (responseCode == HttpStatus.SC_OK) {
+            if (DEBUG) Log.d(TAG, "Response:\n" + new String(responseBytes));
+            return responseBytes;
+        } else if (responseCode == HttpStatus.SC_UNAUTHORIZED) {
+            Log.e(TAG, "Invalid response:\n" + new String(responseBytes));
+            throw new AuthException("Failed to authenticate");
+        }
+
+        return null;
+    }
+
+    /**
+     * Lookup image
+     *
+     * @param context The application context
+     * @param url The image URL
+     * @param data Extra data (a authentication token, perhaps)
+     */
+    @Override
+    public byte[] lookupImage(Context context, String url, Object data) {
+        Account account = (Account) data;
+
+        String token = null;
+        if (url.startsWith(PHOTO_URL)) {
+            token = getImageToken(context, account);
+            if (token == null) {
+                Log.e(TAG, "Failed to get token");
+            }
+        }
+
+        Uri uri = Uri.parse(url);
+        Uri.Builder builder = new Uri.Builder();
+
+        builder.scheme(uri.getScheme());
+        builder.encodedAuthority(uri.getEncodedAuthority());
+        builder.path(uri.getPath());
+
+        WindowManager wm = (WindowManager)
+                context.getSystemService(Context.WINDOW_SERVICE);
+        Point p = new Point();
+        wm.getDefaultDisplay().getSize(p);
+
+        // Screen width
+        builder.appendQueryParameter("sz", Integer.toString(p.x / 2));
+
+        // Try twice
+        int maxTries = 2;
+
+        for (int i = 0; i < maxTries; i++) {
+            try {
+                return httpGetRequest(context, builder.toString(), token);
+            } catch (AuthException e) {
+                Log.e(TAG, "Tried " + (i + 1) + " times, " +
+                        "but failed to authenticate for image lookup");
+                if (i < maxTries - 1) {
+                    invalidateImageToken(context, account);
+                    Log.e(TAG, "Invalidating token and trying again ...");
+                }
+            } catch (IOException e) {
+                Log.e(TAG, "Failed to download image.", e);
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Perform phone number lookup.
+     *
+     * @param context The application context
+     * @param account The Google account
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param includePlaces Whether places should be queried
+     * @param isIncoming Whether the call is incoming or outgoing
+     * @return The phone number info object
+     */
+    private PhoneNumberInfoImpl lookupNumberInternal(
+            Context context, Account account,
+            String normalizedNumber, String formattedNumber,
+            boolean includePlaces, boolean isIncoming) {
+        if (normalizedNumber == null) {
+            throw new NullPointerException();
+        }
+        if (account == null) {
+            throw new NullPointerException();
+        }
+
+        // Try twice
+        int maxTries = 2;
+
+        for (int i = 0; i < maxTries; i++) {
+            try {
+                String token = getToken(context, account);
+
+                if (token != null) {
+                    Uri uri = Uri.parse(DEBUG ? DEBUG_URL : LOOKUP_URL);
+                    Uri.Builder builder = new Uri.Builder();
+
+                    builder.scheme(uri.getScheme());
+                    builder.encodedAuthority(uri.getEncodedAuthority());
+                    builder.path(uri.getPath());
+
+                    // The caller function loops through all available Google accounts.
+                    // This is set to false after the first account to avoid duplicate
+                    // place entries.
+                    if (includePlaces) {
+                        builder.appendQueryParameter("includePlaces", "1");
+                    }
+
+                    builder.appendQueryParameter("includePeople", "1");
+                    builder.appendQueryParameter("includeGal", "1");
+                    builder.appendQueryParameter("type", "phone");
+                    builder.appendQueryParameter("fields",
+                            "kind," +
+                            "items(metadata(objectType,plusPageType,attributions)," +
+                            "names," +
+                            "phoneNumbers(value,type,formattedType,canonicalizedForm)," +
+                            "addresses(value,type,formattedType)," +
+                            "images(url,metadata(container))," +
+                            "urls(value))");
+
+                    builder.appendQueryParameter("callType",
+                            isIncoming ? "incoming" : "outgoing");
+                    builder.appendQueryParameter("id", normalizedNumber);
+
+                    String json = new String(httpGetRequest(
+                            context, builder.toString(), token));
+
+                    if (json == null) {
+                        return null;
+                    } else {
+                        return GoogleLookupJsonParser.parsePeopleJson(json,
+                                normalizedNumber, formattedNumber, PHOTO_URL);
+                    }
+                }
+            } catch (AuthException e) {
+                Log.e(TAG, "Tried " + (i + 1) + " times, " +
+                        "but failed to authenticate for number lookup");
+                if (i < maxTries - 1) {
+                    invalidateToken(context, account);
+                    Log.e(TAG, "Invalidating token and trying again ...");
+                }
+            } catch (IOException e) {
+                Log.e(TAG, "Failed to lookup phone number", e);
+                return null;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Perform phone number lookup.
+     *
+     * @param context The application context
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param isIncoming Whether the call is incoming or outgoing
+     * @return The phone number info object
+     */
+    @Override
+    public Pair<PhoneNumberInfoImpl, Object> lookupNumber(
+            Context context, String normalizedNumber, String formattedNumber,
+            boolean isIncoming) {
+        Account[] accounts = AccountManager.get(context)
+                .getAccountsByType("com.google");
+        if (accounts.length == 0) {
+            Log.d(TAG, "No Google accounts found. Skipping reverse lookup.");
+            return null;
+        }
+
+        boolean includePlaces = true;
+
+        PhoneNumberInfoImpl numberInfo = null;
+        Account account = null;
+
+        for (int i = 0; i < accounts.length && i < MAX_ACCOUNTS; i++) {
+            account = accounts[i];
+            numberInfo = lookupNumberInternal(context, accounts[i],
+                    normalizedNumber, formattedNumber, includePlaces,
+                    isIncoming);
+
+            if (numberInfo != null && numberInfo.getDisplayName() != null) {
+                break;
+            }
+
+            // Include places only once to avoid duplicates
+            includePlaces = false;
+        }
+
+        return Pair.create(numberInfo, (Object) account);
+    }
+}
diff --git a/src/com/android/dialer/lookup/google/Gservices.java b/src/com/android/dialer/lookup/google/Gservices.java
new file mode 100644
index 0000000..12b53cc
--- /dev/null
+++ b/src/com/android/dialer/lookup/google/Gservices.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.google;
+
+import android.content.ContentResolver;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+import java.util.TreeMap;
+
+/**
+ * Gservices provides access to a key-value store that is can be
+ * updated remote (by the google checkin service).
+ */
+public final class Gservices {
+    public static final String TAG = Gservices.class.getSimpleName();
+
+    public static final Uri CONTENT_URI =
+        Uri.parse("content://com.google.android.gsf.gservices");
+    public static final Uri CONTENT_PREFIX_URI =
+        Uri.parse("content://com.google.android.gsf.gservices/prefix");
+
+    public static final Pattern TRUE_PATTERN =
+        Pattern.compile("^(1|true|t|on|yes|y)$", Pattern.CASE_INSENSITIVE);
+    public static final Pattern FALSE_PATTERN =
+        Pattern.compile("^(0|false|f|off|no|n)$", Pattern.CASE_INSENSITIVE);
+
+    private static HashMap<String, String> sCache;
+    private static Object sVersionToken;
+    private static String[] sPreloadedPrefixes = new String[0];
+
+    private Gservices() {
+    }
+
+    public static synchronized void bulkCacheByPrefix(
+            ContentResolver resolver, String... prefixes) {
+        Map<String, String> stringsByPrefix = getStringsByPrefix(resolver, prefixes);
+        ensureCacheInitializedLocked(resolver);
+        sPreloadedPrefixes = prefixes;
+        for (Map.Entry<String, String> entry : stringsByPrefix.entrySet()) {
+            sCache.put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    private static void ensureCacheInitializedLocked(final ContentResolver cr) {
+        if (sCache == null) {
+            sCache = new HashMap<String, String>();
+            sVersionToken = new Object();
+
+            // Create a thread to host a Handler for ContentObserver callbacks.
+            // The callback will clear the cache to force the resolver to be consulted
+            // on future gets. The version is also updated.
+            new Thread(TAG) {
+                public void run() {
+                    Looper.prepare();
+                    cr.registerContentObserver(CONTENT_URI, true,
+                        new ContentObserver(new Handler(Looper.myLooper())) {
+                            public void onChange(boolean selfChange) {
+                                synchronized (Gservices.class) {
+                                    sCache.clear();
+                                    sVersionToken = new Object();
+                                    if (sPreloadedPrefixes.length > 0) {
+                                        bulkCacheByPrefix(cr, sPreloadedPrefixes);
+                                    }
+                                }
+                            } });
+                    Looper.loop();
+                }
+            }.start();
+        }
+    }
+
+    /**
+     * Look up a key in the database.
+     * @param cr to access the database with
+     * @param key to look up in the table
+     * @param defValue the value to return if the value from the database is null
+     * @return the corresponding value, or defValue if not present
+     */
+    public static String getString(ContentResolver cr, String key, String defValue) {
+        final Object version;
+        synchronized (Gservices.class) {
+            ensureCacheInitializedLocked(cr);
+            version = sVersionToken;
+
+            if (sCache.containsKey(key)) {
+                String value = sCache.get(key);
+                return (value != null) ? value : defValue;
+            }
+        }
+
+        final String[] prefixes = sPreloadedPrefixes;
+        for (int i = 0; i < prefixes.length; i++) {
+            if (key.startsWith(prefixes[i])) {
+                return defValue;
+            }
+        }
+
+        Cursor cursor = cr.query(CONTENT_URI, null, null, new String[]{ key }, null);
+        if (cursor == null) return defValue;
+
+        try {
+            if (!cursor.moveToFirst()) {
+                sCache.put(key, null);
+                return defValue;
+            }
+            String value = cursor.getString(1);
+            synchronized (Gservices.class) {
+                // There is a chance that the version change, and thus the cache clearing,
+                // happened after the query, meaning the value we got could be stale. Don't
+                // store it in the cache in this case.
+                if (version == sVersionToken) {
+                    sCache.put(key, value);
+                }
+            }
+            return (value != null) ? value : defValue;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+    }
+
+    /**
+     * Look up a key in the database.
+     * @param cr to access the database with
+     * @param key to look up in the table
+     * @return the corresponding value, or null if not present
+     */
+    public static String getString(ContentResolver cr, String key) {
+        return getString(cr, key, null);
+    }
+
+    /**
+     * Look up the value for key in the database, convert it to an int
+     * using Integer.parseInt and return it. If it is null or if a
+     * NumberFormatException is caught during the conversion then
+     * return defValue.
+     */
+    public static int getInt(ContentResolver cr, String key, int defValue) {
+        String valString = getString(cr, key);
+        int value;
+        try {
+            value = valString != null ? Integer.parseInt(valString) : defValue;
+        } catch (NumberFormatException e) {
+            value = defValue;
+        }
+        return value;
+    }
+
+    /**
+     * Look up the value for key in the database, convert it to a long
+     * using Long.parseLong and return it. If it is null or if a
+     * NumberFormatException is caught during the conversion then
+     * return defValue.
+     */
+    public static long getLong(ContentResolver cr, String key, long defValue) {
+        String valString = getString(cr, key);
+        long value;
+        try {
+            value = valString != null ? Long.parseLong(valString) : defValue;
+        } catch (NumberFormatException e) {
+            value = defValue;
+        }
+        return value;
+    }
+
+    public static boolean getBoolean(ContentResolver cr, String key, boolean defValue) {
+        String valString = getString(cr, key);
+        if (valString == null || valString.equals("")) {
+            return defValue;
+        } else if (TRUE_PATTERN.matcher(valString).matches()) {
+            return true;
+        } else if (FALSE_PATTERN.matcher(valString).matches()) {
+            return false;
+        } else {
+            // Log a possible app bug
+            Log.w(TAG, "attempt to read gservices key " + key + " (value \"" +
+                  valString + "\") as boolean");
+            return defValue;
+        }
+    }
+
+    /**
+     * Look up values for all keys beginning with any of the given prefixes.
+     *
+     * @return a Map<String, String> of the matching key-value pairs.
+     */
+    public static Map<String, String> getStringsByPrefix(ContentResolver cr,
+                                                          String... prefixes) {
+        Cursor c = cr.query(CONTENT_PREFIX_URI, null, null, prefixes, null);
+        TreeMap<String, String> out = new TreeMap<String, String>();
+        if (c == null) return out;
+
+        try {
+            while (c.moveToNext()) {
+                out.put(c.getString(0), c.getString(1));
+            }
+        } finally {
+            c.close();
+        }
+        return out;
+    }
+
+    /**
+     * Returns a token that represents the current version of the data within gservices
+     * @param cr the ContentResolver that Gservices should use to fill its cache
+     * @return an Object that represents the current version of the Gservices values.
+     */
+    public static Object getVersionToken(ContentResolver cr) {
+        synchronized (Gservices.class) {
+            // Even though we don't need the cache itself, we need the cache version, so we make
+            // that the cache has been initialized before we return its version.
+            ensureCacheInitializedLocked(cr);
+            return sVersionToken;
+        }
+    }
+}
diff --git a/src/com/android/dialer/lookup/google/UrlRules.java b/src/com/android/dialer/lookup/google/UrlRules.java
new file mode 100644
index 0000000..5ed1d62
--- /dev/null
+++ b/src/com/android/dialer/lookup/google/UrlRules.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.google;
+
+import android.content.ContentResolver;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A set of rules rewriting and blocking URLs.  Used to offer a point of
+ * control for redirecting HTTP requests, often to the Android proxy server.
+ *
+ * <p>Each rule has the following format:
+ *
+ * <pre><em>url-prefix</em> [REWRITE <em>new-prefix</em>] [BLOCK]</pre>
+ *
+ * <p>Any URL which starts with <em>url-prefix</em> will trigger the rule.
+ * If BLOCK is specified, requests to that URL will be blocked and fail.
+ * If REWRITE is specified, the matching prefix will be removed and replaced
+ * with <em>new-prefix</em>.  (If both are specified, BLOCK wins.)  Case is
+ * insensitive for the REWRITE and BLOCK keywords, but sensitive for URLs.
+ *
+ * <p>In Gservices, the value of any key that starts with "url:" will be
+ * interpreted as a rule.  The full name of the key is unimportant (but can
+ * be used to document the intent of the rule, and must be unique).
+ * Example gservices keys:
+ *
+ * <pre>
+ * url:use_proxy_for_calendar = "http://www.google.com/calendar/ REWRITE http://android.clients.google.com/proxy/calendar/"
+ * url:stop_crash_reports = "http://android.clients.google.com/crash/ BLOCK"
+ * url:use_ssl_for_contacts = "http://www.google.com/m8/ REWRITE https://www.google.com/m8/"
+ * </pre>
+ */
+public class UrlRules {
+    /** Thrown when the rewrite rules can't be parsed. */
+    public static class RuleFormatException extends Exception {
+        public RuleFormatException(String msg) { super(msg); }
+    }
+
+    /** A single rule specifying actions for URLs matching a certain prefix. */
+    public static class Rule implements Comparable {
+        /** Name assigned to the rule (for logging and debugging). */
+        public final String mName;
+
+        /** Prefix required to match this rule. */
+        public final String mPrefix;
+
+        /** Text to replace mPrefix with (null to leave alone). */
+        public final String mRewrite;
+
+        /** True if matching URLs should be blocked. */
+        public final boolean mBlock;
+
+        /** Default rule that does nothing. */
+        public static final Rule DEFAULT = new Rule();
+
+        /** Parse a rewrite rule as given in a Gservices value. */
+        public Rule(String name, String rule) throws RuleFormatException {
+            mName = name;
+            String[] words = PATTERN_SPACE_PLUS.split(rule);
+            if (words.length == 0) throw new RuleFormatException("Empty rule");
+
+            mPrefix = words[0];
+            String rewrite = null;
+            boolean block = false;
+            for (int pos = 1; pos < words.length; ) {
+                String word = words[pos].toLowerCase();
+                if (word.equals("rewrite") && pos + 1 < words.length) {
+                    rewrite = words[pos + 1];
+                    pos += 2;
+                } else if (word.equals("block")) {
+                    block = true;
+                    pos += 1;
+                } else {
+                    throw new RuleFormatException("Illegal rule: " + rule);
+                }
+                // TODO: Parse timeout specifications, etc.
+            }
+
+            mRewrite = rewrite;
+            mBlock = block;
+        }
+
+        /** Create the default Rule. */
+        private Rule() {
+            mName = "DEFAULT";
+            mPrefix = "";
+            mRewrite = null;
+            mBlock = false;
+        }
+
+        /**
+         * Apply the rule to a particular URL (assumed to match the rule).
+         * @param url to rewrite or modify.
+         * @return modified URL, or null if the URL is blocked.
+         */
+         public String apply(String url) {
+             if (mBlock) {
+                 return null;
+             } else if (mRewrite != null) {
+                 return mRewrite + url.substring(mPrefix.length());
+             } else {
+                 return url;
+             }
+         }
+
+         /** More generic rules are greater than more specific rules. */
+         public int compareTo(Object o) {
+             return ((Rule) o).mPrefix.compareTo(mPrefix);
+         }
+    }
+
+    /** Cached rule set from Gservices. */
+    private static UrlRules sCachedRules = new UrlRules(new Rule[] {});
+
+    private static final Pattern PATTERN_SPACE_PLUS = Pattern.compile(" +");
+    private static final Pattern RULE_PATTERN = Pattern.compile("\\W");
+
+    /** Gservices token when sCachedRules was cached. */
+    private static Object sCachedVersionToken = null;
+
+    /** Currently active set of Rules. */
+    private final Rule[] mRules;
+
+    /** Regular expression with one capturing group for each Rule. */
+    private final Pattern mPattern;
+
+    /**
+     * Create a rewriter from an array of Rules.  Normally used only for
+     * testing.  Instead, use {@link #getRules} to get rules from Gservices.
+     * @param rules to use.
+     */
+    public UrlRules(Rule[] rules) {
+        // Sort the rules to put the most specific rules first.
+        Arrays.sort(rules);
+
+        // Construct a regular expression, escaping all the prefix strings.
+        StringBuilder pattern = new StringBuilder("(");
+        for (int i = 0; i < rules.length; ++i) {
+            if (i > 0) pattern.append(")|(");
+            pattern.append(RULE_PATTERN.matcher(rules[i].mPrefix).replaceAll("\\\\$0"));
+        }
+        mPattern = Pattern.compile(pattern.append(")").toString());
+        mRules = rules;
+    }
+
+    /**
+     * Match a string against every Rule and find one that matches.
+     * @param uri to match against the Rules in the rewriter.
+     * @return the most specific matching Rule, or Rule.DEFAULT if none match.
+     */
+    public Rule matchRule(String url) {
+        Matcher matcher = mPattern.matcher(url);
+        if (matcher.lookingAt()) {
+            for (int i = 0; i < mRules.length; ++i) {
+                if (matcher.group(i + 1) != null) {
+                    return mRules[i];  // Rules are sorted most specific first.
+                }
+            }
+        }
+        return Rule.DEFAULT;
+    }
+
+    /**
+     * Get the (possibly cached) UrlRules based on the rules in Gservices.
+     * @param resolver to use for accessing the Gservices database.
+     * @return an updated UrlRules instance
+     */
+    public static synchronized UrlRules getRules(ContentResolver resolver) {
+        Object versionToken = Gservices.getVersionToken(resolver);
+
+        if (versionToken == UrlRules.sCachedVersionToken) {
+            // The token is the same, so the rules are the same.
+            if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+                Log.v("UrlRules", "Using cached rules, versionToken: " + versionToken);
+            }
+            return sCachedRules;
+        }
+
+        if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+            Log.v("UrlRules", "Scanning for Gservices \"url:*\" rules");
+        }
+
+        // Get all the Gservices settings with names starting with "url:".
+        Map<String, String> rulesMap = Gservices.getStringsByPrefix(resolver, "url:");
+        ArrayList<Rule> rules = new ArrayList<Rule>();
+
+        for (Map.Entry<String, String> entry : rulesMap.entrySet()) {
+            try {
+                String name = entry.getKey().substring(4);  // "url:X"
+                String value = entry.getValue();
+                if (value == null || value.length() == 0) continue;
+                if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+                    Log.v("UrlRules", "  Rule " + name + ": " + value);
+                }
+                rules.add(new Rule(name, value));
+            } catch (RuleFormatException e) {
+                // Oops, Gservices has an invalid rule!  Skip it.
+                Log.e("UrlRules", "Invalid rule from Gservices", e);
+            }
+        }
+
+        sCachedRules = new UrlRules(rules.toArray(new Rule[rules.size()]));
+        sCachedVersionToken = versionToken;
+
+        if (Log.isLoggable("UrlRules", Log.VERBOSE)) {
+            Log.v("UrlRules", "New rules stored, versionToken: " + versionToken);
+        }
+
+        return sCachedRules;
+    }
+}
diff --git a/src/com/android/dialer/lookup/opencnam/OpenCnamReverseLookup.java b/src/com/android/dialer/lookup/opencnam/OpenCnamReverseLookup.java
new file mode 100644
index 0000000..08be170
--- /dev/null
+++ b/src/com/android/dialer/lookup/opencnam/OpenCnamReverseLookup.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.opencnam;
+
+import com.android.dialer.lookup.ReverseLookup;
+import com.android.incallui.service.PhoneNumberServiceImpl.PhoneNumberInfoImpl;
+
+import android.content.Context;
+import android.util.Log;
+import android.util.Pair;
+
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+public class OpenCnamReverseLookup extends ReverseLookup {
+    private static final String TAG =
+            OpenCnamReverseLookup.class.getSimpleName();
+
+    private static final String LOOKUP_URL =
+            "https://api.opencnam.com/v2/phone/";
+
+    public OpenCnamReverseLookup(Context context) {
+    }
+
+    /**
+     * Lookup image
+     *
+     * @param context The application context
+     * @param url The image URL
+     * @param data Extra data (a authentication token, perhaps)
+     */
+    public byte[] lookupImage(Context context, String url, Object data) {
+        return null;
+    }
+
+    /**
+     * Perform phone number lookup.
+     *
+     * @param context The application context
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param isIncoming Whether the call is incoming or outgoing
+     * @return The phone number info object
+     */
+    public Pair<PhoneNumberInfoImpl, Object> lookupNumber(
+            Context context, String normalizedNumber, String formattedNumber,
+            boolean isIncoming) {
+        String displayName;
+        try {
+            displayName = httpGetRequest(normalizedNumber);
+            Log.d(TAG, "Reverse lookup returned name: " + displayName);
+        } catch (IOException e) {
+            return null;
+        }
+
+        // Check displayName. The free tier of the service will return the
+        // following for some numbers:
+        // "CNAM for phone "NORMALIZED" is currently unavailable for Hobbyist Tier users."
+
+        if (displayName.contains("Hobbyist Tier")) {
+            return null;
+        }
+
+        String number = formattedNumber != null
+                ? formattedNumber : normalizedNumber;
+
+        ContactBuilder builder = new ContactBuilder(
+                normalizedNumber, formattedNumber);
+
+        ContactBuilder.Name n = new ContactBuilder.Name();
+        n.displayName = displayName;
+        builder.setName(n);
+
+        ContactBuilder.PhoneNumber pn = new ContactBuilder.PhoneNumber();
+        pn.number = number;
+        pn.type = Phone.TYPE_MAIN;
+        builder.addPhoneNumber(pn);
+
+        builder.setPhotoUri(ContactBuilder.PHOTO_URI_BUSINESS);
+
+        return Pair.create(builder.build(), null);
+    }
+
+    private String httpGetRequest(String number) throws IOException {
+        HttpClient client = new DefaultHttpClient();
+        HttpGet request = new HttpGet(LOOKUP_URL + number);
+
+        HttpResponse response = client.execute(request);
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        response.getEntity().writeTo(out);
+
+        return new String(out.toByteArray());
+    }
+}
diff --git a/src/com/android/dialer/lookup/openstreetmap/OpenStreetMapForwardLookup.java b/src/com/android/dialer/lookup/openstreetmap/OpenStreetMapForwardLookup.java
new file mode 100644
index 0000000..a3525d3
--- /dev/null
+++ b/src/com/android/dialer/lookup/openstreetmap/OpenStreetMapForwardLookup.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2014 The OmniROM Project
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Partially based on OmniROM's implementation
+
+package com.android.dialer.lookup.openstreetmap;
+
+import com.android.dialer.lookup.ForwardLookup;
+
+import android.content.Context;
+import android.location.Location;
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class OpenStreetMapForwardLookup extends ForwardLookup {
+    private static final String TAG =
+            OpenStreetMapForwardLookup.class.getSimpleName();
+
+    /** Search within radius (meters) */
+    private static final int RADIUS = 30000;
+
+    /** Query URL */
+    private static final String LOOKUP_URL =
+            "http://overpass-api.de/api/interpreter";
+
+    private static final String LOOKUP_QUERY =
+            "[out:json];node[name~\"%s\"][phone](around:%d,%f,%f);out body;";
+
+    private static final String RESULT_ELEMENTS = "elements";
+    private static final String RESULT_TAGS = "tags";
+    private static final String TAG_NAME = "name";
+    private static final String TAG_PHONE = "phone";
+    private static final String TAG_HOUSENUMBER = "addr:housenumber";
+    private static final String TAG_STREET = "addr:street";
+    private static final String TAG_CITY = "addr:city";
+    private static final String TAG_POSTCODE = "addr:postcode";
+    private static final String TAG_WEBSITE = "website";
+
+    public OpenStreetMapForwardLookup(Context context) {
+    }
+
+    public ForwardLookupDetails[] lookup(Context context,
+            String filter, Location lastLocation) {
+
+        // The OSM API doesn't support case-insentive searches, but does
+        // support regular expressions.
+        String regex = "";
+        for (int i = 0; i < filter.length(); i++) {
+            char c = filter.charAt(i);
+            regex += "[" + Character.toUpperCase(c)
+                    + Character.toLowerCase(c) + "]";
+        }
+
+        String request = String.format(LOOKUP_QUERY, regex, RADIUS,
+                lastLocation.getLatitude(), lastLocation.getLongitude());
+
+        Log.v(TAG, "POST'ing: " + request);
+
+        try {
+            String httpResponse = httpPostRequest(request);
+
+            JSONObject results = new JSONObject(httpResponse);
+
+            return getEntries(results);
+        } catch (IOException e) {
+            Log.e(TAG, "Failed to execute query", e);
+        } catch (JSONException e) {
+            Log.e(TAG, "JSON error", e);
+        }
+
+        return null;
+    }
+
+    private ForwardLookupDetails[] getEntries(JSONObject results)
+            throws JSONException {
+        ArrayList<ForwardLookupDetails> details =
+                new ArrayList<ForwardLookupDetails>();
+
+        JSONArray elements = results.getJSONArray(RESULT_ELEMENTS);
+
+        for (int i = 0; i < elements.length(); i++) {
+            ForwardLookupDetails fld = new ForwardLookupDetails();
+
+            try {
+                JSONObject element = elements.getJSONObject(i);
+                JSONObject tags = element.getJSONObject(RESULT_TAGS);
+
+                String displayName = tags.getString(TAG_NAME);
+                String phoneNumber = tags.getString(TAG_PHONE);
+
+                // Take the first number if there are multiple
+                if (phoneNumber.contains(";")) {
+                    phoneNumber = phoneNumber.split(";")[0];
+                    phoneNumber = phoneNumber.trim();
+                }
+
+                // The address is split
+                String addressHouseNumber =
+                        tags.optString(TAG_HOUSENUMBER, null);
+                String addressStreet = tags.optString(TAG_STREET, null);
+                String addressCity = tags.optString(TAG_CITY, null);
+                String addressPostCode = tags.optString(TAG_POSTCODE, null);
+
+                String address = String.format(
+                        "%s %s, %s %s",
+                        addressHouseNumber != null ? addressHouseNumber : "",
+                        addressStreet != null ? addressStreet : "",
+                        addressCity != null ? addressCity : "",
+                        addressPostCode != null ? addressPostCode : "");
+
+                address = address.trim().replaceAll("\\s+", " ");
+
+                if (address.length() == 0) {
+                    address = null;
+                }
+
+                String website = tags.optString(TAG_WEBSITE, null);
+
+                fld.setDisplayName(displayName);
+                fld.setPhoneNumber(phoneNumber);
+                fld.setAddress(address);
+                fld.setWebsite(website);
+
+                details.add(fld);
+            } catch (JSONException e) {
+                Log.e(TAG, "Skipping the suggestions at index " + i, e);
+            }
+        }
+
+        if (details.size() > 0) {
+            return details.toArray(new ForwardLookupDetails[details.size()]);
+        } else {
+            return null;
+        }
+    }
+
+    private String httpPostRequest(String query) throws IOException {
+        HttpClient client = new DefaultHttpClient();
+        HttpPost post = new HttpPost(LOOKUP_URL);
+
+        post.setEntity(new StringEntity(query));
+
+        HttpResponse response = client.execute(post);
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        response.getEntity().writeTo(out);
+
+        return new String(out.toByteArray());
+    }
+}
diff --git a/src/com/android/dialer/lookup/whitepages/WhitePagesApi.java b/src/com/android/dialer/lookup/whitepages/WhitePagesApi.java
new file mode 100644
index 0000000..469e29e
--- /dev/null
+++ b/src/com/android/dialer/lookup/whitepages/WhitePagesApi.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.whitepages;
+
+import com.android.services.telephony.common.MoreStrings;
+
+import android.util.Log;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class WhitePagesApi {
+    private static final String TAG = WhitePagesApi.class.getSimpleName();
+
+    private static final String USER_AGENT =
+            "Mozilla/5.0 (X11; Linux x86_64; rv:26.0) Gecko/20100101 Firefox/26.0";
+    private static final String LOOKUP_URL =
+            "http://www.whitepages.com/search/ReversePhone?full_phone=";
+    private static final String[] COOKIE_REGEXES = {
+            "distil_RID=([A-Za-z0-9\\-]+)", "PID=([A-Za-z0-9\\-]+)" };
+    private static final String COOKIE = "D_UID";
+
+    private String mNumber = null;
+    private String mOutput = null;
+    private String mCookie = null;
+    private ContactInfo mInfo = null;
+
+    public WhitePagesApi(String number) {
+        mNumber = number;
+    }
+
+    private void fetchPage() throws IOException {
+        mOutput = httpGet(LOOKUP_URL + mNumber);
+    }
+
+    private void findUuidAndReload() throws IOException {
+        for (String regex : COOKIE_REGEXES) {
+            Pattern p = Pattern.compile(regex, Pattern.DOTALL);
+            Matcher m = p.matcher(mOutput);
+            if (m.find()) {
+                mCookie = m.group(1).trim();
+                fetchPage();
+                break;
+            }
+        }
+    }
+
+    private String httpGet(String url) throws IOException {
+        String[] split = url.split("=");
+        Log.d(TAG, "Fetching " + split[0] + "="
+                + MoreStrings.toSafeString(split[1]));
+
+        HttpClient client = new DefaultHttpClient();
+        HttpGet get = new HttpGet(url);
+
+        get.setHeader("User-Agent", USER_AGENT);
+
+        if (mCookie != null) {
+            get.setHeader("Cookie", COOKIE + "=" + mCookie);
+        }
+
+        HttpResponse response = client.execute(get);
+        int status = response.getStatusLine().getStatusCode();
+
+        // Android's org.apache.http doesn't have the RedirectStrategy class
+        if (status == HttpStatus.SC_MOVED_PERMANENTLY
+                || status == HttpStatus.SC_MOVED_TEMPORARILY) {
+            Header[] headers = response.getHeaders("Location");
+
+            if (headers != null && headers.length != 0) {
+                String newUrl = headers[headers.length - 1].getValue();
+                return httpGet(newUrl);
+            } else {
+                return null;
+            }
+        }
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        response.getEntity().writeTo(out);
+
+        return new String(out.toByteArray());
+    }
+
+    private void buildContactInfo() {
+        Matcher m;
+
+        // Name
+        Pattern regexName = Pattern
+                .compile("<h2.*?>Send (.*?)&#39;s details to phone</h2>",
+                        Pattern.DOTALL);
+        String name = null;
+
+        m = regexName.matcher(mOutput);
+        if (m.find()) {
+            name = m.group(1).trim();
+        }
+
+        // Use summary if name doesn't exist
+        if (name == null) {
+            Pattern regexSummary = Pattern.compile(
+                    "<span\\s*class=\"subtitle.*?>\\s*\n?(.*?)\n?\\s*</span>",
+                    Pattern.DOTALL);
+
+            m = regexSummary.matcher(mOutput);
+            if (m.find()) {
+                name = m.group(1).trim();
+            }
+        }
+
+        if (name != null) {
+            name = name.replaceAll("&amp;", "&");
+        }
+
+        // Formatted phone number
+        Pattern regexPhoneNumber = Pattern.compile(
+                "Full Number:</span>([0-9\\-\\+\\(\\)]+)</li>", Pattern.DOTALL);
+        String phoneNumber = null;
+
+        m = regexPhoneNumber.matcher(mOutput);
+        if (m.find()) {
+            phoneNumber = m.group(1).trim();
+        }
+
+        // Address
+        String regexBase = "<span\\s+class=\"%s[^\"]+\"\\s*>([^<]*)</span>";
+
+        Pattern regexAddressPrimary = Pattern.compile(
+                String.format(regexBase, "address-primary"), Pattern.DOTALL);
+        Pattern regexAddressSecondary = Pattern.compile(
+                String.format(regexBase, "address-secondary"), Pattern.DOTALL);
+        Pattern regexAddressLocation = Pattern.compile(
+                String.format(regexBase, "address-location"), Pattern.DOTALL);
+
+        String addressPrimary = null;
+        String addressSecondary = null;
+        String addressLocation = null;
+
+        m = regexAddressPrimary.matcher(mOutput);
+        if (m.find()) {
+            addressPrimary = m.group(1).trim();
+        }
+
+        m = regexAddressSecondary.matcher(mOutput);
+        if (m.find()) {
+            addressSecondary = m.group(1).trim();
+        }
+
+        m = regexAddressLocation.matcher(mOutput);
+        if (m.find()) {
+            addressLocation = m.group(1).trim();
+        }
+
+        StringBuilder sb = new StringBuilder();
+
+        if (addressPrimary != null && addressPrimary.length() != 0) {
+            sb.append(addressPrimary);
+        }
+        if (addressSecondary != null && addressSecondary.length() != 0) {
+            sb.append(", ");
+            sb.append(addressSecondary);
+        }
+        if (addressLocation != null && addressLocation.length() != 0) {
+            sb.append(", ");
+            sb.append(addressLocation);
+        }
+
+        String address = sb.toString();
+        if (address.length() == 0) {
+            address = null;
+        }
+
+        ContactInfo info = new ContactInfo();
+        info.name = name;
+        info.address = address;
+        info.formattedNumber = phoneNumber != null ? phoneNumber : mNumber;
+        info.website = LOOKUP_URL + info.formattedNumber;
+        mInfo = info;
+    }
+
+    public ContactInfo getContactInfo() throws IOException {
+        if (mInfo == null) {
+            fetchPage();
+            findUuidAndReload();
+
+            buildContactInfo();
+        }
+
+        return mInfo;
+    }
+
+    public static class ContactInfo {
+        String name;
+        String address;
+        String formattedNumber;
+        String website;
+    }
+}
diff --git a/src/com/android/dialer/lookup/whitepages/WhitePagesReverseLookup.java b/src/com/android/dialer/lookup/whitepages/WhitePagesReverseLookup.java
new file mode 100644
index 0000000..fb05bdb
--- /dev/null
+++ b/src/com/android/dialer/lookup/whitepages/WhitePagesReverseLookup.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.whitepages;
+
+import com.android.dialer.lookup.ReverseLookup;
+import com.android.incallui.service.PhoneNumberServiceImpl.PhoneNumberInfoImpl;
+
+import android.content.Context;
+import android.util.Pair;
+
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
+import android.provider.ContactsContract.CommonDataKinds.Website;
+
+import java.io.IOException;
+
+public class WhitePagesReverseLookup extends ReverseLookup {
+    private static final String TAG =
+            WhitePagesReverseLookup.class.getSimpleName();
+
+    public WhitePagesReverseLookup(Context context) {
+    }
+
+    /**
+     * Lookup image
+     *
+     * @param context The application context
+     * @param url The image URL
+     * @param data Extra data (a authentication token, perhaps)
+     */
+    public byte[] lookupImage(Context context, String url, Object data) {
+        return null;
+    }
+
+    /**
+     * Perform phone number lookup.
+     *
+     * @param context The application context
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param isIncoming Whether the call is incoming or outgoing
+     * @return The phone number info object
+     */
+    public Pair<PhoneNumberInfoImpl, Object> lookupNumber(
+            Context context, String normalizedNumber, String formattedNumber,
+            boolean isIncoming) {
+        WhitePagesApi wpa = new WhitePagesApi(normalizedNumber);
+        WhitePagesApi.ContactInfo info = null;
+
+        try {
+            info = wpa.getContactInfo();
+        } catch (IOException e) {
+            return null;
+        }
+
+        if (info.name == null) {
+            return null;
+        }
+
+        ContactBuilder builder = new ContactBuilder(
+                normalizedNumber, formattedNumber);
+
+        ContactBuilder.Name n = new ContactBuilder.Name();
+        n.displayName = info.name;
+        builder.setName(n);
+
+        ContactBuilder.PhoneNumber pn = new ContactBuilder.PhoneNumber();
+        pn.number = info.formattedNumber;
+        pn.type = Phone.TYPE_MAIN;
+        builder.addPhoneNumber(pn);
+
+        if (info.address != null) {
+            ContactBuilder.Address a = new ContactBuilder.Address();
+            a.formattedAddress = info.address;
+            a.type = StructuredPostal.TYPE_HOME;
+            builder.addAddress(a);
+        }
+
+        ContactBuilder.WebsiteUrl w = new ContactBuilder.WebsiteUrl();
+        w.url = info.website;
+        w.type = Website.TYPE_PROFILE;
+        builder.addWebsite(w);
+
+        return Pair.create(builder.build(), null);
+    }
+}
diff --git a/src/com/android/dialer/lookup/yellowpages/YellowPagesApi.java b/src/com/android/dialer/lookup/yellowpages/YellowPagesApi.java
new file mode 100644
index 0000000..e39793a
--- /dev/null
+++ b/src/com/android/dialer/lookup/yellowpages/YellowPagesApi.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.yellowpages;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class YellowPagesApi {
+    private static final String TAG = YellowPagesApi.class.getSimpleName();
+
+    private static final String LOOKUP_URL = "http://www.yellowpages.com/phone?phone_search_terms=";
+
+    private String mNumber = null;
+    public String mOutput = null;
+    private ContactInfo mInfo = null;
+
+    public YellowPagesApi(String number) {
+        mNumber = number;
+    }
+
+    private void fetchPage() throws IOException {
+        mOutput = httpGet(LOOKUP_URL + mNumber);
+    }
+
+    private String httpGet(String url) throws IOException {
+        HttpClient client = new DefaultHttpClient();
+        HttpGet get = new HttpGet(url);
+
+        HttpResponse response = client.execute(get);
+        int status = response.getStatusLine().getStatusCode();
+
+        // Android's org.apache.http doesn't have the RedirectStrategy class
+        if (status == HttpStatus.SC_MOVED_PERMANENTLY
+                || status == HttpStatus.SC_MOVED_TEMPORARILY) {
+            Header[] headers = response.getHeaders("Location");
+
+            if (headers != null && headers.length != 0) {
+                String newUrl = headers[headers.length - 1].getValue();
+                return httpGet(newUrl);
+            } else {
+                return null;
+            }
+        }
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        response.getEntity().writeTo(out);
+
+        return new String(out.toByteArray());
+    }
+
+    private String getPhotoUrl(String website) throws IOException {
+        String output = httpGet(website);
+
+        Matcher m;
+
+        Pattern regexGallery = Pattern.compile(
+                "href=\"([^\"]+gallery\\?lid=[^\"]+)\"", Pattern.DOTALL);
+
+        String galleryUrl = null;
+
+        m = regexGallery.matcher(output);
+        if (m.find()) {
+            galleryUrl = "http://www.yellowpages.com" + m.group(1).trim();
+        }
+
+        if (galleryUrl == null) {
+            return null;
+        }
+
+        // Get first image
+
+        output = httpGet(galleryUrl);
+
+        Pattern regexPhoto = Pattern.compile(
+                "\"type\":\"image\",\"src\":\"([^\"]+)\"", Pattern.DOTALL);
+
+        String photoUrl = null;
+
+        m = regexPhoto.matcher(output);
+        if (m.find()) {
+            photoUrl = m.group(1).trim();
+        }
+
+        return photoUrl;
+    }
+
+    private void buildContactInfo() throws IOException {
+        Matcher m;
+
+        // Name
+        Pattern regexNameAndWebsite = Pattern.compile(
+                "<a href=\"([^>]+?)\"[^>]+?class=\"url[^>]+?>([^<]+)</a>",
+                Pattern.DOTALL);
+        String name = null;
+        String website = null;
+
+        m = regexNameAndWebsite.matcher(mOutput);
+        if (m.find()) {
+            website = m.group(1).trim();
+            name = m.group(2).trim();
+        }
+
+        // Formatted phone number
+        Pattern regexPhoneNumber = Pattern.compile(
+                "business-phone.*?>\n*([^\n<]+)\n*<", Pattern.DOTALL);
+        String phoneNumber = null;
+
+        m = regexPhoneNumber.matcher(mOutput);
+        if (m.find()) {
+            phoneNumber = m.group(1).trim();
+        }
+
+        // Address
+        Pattern regexAddressStreet = Pattern.compile(
+                "street-address.*?>\n*([^\n<]+)\n*<", Pattern.DOTALL);
+        Pattern regexAddressCity = Pattern.compile(
+                "locality.*?>\n*([^\n<]+)\n*<", Pattern.DOTALL);
+        Pattern regexAddressState = Pattern.compile(
+                "region.*?>\n*([^\n<]+)\n*<", Pattern.DOTALL);
+        Pattern regexAddressZip = Pattern.compile(
+                "postal-code.*?>\n*([^\n<]+)\n*<", Pattern.DOTALL);
+
+        String addressStreet = null;
+        String addressCity = null;
+        String addressState = null;
+        String addressZip = null;
+
+        m = regexAddressStreet.matcher(mOutput);
+        if (m.find()) {
+            addressStreet = m.group(1).trim();
+            if (addressStreet.endsWith(",")) {
+                addressStreet = addressStreet.substring(0,
+                        addressStreet.length() - 1);
+            }
+        }
+
+        m = regexAddressCity.matcher(mOutput);
+        if (m.find()) {
+            addressCity = m.group(1).trim();
+        }
+
+        m = regexAddressState.matcher(mOutput);
+        if (m.find()) {
+            addressState = m.group(1).trim();
+        }
+
+        m = regexAddressZip.matcher(mOutput);
+        if (m.find()) {
+            addressZip = m.group(1).trim();
+        }
+
+        StringBuilder sb = new StringBuilder();
+
+        if (addressStreet != null && addressStreet.length() != 0) {
+            sb.append(addressStreet);
+        }
+        if (addressCity != null && addressCity.length() != 0) {
+            sb.append(", ");
+            sb.append(addressCity);
+        }
+        if (addressState != null && addressState.length() != 0) {
+            sb.append(", ");
+            sb.append(addressState);
+        }
+        if (addressZip != null && addressZip.length() != 0) {
+            sb.append(", ");
+            sb.append(addressZip);
+        }
+
+        String address = sb.toString();
+        if (address.length() == 0) {
+            address = null;
+        }
+
+        String photoUrl = null;
+        if (website != null) {
+            photoUrl = getPhotoUrl(website);
+        }
+
+        ContactInfo info = new ContactInfo();
+        info.name = name;
+        info.address = address;
+        info.formattedNumber = phoneNumber != null ? phoneNumber : mNumber;
+        info.website = website;
+        info.photoUrl = photoUrl;
+        mInfo = info;
+    }
+
+    public ContactInfo getContactInfo() throws IOException {
+        if (mInfo == null) {
+            fetchPage();
+
+            buildContactInfo();
+        }
+
+        return mInfo;
+    }
+
+    public static class ContactInfo {
+        String name;
+        String address;
+        String formattedNumber;
+        String website;
+        String photoUrl;
+    }
+}
diff --git a/src/com/android/dialer/lookup/yellowpages/YellowPagesReverseLookup.java b/src/com/android/dialer/lookup/yellowpages/YellowPagesReverseLookup.java
new file mode 100644
index 0000000..dbd9499
--- /dev/null
+++ b/src/com/android/dialer/lookup/yellowpages/YellowPagesReverseLookup.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.yellowpages;
+
+import com.android.dialer.lookup.ReverseLookup;
+import com.android.incallui.service.PhoneNumberServiceImpl.PhoneNumberInfoImpl;
+
+import android.content.Context;
+import android.util.Log;
+import android.util.Pair;
+
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
+import android.provider.ContactsContract.CommonDataKinds.Website;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+public class YellowPagesReverseLookup extends ReverseLookup {
+    private static final String TAG =
+            YellowPagesReverseLookup.class.getSimpleName();
+
+    public YellowPagesReverseLookup(Context context) {
+    }
+
+    /**
+     * Lookup image
+     *
+     * @param context The application context
+     * @param url The image URL
+     * @param data Extra data (a authentication token, perhaps)
+     */
+    public byte[] lookupImage(Context context, String url, Object data) {
+        if (url == null) {
+            throw new NullPointerException("URL is null");
+        }
+
+        Log.e(TAG, "Fetching " + url);
+
+        HttpClient client = new DefaultHttpClient();
+        HttpGet request = new HttpGet(url);
+
+        try {
+            HttpResponse response = client.execute(request);
+
+            int responseCode = response.getStatusLine().getStatusCode();
+
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            response.getEntity().writeTo(out);
+            byte[] responseBytes = out.toByteArray();
+
+            if (responseCode == HttpStatus.SC_OK) {
+                return responseBytes;
+            }
+        } catch (IOException e) {
+            Log.e(TAG, "Failed to retrieve image", e);
+        }
+
+        return null;
+    }
+
+    /**
+     * Perform phone number lookup.
+     *
+     * @param context The application context
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param isIncoming Whether the call is incoming or outgoing
+     * @return The phone number info object
+     */
+    public Pair<PhoneNumberInfoImpl, Object> lookupNumber(
+            Context context, String normalizedNumber, String formattedNumber,
+            boolean isIncoming) {
+        YellowPagesApi ypa = new YellowPagesApi(normalizedNumber);
+        YellowPagesApi.ContactInfo info = null;
+
+        try {
+            info = ypa.getContactInfo();
+        } catch (IOException e) {
+            return null;
+        }
+
+        if (info.name == null) {
+            return null;
+        }
+
+        ContactBuilder builder = new ContactBuilder(
+                normalizedNumber, formattedNumber);
+
+        ContactBuilder.Name n = new ContactBuilder.Name();
+        n.displayName = info.name;
+        builder.setName(n);
+
+        ContactBuilder.PhoneNumber pn = new ContactBuilder.PhoneNumber();
+        pn.number = info.formattedNumber;
+        pn.type = Phone.TYPE_MAIN;
+        builder.addPhoneNumber(pn);
+
+        if (info.address != null) {
+            ContactBuilder.Address a = new ContactBuilder.Address();
+            a.formattedAddress = info.address;
+            a.type = StructuredPostal.TYPE_HOME;
+            builder.addAddress(a);
+        }
+
+        ContactBuilder.WebsiteUrl w = new ContactBuilder.WebsiteUrl();
+        w.url = info.website;
+        w.type = Website.TYPE_PROFILE;
+        builder.addWebsite(w);
+
+        if (info.photoUrl != null) {
+            builder.setPhotoUri(info.photoUrl);
+        } else {
+            builder.setPhotoUri(ContactBuilder.PHOTO_URI_BUSINESS);
+        }
+
+        return Pair.create(builder.build(), null);
+    }
+}
diff --git a/src/com/android/dialer/lookup/zabasearch/ZabaSearchApi.java b/src/com/android/dialer/lookup/zabasearch/ZabaSearchApi.java
new file mode 100644
index 0000000..385e2d0
--- /dev/null
+++ b/src/com/android/dialer/lookup/zabasearch/ZabaSearchApi.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.zabasearch;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+public class ZabaSearchApi {
+    private static final String TAG = ZabaSearchApi.class.getSimpleName();
+
+    private static final String LOOKUP_URL = "http://www.zabasearch.com/phone/";
+
+    private String mNumber = null;
+    public String mOutput = null;
+    private ContactInfo mInfo = null;
+
+    public ZabaSearchApi(String number) {
+        mNumber = number;
+    }
+
+    private void fetchPage() throws IOException {
+        mOutput = httpGet(LOOKUP_URL + mNumber);
+    }
+
+    private String httpGet(String url) throws IOException {
+        HttpClient client = new DefaultHttpClient();
+        HttpGet get = new HttpGet(url);
+
+        HttpResponse response = client.execute(get);
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        response.getEntity().writeTo(out);
+
+        return new String(out.toByteArray());
+    }
+
+    private void buildContactInfo() {
+        Matcher m;
+
+        // Name
+        Pattern regexName = Pattern.compile(
+                "itemprop=\"?name\"?>([^<]+)<", Pattern.DOTALL);
+        String name = null;
+
+        m = regexName.matcher(mOutput);
+        if (m.find()) {
+            name = m.group(1).trim();
+        }
+
+        // Formatted phone number
+        Pattern regexPhoneNumber = Pattern.compile(
+                "itemprop=\"?telephone\"?>([^<]+)<", Pattern.DOTALL);
+        String phoneNumber = null;
+
+        m = regexPhoneNumber.matcher(mOutput);
+        if (m.find()) {
+            phoneNumber = m.group(1).trim();
+        }
+
+        // Address
+        Pattern regexStreet = Pattern.compile(
+                "itemprop=\"?streetAddress\"?>([^<]+?)(&nbsp;)*<", Pattern.DOTALL);
+        Pattern regexCity = Pattern.compile(
+                "itemprop=\"?addressLocality\"?>([^<]+)<", Pattern.DOTALL);
+        Pattern regexState = Pattern.compile(
+                "itemprop=\"?addressRegion\"?>([^<]+)<", Pattern.DOTALL);
+        Pattern regexZip = Pattern.compile(
+                "itemprop=\"?postalCode\"?>([^<]+)<", Pattern.DOTALL);
+
+        String addressStreet = null;
+        String addressCity = null;
+        String addressState = null;
+        String addressZip = null;
+
+        m = regexStreet.matcher(mOutput);
+        if (m.find()) {
+            addressStreet = m.group(1).trim();
+        }
+
+        m = regexCity.matcher(mOutput);
+        if (m.find()) {
+            addressCity = m.group(1).trim();
+        }
+
+        m = regexState.matcher(mOutput);
+        if (m.find()) {
+            addressState = m.group(1).trim();
+        }
+
+        m = regexZip.matcher(mOutput);
+        if (m.find()) {
+            addressZip = m.group(1).trim();
+        }
+
+        StringBuilder sb = new StringBuilder();
+
+        if (addressStreet != null && addressStreet.length() != 0) {
+            sb.append(addressStreet);
+        }
+        if (addressCity != null && addressCity.length() != 0) {
+            sb.append(", ");
+            sb.append(addressCity);
+        }
+        if (addressState != null && addressState.length() != 0) {
+            sb.append(", ");
+            sb.append(addressState);
+        }
+        if (addressZip != null && addressZip.length() != 0) {
+            sb.append(", ");
+            sb.append(addressZip);
+        }
+
+        String address = sb.toString();
+        if (address.length() == 0) {
+            address = null;
+        }
+
+        ContactInfo info = new ContactInfo();
+        info.name = name;
+        info.address = address;
+        info.formattedNumber = mNumber;
+        info.website = LOOKUP_URL + info.formattedNumber;
+        mInfo = info;
+    }
+
+    public ContactInfo getContactInfo() throws IOException {
+        if (mInfo == null) {
+            fetchPage();
+
+            buildContactInfo();
+        }
+
+        return mInfo;
+    }
+
+    public static class ContactInfo {
+        String name;
+        String address;
+        String formattedNumber;
+        String website;
+    }
+}
diff --git a/src/com/android/dialer/lookup/zabasearch/ZabaSearchReverseLookup.java b/src/com/android/dialer/lookup/zabasearch/ZabaSearchReverseLookup.java
new file mode 100644
index 0000000..5312a31
--- /dev/null
+++ b/src/com/android/dialer/lookup/zabasearch/ZabaSearchReverseLookup.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.lookup.zabasearch;
+
+import com.android.dialer.lookup.ReverseLookup;
+import com.android.incallui.service.PhoneNumberServiceImpl.PhoneNumberInfoImpl;
+
+import android.content.Context;
+import android.util.Pair;
+
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.provider.ContactsContract.CommonDataKinds.StructuredPostal;
+import android.provider.ContactsContract.CommonDataKinds.Website;
+
+import java.io.IOException;
+
+public class ZabaSearchReverseLookup extends ReverseLookup {
+    private static final String TAG =
+            ZabaSearchReverseLookup.class.getSimpleName();
+
+    public ZabaSearchReverseLookup(Context context) {
+    }
+
+    /**
+     * Lookup image
+     *
+     * @param context The application context
+     * @param url The image URL
+     * @param data Extra data (a authentication token, perhaps)
+     */
+    public byte[] lookupImage(Context context, String url, Object data) {
+        return null;
+    }
+
+    /**
+     * Perform phone number lookup.
+     *
+     * @param context The application context
+     * @param normalizedNumber The normalized phone number
+     * @param formattedNumber The formatted phone number
+     * @param isIncoming Whether the call is incoming or outgoing
+     * @return The phone number info object
+     */
+    public Pair<PhoneNumberInfoImpl, Object> lookupNumber(
+            Context context, String normalizedNumber, String formattedNumber,
+            boolean isIncoming) {
+        ZabaSearchApi zsa = new ZabaSearchApi(normalizedNumber);
+        ZabaSearchApi.ContactInfo info = null;
+
+        try {
+            info = zsa.getContactInfo();
+        } catch (IOException e) {
+            return null;
+        }
+
+        if (info.name == null) {
+            return null;
+        }
+
+        ContactBuilder builder = new ContactBuilder(
+                normalizedNumber, formattedNumber);
+
+        ContactBuilder.Name n = new ContactBuilder.Name();
+        n.displayName = info.name;
+        builder.setName(n);
+
+        ContactBuilder.PhoneNumber pn = new ContactBuilder.PhoneNumber();
+        pn.number = info.formattedNumber;
+        pn.type = Phone.TYPE_MAIN;
+        builder.addPhoneNumber(pn);
+
+        if (info.address != null) {
+            ContactBuilder.Address a = new ContactBuilder.Address();
+            a.formattedAddress = info.address;
+            a.type = StructuredPostal.TYPE_HOME;
+            builder.addAddress(a);
+        }
+
+        ContactBuilder.WebsiteUrl w = new ContactBuilder.WebsiteUrl();
+        w.url = info.website;
+        w.type = Website.TYPE_PROFILE;
+        builder.addWebsite(w);
+
+        return Pair.create(builder.build(), null);
+    }
+}
diff --git a/src/com/android/dialer/service/CachedNumberLookupServiceImpl.java b/src/com/android/dialer/service/CachedNumberLookupServiceImpl.java
new file mode 100644
index 0000000..c8590c9
--- /dev/null
+++ b/src/com/android/dialer/service/CachedNumberLookupServiceImpl.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2014 Xiao-Long Chen <chenxiaolong@cxl.epac.to>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.dialer.service;
+
+import com.android.dialer.calllog.ContactInfo;
+import com.android.dialer.database.DialerDatabaseHelper;
+import com.android.dialer.database.DialerDatabaseHelper.CachedContactsColumns;
+import com.android.dialer.database.DialerDatabaseHelper.CachedNumberQuery;
+import com.android.dialer.database.DialerDatabaseHelper.SmartDialDbColumns;
+import com.android.dialer.lookup.LookupSettings;
+import com.android.dialer.lookup.PhoneNumberCacheContract;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.text.TextUtils;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import libcore.io.IoUtils;
+
+public class CachedNumberLookupServiceImpl implements CachedNumberLookupService {
+    public static final int SOURCE_DIRECTORY = 1;
+    public static final int SOURCE_EXTENDED = 2;
+    public static final int SOURCE_BUSINESS = 3;
+    public static final int SOURCE_PERSON = 4;
+
+    public static class CachedContactInfoImpl implements CachedContactInfo {
+        private final ContactInfo mInfo;
+
+        public String lookupKey;
+
+        public long sourceId;
+        public String sourceName;
+        public int sourceType;
+
+        public CachedContactInfoImpl(ContactInfo info) {
+            if (info == null) {
+                info = ContactInfo.EMPTY;
+            }
+            mInfo = info;
+        }
+
+        @Override
+        public ContactInfo getContactInfo() {
+            return mInfo;
+        }
+
+        @Override
+        public void setDirectorySource(String name, long directoryId) {
+            setSource(SOURCE_DIRECTORY, name, directoryId);
+        }
+
+        @Override
+        public void setExtendedSource(String name, long directoryId) {
+            setSource(SOURCE_EXTENDED, name, directoryId);
+        }
+
+        @Override
+        public void setLookupKey(String key) {
+            lookupKey = key;
+        }
+
+        protected void setSource(int type, String name, long id) {
+            sourceType = type;
+            sourceName = name;
+            sourceId = id;
+            mInfo.sourceType = type;
+        }
+
+        public static boolean isBusiness(int type) {
+            return type == SOURCE_BUSINESS || type == SOURCE_EXTENDED;
+        }
+
+        public static boolean isLookupSource(int type) {
+            return type == SOURCE_BUSINESS || type == SOURCE_PERSON;
+        }
+
+        public int getSourceType() {
+            return sourceType;
+        }
+
+        public void setLookupSource(boolean isBusiness) {
+            int type;
+            if (isBusiness) {
+                type = SOURCE_BUSINESS;
+            } else {
+                type = SOURCE_PERSON;
+            }
+            setSource(type, "Caller ID", 0x7fffffff);
+        }
+    }
+
+    @Override
+    public CachedContactInfoImpl buildCachedContactInfo(ContactInfo info) {
+        return new CachedContactInfoImpl(info);
+    }
+
+    /**
+     * Perform a lookup using the cached number lookup service to return contact
+     * information stored in the cache that corresponds to the given number.
+     *
+     * @param context Valid context
+     * @param number Phone number to lookup the cache for
+     * @return A {@link CachedContactInfo} containing the contact information
+     * if the phone number is found in the cache, {@link ContactInfo#EMPTY} if
+     * the phone number was not found in the cache, and null if there was an
+     * error when querying the cache.
+     */
+    @Override
+    public CachedContactInfoImpl lookupCachedContactFromNumber(
+            Context context, String number) {
+        Cursor cursor = context.getContentResolver().query(
+                PhoneNumberCacheContract.getContactLookupUri(number),
+                CachedNumberQuery.PROJECTION, null, null, null);
+
+        if (cursor == null) {
+            return null;
+        }
+
+        try {
+            if (!cursor.moveToFirst()) {
+                return buildCachedContactInfo(ContactInfo.EMPTY);
+            }
+
+            int sourceType = cursor.getInt(CachedNumberQuery.CACHE_SOURCE_TYPE);
+
+            // If reverse lookup is disabled, remove the cache entries
+            if (CachedContactInfoImpl.isLookupSource(sourceType)
+                    && !LookupSettings.isReverseLookupEnabled(context)) {
+                purgePeopleApiCacheEntries(context);
+                return buildCachedContactInfo(ContactInfo.EMPTY);
+            }
+
+            // Build ContactInfo with cached information
+            ContactInfo info = new ContactInfo();
+
+            info.lookupUri = getContactUri(cursor);
+            info.name = cursor.getString(CachedNumberQuery.CACHE_DISPLAY_NAME);
+            info.type = cursor.getInt(CachedNumberQuery.CACHE_PHONE_TYPE);
+            info.label = cursor.getString(CachedNumberQuery.CACHE_PHONE_LABEL);
+
+            if (info.type == 0 && info.label == null) {
+                info.label = ContactInfo.GEOCODE_AS_LABEL;
+            }
+
+            info.number = cursor.getString(CachedNumberQuery.CACHE_NUMBER);
+            info.normalizedNumber = number;
+            info.formattedNumber = null;
+
+            info.photoId = 0;
+            info.photoUri = getPhotoUri(cursor, number);
+
+            CachedContactInfoImpl cachedContactInfo =
+                    buildCachedContactInfo(info);
+
+            cachedContactInfo.setSource(sourceType,
+                    cursor.getString(CachedNumberQuery.CACHE_SOURCE_NAME),
+                    cursor.getLong(CachedNumberQuery.CACHE_SOURCE_ID));
+
+            return cachedContactInfo;
+        } finally {
+            cursor.close();
+        }
+    }
+
+    @Override
+    public void addContact(Context context,
+            CachedContactInfo info) {
+        if (info instanceof CachedContactInfoImpl) {
+            CachedContactInfoImpl cachedInfo = (CachedContactInfoImpl) info;
+
+            Uri uri = PhoneNumberCacheContract.CONTACT_URI;
+            ContentValues contentValues = new ContentValues();
+            ContactInfo contactInfo = cachedInfo.getContactInfo();
+
+            if (contactInfo != null && contactInfo != ContactInfo.EMPTY) {
+                String number;
+                if (contactInfo.number != null) {
+                    number = contactInfo.number;
+                } else {
+                    number = contactInfo.normalizedNumber;
+                }
+
+                if (!TextUtils.isEmpty(number)) {
+                    contentValues.put(CachedContactsColumns.NUMBER, number);
+                    contentValues.put(CachedContactsColumns.PHONE_TYPE,
+                            contactInfo.type);
+                    contentValues.put(CachedContactsColumns.PHONE_LABEL,
+                            contactInfo.label);
+                    contentValues.put(SmartDialDbColumns.DISPLAY_NAME_PRIMARY,
+                            contactInfo.name);
+                    String photoUri;
+                    if (contactInfo.photoUri != null) {
+                        photoUri = contactInfo.photoUri.toString();
+                    } else {
+                        photoUri = null;
+                    }
+                    contentValues.put(CachedContactsColumns.PHOTO_URI, photoUri);
+                    contentValues.put(CachedContactsColumns.SOURCE_NAME,
+                            cachedInfo.sourceName);
+                    contentValues.put(CachedContactsColumns.SOURCE_TYPE,
+                            cachedInfo.sourceType);
+                    contentValues.put(CachedContactsColumns.SOURCE_ID,
+                            cachedInfo.sourceId);
+                    contentValues.put(CachedContactsColumns.LOOKUP_KEY,
+                            cachedInfo.lookupKey);
+                    context.getContentResolver().insert(uri, contentValues);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean isCacheUri(String uri) {
+        return uri.startsWith(
+                PhoneNumberCacheContract.AUTHORITY_URI.toString());
+    }
+
+    @Override
+    public boolean addPhoto(Context context, String number, byte[] photo) {
+        Uri uri = PhoneNumberCacheContract.getPhotoLookupUri(number);
+        OutputStream out = null;
+        try {
+            out = context.getContentResolver().openOutputStream(uri);
+            out.write(photo);
+            return true;
+        } catch (IOException e) {
+            return false;
+        } finally {
+            IoUtils.closeQuietly(out);
+        }
+    }
+
+    @Override
+    public void clearAllCacheEntries(Context context) {
+        DialerDatabaseHelper.getInstance(context).purgeAll();
+    }
+
+    public static void purgePeopleApiCacheEntries(Context context) {
+        DialerDatabaseHelper helper =
+                DialerDatabaseHelper.getInstance(context);
+
+        helper.purgeSource(SOURCE_BUSINESS);
+        helper.purgeSource(SOURCE_PERSON);
+    }
+
+    private Uri getContactUri(Cursor cursor) {
+        int sourceType = cursor.getInt(CachedNumberQuery.CACHE_SOURCE_TYPE);
+        String sourceId = cursor.getString(CachedNumberQuery.CACHE_SOURCE_ID);
+        String sourceName = cursor.getString(CachedNumberQuery.CACHE_SOURCE_NAME);
+        String lookupKey = cursor.getString(CachedNumberQuery.CACHE_LOOKUP_KEY);
+
+        if (!TextUtils.isEmpty(lookupKey) && !TextUtils.isEmpty(sourceId)) {
+            if (sourceType == SOURCE_DIRECTORY) {
+                return ContactsContract.Contacts.getLookupUri(0, lookupKey)
+                        .buildUpon().appendQueryParameter("directory", sourceId)
+                        .build();
+            } else if (sourceType == SOURCE_EXTENDED
+                    || sourceType == SOURCE_BUSINESS
+                    || sourceType == SOURCE_PERSON) {
+                Uri.Builder encodedFragment =
+                        ContactsContract.Contacts.CONTENT_LOOKUP_URI
+                        .buildUpon().appendPath("encoded")
+                        .encodedFragment(lookupKey);
+
+                if (!TextUtils.isEmpty(sourceName)) {
+                    encodedFragment.appendQueryParameter(
+                            "displayName", sourceName);
+                }
+
+                return encodedFragment.appendQueryParameter(
+                        "directory", sourceId).build();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Return photo or thumbnail URI if either is cached. Otherwise, return
+     * the default parameter (uri).
+     *
+     * @param cursor Cursor for database
+     * @param uri Default URI if there is no cached URI
+     * @return The photo or thumbnail URI
+     */
+    private Uri getPhotoUri(Cursor cursor, String number) {
+        int hasPhoto = cursor.getInt(CachedNumberQuery.CACHE_HAS_PHOTO);
+        int hasThumbnail = cursor.getInt(CachedNumberQuery.CACHE_HAS_THUMBNAIL);
+
+        if (hasPhoto != 0) {
+            return PhoneNumberCacheContract.getPhotoLookupUri(number);
+        } else if (hasThumbnail != 0) {
+            return PhoneNumberCacheContract.getThumbnailLookupUri(number);
+        }
+
+        String photoUri = cursor.getString(CachedNumberQuery.CACHE_PHOTO_URI);
+        if (photoUri != null) {
+            return Uri.parse(photoUri);
+        } else {
+            return null;
+        }
+    }
+}
diff --git a/src/com/android/dialerbind/ObjectFactory.java b/src/com/android/dialerbind/ObjectFactory.java
index c43dffc..f2e7a27 100644
--- a/src/com/android/dialerbind/ObjectFactory.java
+++ b/src/com/android/dialerbind/ObjectFactory.java
@@ -23,6 +23,7 @@ import android.content.Context;
 import com.android.dialer.calllog.CallLogAdapter;
 import com.android.dialer.calllog.ContactInfoHelper;
 import com.android.dialer.service.CachedNumberLookupService;
+import com.android.dialer.service.CachedNumberLookupServiceImpl;
 
 /**
  * Default static binding for various objects.
@@ -30,8 +31,7 @@ import com.android.dialer.service.CachedNumberLookupService;
 public class ObjectFactory {
 
     public static CachedNumberLookupService newCachedNumberLookupService() {
-        // no-op
-        return null;
+        return new CachedNumberLookupServiceImpl();
     }
 
     public static CallLogAdapter newCallLogAdapter(Context context, CallFetcher callFetcher,
-- 
1.8.5.4

